// @ts-nocheck
/* eslint-disable @typescript-eslint/no-explicit-any */
/**
 * AUTO-GENERATED API Service
 *
 * This file is automatically generated by scripts/generate-api-service-advanced.ts
 * DO NOT EDIT MANUALLY - Your changes will be overwritten
 *
 * Generated: 2026-02-11T17:26:04.478Z
 *
 * Provides offline/online mode switching for all entity operations:
 * - OFFLINE mode: Uses local Dexie database
 * - ONLINE mode: Uses API client
 */

import type { AllSamples, AssayBatch, AssayBatchDetail, AssayBatchStatus, AssayBatchStatusLog, AssayElement, AssayElementGroup, AssayLab, AssayLabElementAlias, AssayLabMethod, AssayMethodGeneric, CollarCoordinate, Config, CoreRecoveryRunLog, CycloneCleaning, DrillMethod, DrillPattern, DrillPlanStatusHistory, DrillProgram, FractureCountLog, GeologyCombinedLog, Hole, HoleName, HoleNmPrefix, LabDispatch, LoggingEvent, LookUpNormalization, MagSusLog, MetaDataLog, Organization, Phase, PickList, PickListUser, PickListValue, Pit, Project, Prospect, QcAnalysisType, QcClassification, QcFilteredset, QcGroup, QcInsertionRule, QcInsertionRuleStandardSequence, QcReference, QcReferenceType, QcReferenceValue, QcReferenceValueType, QcRule, QcStatisticalLimits, QcType, RigSetup, RockMechanicLog, RockQualityDesignationLog, Section, ShearLog, SpecificGravityPtLog, StructureLog, StructurePtLog, SubTarget, Survey, SurveyLog, Target, Template, Tenement, VwCollar, VwDrillPlan, Zone } from "../api/database/data-contracts";
import { FilterField, FilterInput, WorkMode } from "../types/types";

import apiClient from "../api/apiClient";
import { db } from "../db/connection";
import { getMode } from "../store/workModeStore";

// ============================================
// Filter Parsing Utilities
// ============================================

/**
 * Parse filter input into standardized array format for Dexie
 * Supports:
 * - JSON string: '[{"field":"DrillPlanId","op":"eq","value":"..."}]'
 * - Object with filters array: { filters: [{ field: '...', op: 'eq', value: '...' }] }
 * - Plain object: { DrillPlanId: '...' } (defaults to 'eq' op)
 */
export function parseFiltersForDexie(input: FilterInput | string | undefined): FilterField[] {
	if (!input) return [];

	// Handle JSON string input (API format)
	if (typeof input === 'string') {
		try {
			const parsed = JSON.parse(input);
			if (Array.isArray(parsed)) {
				return parsed as FilterField[];
			}
			if (parsed.filters && Array.isArray(parsed.filters)) {
				return parsed.filters as FilterField[];
			}
		} catch {
			// Not valid JSON, treat as raw value for simple equality.
			return [];
		}
	}

	// Handle object with filters array (FilterWrapper format)
	if (input && typeof input === 'object' && 'filters' in input) {
		const wrapper = input as { filters: FilterField[] };
		if (Array.isArray(wrapper.filters)) {
			return wrapper.filters;
		}
	}

	// Handle plain object (key-value pairs)
	if (input && typeof input === 'object' && !Array.isArray(input)) {
		const result: FilterField[] = [];
		const obj = input as Record<string, unknown>;
		for (const [key, value] of Object.entries(obj)) {
			result.push({ field: key, op: 'eq', value: value as string | number | boolean });
		}
		return result;
	}

	return [];
}

/**
 * Apply parsed filters to a Dexie collection
 *
 * IMPORTANT: This function only applies the FIRST indexed filter to avoid
 * "where is not a function" errors. Dexie cannot mix .where() and .filter()
 * operations. All other filters must be applied on the array after toArray().
 *
 * Indexed operations: eq, neq, gt, gte, lt, lte
 * Non-indexed operations: contains, startsWith, endsWith, in, notIn
 */
export function applyFiltersToDexie<T extends { [key: string]: unknown }>(
	collection: dexie.Collection<T, unknown>,
	filters: FilterField[]
): dexie.Collection<T, unknown> {
	// Only apply the FIRST indexed filter
	const indexedOps = ['eq', 'neq', 'gt', 'gte', 'lt', 'lte'];
	const firstIndexedFilter = filters.find(f => indexedOps.includes(f.op));

	if (!firstIndexedFilter) {
		return collection;  // No indexed filters, return collection unchanged
	}

	const { field, op, value } = firstIndexedFilter;

	switch (op) {
		case 'eq':
			return collection.where(field).equals(value as string | number | boolean);
		case 'neq':
			return collection.where(field).notEqual(value as string | number | boolean);
		case 'gt':
			return collection.where(field).above(value as number | Date);
		case 'gte':
			return collection.where(field).aboveOrEqual(value as number | Date);
		case 'lt':
			return collection.where(field).below(value as number | Date);
		case 'lte':
			return collection.where(field).belowOrEqual(value as number | Date);
		default:
			return collection;
	}
}

/**
 * Unified query handler for both API and Dexie
 * @param storeName - Dexie store name
 * @param query - Query parameters
 * @returns Promise with results
 */
export async function unifiedQuery<T extends { [key: string]: unknown }>(
	storeName: string,
	query?: {
		page?: number;
		take?: number;
		order?: "ASC" | "DESC";
		search?: string;
		filters?: string | FilterInput;
		sorts?: string;
	}
): Promise<T[]> {
	if (getMode() === WorkMode.OFFLINE) {
		let collection = (db as unknown as Record<string, dexie.Table<T>>)[storeName].toCollection();

		// Apply filters
		if (query?.filters) {
			const filters = parseFiltersForDexie(query.filters);
			if (filters.length > 0) {
				collection = applyFiltersToDexie(collection, filters);
			}
		}

		// Apply search (simple contains on all string fields)
		if (query?.search) {
			const searchLower = query.search.toLowerCase();
			collection = collection.filter((item) => {
				return Object.values(item).some(val =>
					typeof val === 'string' && val.toLowerCase().includes(searchLower)
				);
			});
		}

		// Get results
		let results = await collection.toArray();

		// Apply in-memory sorting if needed (Dexie multi-column sorting)
		if (query?.sorts) {
			try {
				const sortFields = JSON.parse(query.sorts);
				if (Array.isArray(sortFields) && sortFields.length > 0) {
					results.sort((a, b) => {
						for (const sort of sortFields) {
							const { field, dir } = sort;
							const aVal = a[field];
							const bVal = b[field];
							if (aVal === bVal) continue;
							const comparison = aVal < bVal ? -1 : 1;
							return dir === 'desc' ? -comparison : comparison;
						}
						return 0;
					});
				}
			} catch {
				// Invalid sorts format, skip sorting
			}
		}

		// Apply pagination
		if (query?.page && query?.take) {
			const skip = (query.page - 1) * query.take;
			results = results.slice(skip, skip + query.take);
		} else if (query?.take) {
			results = results.slice(0, query.take);
		}

		return results as T[];
	}

	// Online mode - pass to API
	const response = await (apiClient as unknown as Record<string, (q?: unknown) => Promise<{ data?: unknown }>>)[storeName.replace(/_([a-z])/g, (_, letter) => letter.toUpperCase()).replace(/^[A-Z]/, str => str.toLowerCase()) + 'ControllerFindAll'](query);
	return (response.data as T[]) || [];
}


export const dataLayer = {

	/**
 * Shared Sync Logic
 *
 * Performs the actual sync operation used by both sync and react methods.
 * Handles filtering, transforming, sending, and applying changes.
 *
 * **Flow**:
 * 1. Validate auth token
 * 2. Filter out API-fetched creates (to prevent sync loops)
 * 3. Transform changes to include rowversion (rv) for updates
 * 4. Send to server via API client
 * 5. Apply remote changes to local DB
 * 6. Schedule next sync (poll pattern) or return (react pattern)
 *
 * @param {any} context - Dexie.Syncable context
 * @param {string} url - Sync endpoint URL
 * @param {any} options - Sync options (unused, for Dexie API compatibility)
 * @param {any} baseRevision - Last known server revision
 * @param {any} syncedRevision - Client's synced revision
 * @param {DexieChange[]} changes - Local changes to sync
 * interface DexieChange {
	type: 1 | 2 | 3 // 1=CREATE, 2=UPDATE, 3=DELETE
	table: string
	key: string
	obj?: any // Full object for CREATE/UPDATE
	mods?: any // Only changed fields for UPDATE
	oldObj?: any // Previous state (required by IDatabaseChange for updates)
}
 * @param {boolean} partial - Whether this is a partial sync
 * @param {Function} applyRemoteChanges - Dexie function to apply remote changes
 * @param {Function} onChangesAccepted - Callback when server accepts changes
 * @param {Function} onSuccess - Callback on successful sync
 * @param {Function} onError - Callback on sync error
 * @param {boolean} isReactPattern - True if called from react method
 * @returns {Promise<void>}
 */
	// const  performSync : => (
	async performSync(




		// context: any,
		// url: string,
		// options: any,
		baseRevision: any,
		// syncedRevision: any,
		changes: DexieChange[],
		// partial: boolean,
		// applyRemoteChanges: any,
		// onChangesAccepted: any,
		// onSuccess: any,
		// onError: any,
		// isReactPattern: boolean = false,
	) {
		// console.log("[SYNC-PROTOCOL] üîÑ SYNC FUNCTION CALLED - Entry point", {
		// 	timestamp: new Date().toISOString(),
		// 	changesCount: changes.length,
		// 	baseRevision,
		// 	syncedRevision,
		// 	pattern: isReactPattern ? "REACT" : "POLL",
		// });

		const startTime = Date.now();
		// const { authToken, selectedProgramIds, selectedCollarIds } = useSyncStore.getState();

		// console.log("[SYNC-PROTOCOL] üì° Sync initiated", {
		// 	url,
		// 	baseRevision,
		// 	syncedRevision,
		// 	clientChanges: changes.length,
		// 	selectedPrograms: selectedProgramIds.length,
		// 	selectedCollars: selectedCollarIds.length,
		// 	timestamp: new Date().toISOString(),
		// 	changes: JSON.stringify(changes, null, 2),
		// });

		// 1. Auth check - abort if no token
		// if (!authToken) {
		// 	console.warn("[SYNC-PROTOCOL] üö´ No auth token - aborting sync");
		// 	useSyncStore.getState().setSyncStatus("UNAUTHORIZED");
		// 	return onError("UNAUTHORIZED", 0); // 0 = don't retry
		// }

		// 2. Check sync mode
		// - Local changes: ALWAYS sync (regardless of selection)
		// - Remote changes: Only fetch for selected programs/collars
		// - Selection: Controls offline caching, NOT sync connection
		// const hasSelection = selectedProgramIds.length > 0 || selectedCollarIds.length > 0;

		// Log what we're doing
		// if (changes.length > 0) {
		// 	console.log("[SYNC-PROTOCOL] üì§ Syncing local changes to server", {
		// 		changeCount: changes.length,
		// 		hasSelection,
		// 		tablesChanged: [...new Set(changes.map((c: any) => c.table))],
		// 	});
		// }

		// if (hasSelection) {
		// 	console.log("[SYNC-PROTOCOL] üì• Will receive remote changes for offline caching", {
		// 		programs: selectedProgramIds.length,
		// 		collars: selectedCollarIds.length,
		// 	});
		// }

		try {
			// 3. Filter and transform changes
			// CRITICAL: Filter out changes that originated from API data
			// When SSRM fetches data and does bulkPut, those records have rv (rowversion)
			// from the server. They should NOT be synced back as creates.
			const filteredChanges = changes.filter((change: any) => {
				// For CREATE (type 1): Skip if obj has rv - means it came from API
				if (change.type === 1 && change.obj?.rv) {
					// 	console.log("[SYNC-PROTOCOL] üö´ Filtering out API-fetched CREATE", {
					// 		table: change.table,
					// 		key: change.key,
					// 		rv: change.obj.rv,
					// 	});
					return false;
				}
				// For UPDATE (type 2): Keep all updates (they have oldObj with rv)
				// For DELETE (type 3): Keep all deletes
				return true;
			});

			// Transform changes to ensure rv is included for UPDATEs
			// For UPDATEs, we need to fetch the current record from DB to get rv
			// const transformedChanges = await Promise.all(
			// 	filteredChanges.map(async (change: any) => {
			// 		if (change.type === 2) {
			// 			// Fetch the current record from DB to get rv
			// 			const table = (db as any)[change.table];
			// 			let rv: string | undefined;
			// 			if (table) {
			// 				try {
			// 					const record = await table.get(change.key);
			// 					rv = record?.rv;
			// 				}
			// 				catch (e) {
			// 					console.warn("[SYNC-PROTOCOL] ‚ö†Ô∏è Could not fetch rv for", change.table, change.key);
			// 				}
			// 			}
			// 			// Merge mods with rv for optimistic locking
			// 			const mergedObj = rv ? { ...change.mods, rv } : change.mods;
			// 			return {
			// 				...change,
			// 				obj: mergedObj, // Include full object for server
			// 				mods: {
			// 					...change.mods,
			// 					rv, // Rowversion for optimistic locking
			// 				},
			// 			};
			// 		}
			// 		return change;
			// 	}),
			// );

			// Log filtering results
			// if (changes.length !== transformedChanges.length) {
			// 	console.log("[SYNC-PROTOCOL] üîÑ Filtering summary", {
			// 		totalChanges: changes.length,
			// 		filteredOut: changes.length - transformedChanges.length,
			// 		toSync: transformedChanges.length,
			// 	});
			// }

			// 4. Build sync request
			const request: SyncRequestDto = {
				clientChanges: changes,
				lastRevision: baseRevision,
				syncContext: {
					selectedProgramIds: [],
					selectedCollarIds: [],
				},
			};

			// Log what we're sending to server
			console.log(`[SYNC-PROTOCOL] üì§ Sending to server:`, {
				clientChanges: changes.length,
				firstChange: changes[0] ? {
					type: changes[0].type,
					table: changes[0].table,
					key: changes[0].key,
					hasObj: !!changes[0].obj,
					hasMods: !!changes[0].mods,
				} : null,
			});

			// console.log("[SYNC-PROTOCOL] üì§Sending request to server", {
			// 	changes: transformedChanges.length,
			// 	lastRevision: baseRevision,
			// 	syncedRevision,
			// 	isHeartbeat: transformedChanges.length === 0,
			// 	programs: selectedProgramIds,
			// 	collars: selectedCollarIds.slice(0, 5), // Log first 5 for brevity
			// });

			// Log sample change to verify rv is included
			// if (transformedChanges.length > 0) {
			// 	const sampleChange = transformedChanges[0] as any;
			// 	// console.log("[SYNC-PROTOCOL] üìã Sample change structure", {
			// 	// 	type: sampleChange.type === 1 ? "CREATE" : sampleChange.type === 2 ? "UPDATE" : "DELETE",
			// 	// 	table: sampleChange.table,
			// 	// 	key: sampleChange.key,
			// 	// 	hasObj: !!sampleChange.obj,
			// 	// 	hasMods: !!sampleChange.mods,
			// 	// 	hasOldObj: !!sampleChange.oldObj,
			// 	// 	rvInMods: sampleChange.mods?.rv,
			// 	// 	rvInOldObj: sampleChange.oldObj?.rv,
			// 	// 	modsKeys: sampleChange.mods ? Object.keys(sampleChange.mods) : [],
			// 	// });
			// }

			// 4. Send to server using API client
			// Update auth token in API client
			// apiClient.setAuthToken(authToken);

			// console.log("[SYNC-PROTOCOL] üì§ Using API client for sync");

			// Call sync endpoint
			let syncResponse: SyncResponseDto;
			try {

				syncResponse = (await apiClient.syncControllerSync(request))?.data;
			}
			catch (error: any) {
				// Handle API client errors
				if (error.message.includes("401") || error.message.includes("Unauthorized")) {
					console.error("[SYNC-PROTOCOL] üîí Unauthorized - token may have expired");
					// useSyncStore.getState().setSyncStatus("UNAUTHORIZED", "Auth token expired");
					// return onError("UNAUTHORIZED", 0);
				}

				if (error.message.includes("403") || error.message.includes("Forbidden")) {
					console.error("[SYNC-PROTOCOL] üö´ Forbidden - insufficient permissions");
					// useSyncStore.getState().setSyncStatus("ERROR", "Insufficient permissions");
					// return onError("FORBIDDEN", 60000);
				}

				if (error.message.includes("500") || error.message.includes("Server error")) {
					console.error("[SYNC-PROTOCOL] üí• Server error");
					// useSyncStore.getState().setSyncStatus("ERROR", "Server error");
					// return onError("SERVER_ERROR", 10000);
				}

				throw error;
			}

			// 5. Response received successfully
			const data: SyncResponse = syncResponse as SyncResponse;

			const duration = Date.now() - startTime;
			// console.log("[SYNC-PROTOCOL] üì• RECEIVED DATA FROM API - PARSING RESPONSE", {
			// 	serverChanges: data.changes.length,
			// 	currentRevision: data.currentRevision,
			// 	partial: data.partial,
			// 	conflicts: data.conflicts?.length || 0,
			// 	duration: `${duration}ms`,
			// 	timestamp: new Date().toISOString(),
			// });

			// Log details about the changes received
			if (data.changes.length > 0) {
				const changesByTable = data.changes.reduce((acc: any, change) => {
					acc[change.table] = (acc[change.table] || 0) + 1;
					return acc;
				}, {});

				// console.log("[SYNC-PROTOCOL] üìä API DATA BREAKDOWN BY TABLE", changesByTable);
				// console.log("[SYNC-PROTOCOL] üìã SAMPLE CHANGES FROM API", {
				// 	first3Changes: data.changes.slice(0, 3).map(c => ({
				// 		table: c.table,
				// 		type: c.type === 1 ? "CREATE" : c.type === 2 ? "UPDATE" : "DELETE",
				// 		key: c.key,
				// 		hasObj: !!c.obj,
				// 		obj: c.obj, // Log full object to see what's wrong
				// 	})),
				// });

				// VALIDATE changes before passing to dexie-syncable
				// Filter out any changes with null/undefined obj for CREATE/UPDATE
				const validatedChanges = data.changes.filter((change: any) => {
					if (change.type === 1 || change.type === 2) { // CREATE or UPDATE
						if (!change.obj) {
							// console.error("[SYNC-PROTOCOL] ‚ùå Invalid change - missing obj", {
							// 	type: change.type === 1 ? "CREATE" : "UPDATE",
							// 	table: change.table,
							// 	key: change.key,
							// });
							return false;
						}
					}
					return true;
				});

				// if (validatedChanges.length !== data.changes.length) {
				// 	console.warn("[SYNC-PROTOCOL] ‚ö†Ô∏è Filtered out invalid changes", {
				// 		original: data.changes.length,
				// 		valid: validatedChanges.length,
				// 		filtered: data.changes.length - validatedChanges.length,
				// 	});
				// }

				data.changes = validatedChanges;
			}

			// 6. Handle conflicts
			if (data.conflicts && data.conflicts.length > 0) {
				// console.warn("[SYNC-PROTOCOL] ‚ö†Ô∏è Conflicts detected", {
				// 	count: data.conflicts.length,
				// 	conflicts: data.conflicts.map(c => ({ table: c.table, key: c.key, reason: c.reason })),
				// });

				// Store conflicts for UI resolution
				// useSyncStore.getState().setConflicts(data.conflicts);
			}

			// 7. Apply remote changes to local DB
			// CRITICAL: Always call applyRemoteChanges, even when changes array is empty
			// This ensures Dexie Syncable's internal revision tracking (node.appliedRemoteRevision)
			// gets updated to the current server revision. Without this, heartbeat syncs would
			// never update the revision, causing lastRevision to remain null on subsequent syncs.
			// console.log("[SYNC-PROTOCOL] üíæ APPLYING REMOTE CHANGES TO DEXIE...", {
			// 	count: data.changes.length,
			// 	currentRevision: data.currentRevision,
			// 	tables: data.changes.length > 0 ? [...new Set(data.changes.map(c => c.table))] : [],
			// 	isHeartbeat: data.changes.length === 0,
			// 	timestamp: new Date().toISOString(),
			// });

			const dexieStartTime = Date.now();

			// Cast to IDatabaseChange[] - our DexieChange interface is compatible
			// but TypeScript needs explicit assertion due to type enum differences
			await applyRemoteChanges(
				data.changes as any,
				data.currentRevision,
				false, // clear = false (don't wipe local DB)
				data.partial,
			);

			const dexieDuration = Date.now() - dexieStartTime;
			// console.log("[SYNC-PROTOCOL] ‚úÖ REMOTE CHANGES APPLIED TO DEXIE", {
			// 	count: data.changes.length,
			// 	duration: `${dexieDuration}ms`,
			// 	revisionUpdated: data.currentRevision,
			// 	timestamp: new Date().toISOString(),
			// });

			// 8. Confirm local changes were accepted
			// CRITICAL: Always call onChangesAccepted(), even when changes.length === 0
			// This is required for Dexie-Syncable to call continueSendingChanges() and set up polling.
			// Without this, the continuation pattern never initiates and polling stops after first sync.
			// console.log("[SYNC-PROTOCOL] ‚úÖ Calling onChangesAccepted()", {
			// 	hadLocalChanges: changes.length > 0,
			// 	reason: changes.length > 0 ? "Local changes accepted by server" : "Heartbeat sync - no local changes",
			// });
			onChangesAccepted();

			// TODO: Update local records with new rv from server to prevent stale rowversions
			// Use Dexie.ignoreTransaction() to prevent triggering Observable (infinite loop)
			// await Dexie.ignoreTransaction(async () => {
			// 	console.log('[SYNC-PROTOCOL] üîÑ Updating local records with new rv from server');

			// 	// Find the updated records from server response that match our changes
			// 	for (const change of changes) {
			// 		// Look for the server's echo-back of this change
			// 		const serverUpdate = data.changes.find((serverChange: any) =>
			// 			serverChange.table === change.table &&
			// 			serverChange.key === change.key &&
			// 			serverChange.type === change.type
			// 		);

			// 		if (serverUpdate && serverUpdate.obj && serverUpdate.obj.rv) {
			// 			const table = (db as any)[change.table];
			// 			if (table) {
			// 				try {
			// 					// Update only the rv field without triggering Observable
			// 					await table.update(change.key, { rv: serverUpdate.obj.rv });
			// 					console.log('[SYNC-PROTOCOL] ‚úÖ Updated rv:', {
			// 						table: change.table,
			// 						key: change.key,
			// 						oldRv: change.obj?.rv || change.mods?.rv,
			// 						newRv: serverUpdate.obj.rv
			// 					});
			// 				} catch (err) {
			// 					console.warn('[SYNC-PROTOCOL] ‚ö†Ô∏è Failed to update rv:', {
			// 						table: change.table,
			// 						key: change.key,
			// 						error: err
			// 					});
			// 				}
			// 			}
			// 		}
			// 	}
			// });

			// 9. Schedule next sync
			// For react pattern: don't schedule polling, changes will trigger immediately
			// For poll pattern: schedule next poll in 30 seconds

			// 10. Update UI state
			// useSyncStore.getState().setSyncStatus("CONNECTED");

			console.log("[SYNC-PROTOCOL] üéâ Sync completed successfully", {
				duration: `${duration}ms`,
				pattern: isReactPattern ? "REACT (immediate on changes)" : "POLL (30s interval)",
			});
			if (isReactPattern) {
				console.log("[SYNC-PROTOCOL] ‚ö° React pattern - no polling scheduled, changes will trigger immediately");
				return onSuccess({ again: undefined }); // No polling interval for react pattern
			}
			else {
				console.log(`[SYNC-PROTOCOL] ‚è±Ô∏è Poll pattern - scheduling next sync in ${SYNC_POLL_INTERVAL}ms`);
				return onSuccess({ again: SYNC_POLL_INTERVAL });
			}
		}
		catch (err: any) {
			const duration = Date.now() - startTime;
			console.error("[SYNC-PROTOCOL] üí• Sync error", {
				error: err.message,
				stack: err.stack,
				duration: `${duration}ms`,
			});

			// Update UI state
			// useSyncStore.getState().setSyncStatus("ERROR", err.message);

			// Determine retry strategy based on error
			let retryDelay = 5000; // Default 5s

			if (err.message.includes("NetworkError") || err.message.includes("Failed to fetch")) {
				retryDelay = 10000; // 10s for network errors
				console.log("[SYNC-PROTOCOL] üì° Network error - will retry in 10s");
			}

			onError(err.message, retryDelay);
		}
	},

	/**
	 * Update a record via sync API
	 *
	 * @param tableName - Table name (e.g., "DrillHole_RigSetup")
	 * @param updatedData - Updated data (can be partial or full object)
	 * @param originalData - Original data with rv field (optional, for optimistic locking)
	 * @returns Promise with sync response
	 */
	async Update(tableName: string, updatedData: any, originalData?: any): Promise<any> {
		const keyString: string = updatedData[tableName.split('_')[1] + 'Id'];

		if (!keyString) {
			throw new Error(`Missing primary key in updatedData for table ${tableName}`);
		}

		if (getMode() === WorkMode.OFFLINE) {
			// ‚úÖ Fix: Use keyString and updatedData instead of undefined 'key'
			const result = await db[tableName].put(updatedData);
			if (!result) {
				throw new Error(`${tableName} not found: ${keyString}`);
			}
			return result;
		}
		// Convert table name to camelCase controller method
		// e.g., "DrillHole_RigSetup" -> "rigSetupControllerUpdate"
		const controllerMethodName = tableName.split('_')[1].charAt(0).toLowerCase() + tableName.split('_')[1].slice(1) + 'ControllerUpdate'
		const apiMethod = (apiClient as any)[controllerMethodName];
		if (!apiMethod) {
			throw new Error(`API method not found: ${controllerMethodName} for table ${tableName}`);
		}

		return (await apiMethod.call(apiClient, keyString, updatedData)).data;
	},
	/**
	 * Find a single VwDrillPlan by ID
	 * @param drillPlanId - The DrillPlanId to find
	 * @returns Promise<VwDrillPlan>
	 */
	async vwDrillPlanControllerFindOne(drillPlanId: string): Promise<VwDrillPlan> {
		if (getMode() === WorkMode.OFFLINE) {
			const result = await db.Planning_DrillPlan.get(drillPlanId);
			if (!result) {
				throw new Error(`VwDrillPlan not found: ${drillPlanId}`);
			}
			return result;
		}
		return (await apiClient.vwDrillPlanControllerFindOne(drillPlanId)).data;
	},

	/**
	 * Find all VwDrillPlan records with optional filtering
	 * @param query - Optional query parameters for filtering, pagination, etc.
	 * @returns Promise<VwDrillPlan[]>
	 */
	async vwDrillPlanControllerFindAll(query?: {
		page?: number;
		take?: number;
		order?: "ASC" | "DESC";
		search?: string;
		filters?: string | FilterInput;
		sorts?: string;
	}): Promise<VwDrillPlan[]> {
		if (getMode() === WorkMode.OFFLINE) {
			let collection = db.Planning_DrillPlan.toCollection();

			// Get results as array
			let results = await collection.toArray();

			// Apply ALL filters on array
			if (query?.filters) {
				const filters = parseFiltersForDexie(query.filters);
				if (filters.length > 0) {
					for (const filter of filters) {
						const { field, op, value } = filter;
						switch (op) {
							case 'eq':
								results = results.filter((item: any) => item[field] === value);
								break;
							case 'neq':
								results = results.filter((item: any) => item[field] !== value);
								break;
							case 'gt':
								results = results.filter((item: any) => item[field] > value);
								break;
							case 'gte':
								results = results.filter((item: any) => item[field] >= value);
								break;
							case 'lt':
								results = results.filter((item: any) => item[field] < value);
								break;
							case 'lte':
								results = results.filter((item: any) => item[field] <= value);
								break;
							case 'contains':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().includes(String(value).toLowerCase())
								);
								break;
							case 'startsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().startsWith(String(value).toLowerCase())
								);
								break;
							case 'endsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().endsWith(String(value).toLowerCase())
								);
								break;
							case 'in':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => value.includes(item[field]));
								}
								break;
							case 'notIn':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => !value.includes(item[field]));
								}
								break;
						}
					}
				}
			}

			// Apply search (on array)
			if (query?.search) {
				const searchLower = query.search.toLowerCase();
				results = results.filter((item: any) =>
					Object.values(item).some(val =>
						typeof val === 'string' && val.toLowerCase().includes(searchLower)
					)
				);
			}

			// Apply sorting
			if (query?.sorts) {
				try {
					const sortFields = JSON.parse(query.sorts);
					if (Array.isArray(sortFields) && sortFields.length > 0) {
						results.sort((a: any, b: any) => {
							for (const sort of sortFields) {
								const { field, dir } = sort;
								const aVal = a[field];
								const bVal = b[field];
								if (aVal === bVal) continue;
								const comparison = aVal < bVal ? -1 : 1;
								return dir === 'desc' ? -comparison : comparison;
							}
							return 0;
						}
						);
					}
				} catch {
					// Invalid sorts format, skip
				}
			}

			// Apply pagination
			if (query?.page && query?.take) {
				const skip = (query.page - 1) * query.take;
				results = results.slice(skip, skip + query.take);
			} else if (query?.take) {
				results = results.slice(0, query.take);
			}

			return results as VwDrillPlan[];
		}
		const response = await apiClient.vwDrillPlanControllerFindAll(query);
		return (response.data as any) || [];
	},

	/**
	 * Create a new VwDrillPlan
	 * @param vwDrillPlan - The VwDrillPlan data to create
	 * @returns Promise<VwDrillPlan>
	 */
	async vwDrillPlanControllerCreate(vwDrillPlan: VwDrillPlan): Promise<VwDrillPlan> {
		if (getMode() === WorkMode.OFFLINE) {
			await db.Planning_DrillPlan.add(vwDrillPlan);
			const result = await db.Planning_DrillPlan.get(vwDrillPlan.DrillPlanId);
			if (!result) {
				throw new Error(`Failed to create VwDrillPlan: ${vwDrillPlan.DrillPlanId}`);
			}
			return result;
		}
		return (await apiClient.vwDrillPlanControllerCreate(vwDrillPlan)).data;
	},

	/**
	 * Update a VwDrillPlan
	 * @param drillPlanId - The DrillPlanId to update
	 * @param vwDrillPlan - The updated VwDrillPlan data
	 * @returns Promise<VwDrillPlan>
	 */
	async vwDrillPlanControllerUpdate(drillPlanId: string, vwDrillPlan: VwDrillPlan): Promise<VwDrillPlan> {
		if (getMode() === WorkMode.OFFLINE) {
			const numAffected = await db.Planning_DrillPlan.update(drillPlanId, vwDrillPlan as any);
			let result;
			if (numAffected > 0) {
				result = await db.Planning_DrillPlan.get(drillPlanId);
			}
			if (!result) {
				throw new Error(`VwDrillPlan not found: ${drillPlanId}`);
			}
			return result;
		}
		return (await apiClient.vwDrillPlanControllerUpdate(drillPlanId, vwDrillPlan)).data;
	},

	/**
	 * Remove (soft delete) a VwDrillPlan
	 * Calls the API Remove endpoint which sets ActiveInd to false
	 * @param drillPlanId - The DrillPlanId to remove
	 * @param vwDrillPlan - The VwDrillPlan data
	 * @returns Promise<VwDrillPlan>
	 */
	async vwDrillPlanControllerRemove(drillPlanId: string, vwDrillPlan: VwDrillPlan): Promise<VwDrillPlan> {
		if (getMode() === WorkMode.OFFLINE) {
			// In offline mode, soft delete by updating ActiveInd
			const numAffected = await db.Planning_DrillPlan.update(drillPlanId, { ...vwDrillPlan, ActiveInd: false });
			let result;
			if (numAffected > 0) {
				result = await db.Planning_DrillPlan.get(drillPlanId);
			}
			if (!result) {
				throw new Error(`VwDrillPlan not found: ${drillPlanId}`);
			}
			return result;
		}
		// In online mode, call the API's Remove endpoint
		return (await apiClient.vwDrillPlanControllerUpdate(drillPlanId, { ...vwDrillPlan, ActiveInd: false })).data;
	},

	/**
	 * Find a single VwCollar by ID
	 * @param collarId - The CollarId to find
	 * @returns Promise<VwCollar>
	 */
	async vwCollarControllerFindOne(collarId: string): Promise<VwCollar> {
		if (getMode() === WorkMode.OFFLINE) {
			const result = await db.DrillHole_Collar.get(collarId);
			if (!result) {
				throw new Error(`VwCollar not found: ${collarId}`);
			}
			return result;
		}
		return (await apiClient.vwCollarControllerFindOne(collarId)).data;
	},

	/**
	 * Find all VwCollar records with optional filtering
	 * @param query - Optional query parameters for filtering, pagination, etc.
	 * @returns Promise<VwCollar[]>
	 */
	async vwCollarControllerFindAll(query?: {
		page?: number;
		take?: number;
		order?: "ASC" | "DESC";
		search?: string;
		filters?: string | FilterInput;
		sorts?: string;
	}): Promise<VwCollar[]> {
		if (getMode() === WorkMode.OFFLINE) {
			let collection = db.DrillHole_Collar.toCollection();

			// Get results as array
			let results = await collection.toArray();

			// Apply ALL filters on array
			if (query?.filters) {
				const filters = parseFiltersForDexie(query.filters);
				if (filters.length > 0) {
					for (const filter of filters) {
						const { field, op, value } = filter;
						switch (op) {
							case 'eq':
								results = results.filter((item: any) => item[field] === value);
								break;
							case 'neq':
								results = results.filter((item: any) => item[field] !== value);
								break;
							case 'gt':
								results = results.filter((item: any) => item[field] > value);
								break;
							case 'gte':
								results = results.filter((item: any) => item[field] >= value);
								break;
							case 'lt':
								results = results.filter((item: any) => item[field] < value);
								break;
							case 'lte':
								results = results.filter((item: any) => item[field] <= value);
								break;
							case 'contains':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().includes(String(value).toLowerCase())
								);
								break;
							case 'startsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().startsWith(String(value).toLowerCase())
								);
								break;
							case 'endsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().endsWith(String(value).toLowerCase())
								);
								break;
							case 'in':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => value.includes(item[field]));
								}
								break;
							case 'notIn':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => !value.includes(item[field]));
								}
								break;
						}
					}
				}
			}

			// Apply search (on array)
			if (query?.search) {
				const searchLower = query.search.toLowerCase();
				results = results.filter((item: any) =>
					Object.values(item).some(val =>
						typeof val === 'string' && val.toLowerCase().includes(searchLower)
					)
				);
			}

			// Apply sorting
			if (query?.sorts) {
				try {
					const sortFields = JSON.parse(query.sorts);
					if (Array.isArray(sortFields) && sortFields.length > 0) {
						results.sort((a: any, b: any) => {
							for (const sort of sortFields) {
								const { field, dir } = sort;
								const aVal = a[field];
								const bVal = b[field];
								if (aVal === bVal) continue;
								const comparison = aVal < bVal ? -1 : 1;
								return dir === 'desc' ? -comparison : comparison;
							}
							return 0;
						}
						);
					}
				} catch {
					// Invalid sorts format, skip
				}
			}

			// Apply pagination
			if (query?.page && query?.take) {
				const skip = (query.page - 1) * query.take;
				results = results.slice(skip, skip + query.take);
			} else if (query?.take) {
				results = results.slice(0, query.take);
			}

			return results as VwCollar[];
		}
		const response = await apiClient.vwCollarControllerFindAll(query);
		return (response.data as any) || [];
	},

	/**
	 * Create a new VwCollar
	 * @param vwCollar - The VwCollar data to create
	 * @returns Promise<VwCollar>
	 */
	async vwCollarControllerCreate(vwCollar: VwCollar): Promise<VwCollar> {
		if (getMode() === WorkMode.OFFLINE) {
			await db.DrillHole_Collar.add(vwCollar);
			const result = await db.DrillHole_Collar.get(vwCollar.CollarId);
			if (!result) {
				throw new Error(`Failed to create VwCollar: ${vwCollar.CollarId}`);
			}
			return result;
		}
		return (await apiClient.vwCollarControllerCreate(vwCollar)).data;
	},

	/**
	 * Update a VwCollar
	 * @param collarId - The CollarId to update
	 * @param vwCollar - The updated VwCollar data
	 * @returns Promise<VwCollar>
	 */
	async vwCollarControllerUpdate(collarId: string, vwCollar: VwCollar): Promise<VwCollar> {
		if (getMode() === WorkMode.OFFLINE) {
			const numAffected = await db.DrillHole_Collar.update(collarId, vwCollar as any);
			let result;
			if (numAffected > 0) {
				result = await db.DrillHole_Collar.get(collarId);
			}
			if (!result) {
				throw new Error(`VwCollar not found: ${collarId}`);
			}
			return result;
		}
		return (await apiClient.vwCollarControllerUpdate(collarId, vwCollar)).data;
	},

	/**
	 * Remove (soft delete) a VwCollar
	 * Calls the API Remove endpoint which sets ActiveInd to false
	 * @param collarId - The CollarId to remove
	 * @param vwCollar - The VwCollar data
	 * @returns Promise<VwCollar>
	 */
	async vwCollarControllerRemove(collarId: string, vwCollar: VwCollar): Promise<VwCollar> {
		if (getMode() === WorkMode.OFFLINE) {
			// In offline mode, soft delete by updating ActiveInd
			const numAffected = await db.DrillHole_Collar.update(collarId, { ...vwCollar, ActiveInd: false });
			let result;
			if (numAffected > 0) {
				result = await db.DrillHole_Collar.get(collarId);
			}
			if (!result) {
				throw new Error(`VwCollar not found: ${collarId}`);
			}
			return result;
		}
		// In online mode, call the API's Remove endpoint
		return (await apiClient.vwCollarControllerUpdate(collarId, { ...vwCollar, ActiveInd: false })).data;
	},

	/**
	 * Find a single AllSamples by ID
	 * @param sampleId - The SampleId to find
	 * @returns Promise<AllSamples>
	 */
	async allSamplesControllerFindOne(sampleId: string): Promise<AllSamples> {
		if (getMode() === WorkMode.OFFLINE) {
			const result = await db.Sample.get(sampleId);
			if (!result) {
				throw new Error(`AllSamples not found: ${sampleId}`);
			}
			return result;
		}
		return (await apiClient.allSamplesControllerFindOne(sampleId)).data;
	},

	/**
	 * Find all AllSamples records with optional filtering
	 * @param query - Optional query parameters for filtering, pagination, etc.
	 * @returns Promise<AllSamples[]>
	 */
	async allSamplesControllerFindAll(query?: {
		page?: number;
		take?: number;
		order?: "ASC" | "DESC";
		search?: string;
		filters?: string | FilterInput;
		sorts?: string;
	}): Promise<AllSamples[]> {
		if (getMode() === WorkMode.OFFLINE) {
			let collection = db.Sample.toCollection();

			// Get results as array
			let results = await collection.toArray();

			// Apply ALL filters on array
			if (query?.filters) {
				const filters = parseFiltersForDexie(query.filters);
				if (filters.length > 0) {
					for (const filter of filters) {
						const { field, op, value } = filter;
						switch (op) {
							case 'eq':
								results = results.filter((item: any) => item[field] === value);
								break;
							case 'neq':
								results = results.filter((item: any) => item[field] !== value);
								break;
							case 'gt':
								results = results.filter((item: any) => item[field] > value);
								break;
							case 'gte':
								results = results.filter((item: any) => item[field] >= value);
								break;
							case 'lt':
								results = results.filter((item: any) => item[field] < value);
								break;
							case 'lte':
								results = results.filter((item: any) => item[field] <= value);
								break;
							case 'contains':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().includes(String(value).toLowerCase())
								);
								break;
							case 'startsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().startsWith(String(value).toLowerCase())
								);
								break;
							case 'endsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().endsWith(String(value).toLowerCase())
								);
								break;
							case 'in':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => value.includes(item[field]));
								}
								break;
							case 'notIn':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => !value.includes(item[field]));
								}
								break;
						}
					}
				}
			}

			// Apply search (on array)
			if (query?.search) {
				const searchLower = query.search.toLowerCase();
				results = results.filter((item: any) =>
					Object.values(item).some(val =>
						typeof val === 'string' && val.toLowerCase().includes(searchLower)
					)
				);
			}

			// Apply sorting
			if (query?.sorts) {
				try {
					const sortFields = JSON.parse(query.sorts);
					if (Array.isArray(sortFields) && sortFields.length > 0) {
						results.sort((a: any, b: any) => {
							for (const sort of sortFields) {
								const { field, dir } = sort;
								const aVal = a[field];
								const bVal = b[field];
								if (aVal === bVal) continue;
								const comparison = aVal < bVal ? -1 : 1;
								return dir === 'desc' ? -comparison : comparison;
							}
							return 0;
						}
						);
					}
				} catch {
					// Invalid sorts format, skip
				}
			}

			// Apply pagination
			if (query?.page && query?.take) {
				const skip = (query.page - 1) * query.take;
				results = results.slice(skip, skip + query.take);
			} else if (query?.take) {
				results = results.slice(0, query.take);
			}

			return results as AllSamples[];
		}
		console.log('samplesAllControllerFindAll', query)
		const response = await apiClient.samplesAllControllerFindAll(query);
		return (response.data as any) || [];
	},

	/**
	 * Create a new AllSamples
	 * @param allSamples - The AllSamples data to create
	 * @returns Promise<AllSamples>
	 */
	async allSamplesControllerCreate(allSamples: AllSamples): Promise<AllSamples> {
		if (getMode() === WorkMode.OFFLINE) {
			await db.Sample.add(allSamples);
			const result = await db.Sample.get(allSamples.SampleId);
			if (!result) {
				throw new Error(`Failed to create AllSamples: ${allSamples.SampleId}`);
			}
			return result;
		}
		return (await apiClient.samplesAllControllerCreate(allSamples)).data;
	},

	/**
	 * Update a AllSamples
	 * @param sampleId - The SampleId to update
	 * @param allSamples - The updated AllSamples data
	 * @returns Promise<AllSamples>
	 */
	async allSamplesControllerUpdate(sampleId: string, allSamples: AllSamples): Promise<AllSamples> {
		if (getMode() === WorkMode.OFFLINE) {
			const numAffected = await db.Sample.update(sampleId, allSamples as any);
			let result;
			if (numAffected > 0) {
				result = await db.Sample.get(sampleId);
			}
			if (!result) {
				throw new Error(`AllSamples not found: ${sampleId}`);
			}
			return result;
		}
		return (await apiClient.samplesAllControllerUpdate(sampleId, allSamples)).data;
	},

	/**
	 * Remove (soft delete) a AllSamples
	 * Calls the API Remove endpoint which sets ActiveInd to false
	 * @param sampleId - The SampleId to remove
	 * @param allSamples - The AllSamples data
	 * @returns Promise<AllSamples>
	 */
	async allSamplesControllerRemove(sampleId: string, allSamples: AllSamples): Promise<AllSamples> {
		if (getMode() === WorkMode.OFFLINE) {
			// In offline mode, soft delete by updating ActiveInd
			const numAffected = await db.Sample.update(sampleId, { ...allSamples, ActiveInd: false });
			let result;
			if (numAffected > 0) {
				result = await db.Sample.get(sampleId);
			}
			if (!result) {
				throw new Error(`AllSamples not found: ${sampleId}`);
			}
			return result;
		}
		// In online mode, call the API's Remove endpoint
		return (await apiClient.samplesAllControllerUpdate(sampleId, { ...allSamples, ActiveInd: false })).data;
	},

	/**
	 * Find a single GeologyCombinedLog by ID
	 * @param geologyCombinedLogId - The GeologyCombinedLogId to find
	 * @returns Promise<GeologyCombinedLog>
	 */
	async geologyCombinedLogControllerFindOne(geologyCombinedLogId: string): Promise<GeologyCombinedLog> {
		if (getMode() === WorkMode.OFFLINE) {
			const result = await db.Geology_GeologyCombinedLog.get(geologyCombinedLogId);
			if (!result) {
				throw new Error(`GeologyCombinedLog not found: ${geologyCombinedLogId}`);
			}
			return result;
		}
		return (await apiClient.geologyCombinedLogControllerFindOne(geologyCombinedLogId)).data;
	},

	/**
	 * Find all GeologyCombinedLog records with optional filtering
	 * @param query - Optional query parameters for filtering, pagination, etc.
	 * @returns Promise<GeologyCombinedLog[]>
	 */
	async geologyCombinedLogControllerFindAll(query?: {
		page?: number;
		take?: number;
		order?: "ASC" | "DESC";
		search?: string;
		filters?: string | FilterInput;
		sorts?: string;
	}): Promise<GeologyCombinedLog[]> {
		if (getMode() === WorkMode.OFFLINE) {
			let collection = db.Geology_GeologyCombinedLog.toCollection();

			// Get results as array
			let results = await collection.toArray();

			// Apply ALL filters on array
			if (query?.filters) {
				const filters = parseFiltersForDexie(query.filters);
				if (filters.length > 0) {
					for (const filter of filters) {
						const { field, op, value } = filter;
						switch (op) {
							case 'eq':
								results = results.filter((item: any) => item[field] === value);
								break;
							case 'neq':
								results = results.filter((item: any) => item[field] !== value);
								break;
							case 'gt':
								results = results.filter((item: any) => item[field] > value);
								break;
							case 'gte':
								results = results.filter((item: any) => item[field] >= value);
								break;
							case 'lt':
								results = results.filter((item: any) => item[field] < value);
								break;
							case 'lte':
								results = results.filter((item: any) => item[field] <= value);
								break;
							case 'contains':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().includes(String(value).toLowerCase())
								);
								break;
							case 'startsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().startsWith(String(value).toLowerCase())
								);
								break;
							case 'endsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().endsWith(String(value).toLowerCase())
								);
								break;
							case 'in':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => value.includes(item[field]));
								}
								break;
							case 'notIn':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => !value.includes(item[field]));
								}
								break;
						}
					}
				}
			}

			// Apply search (on array)
			if (query?.search) {
				const searchLower = query.search.toLowerCase();
				results = results.filter((item: any) =>
					Object.values(item).some(val =>
						typeof val === 'string' && val.toLowerCase().includes(searchLower)
					)
				);
			}

			// Apply sorting
			if (query?.sorts) {
				try {
					const sortFields = JSON.parse(query.sorts);
					if (Array.isArray(sortFields) && sortFields.length > 0) {
						results.sort((a: any, b: any) => {
							for (const sort of sortFields) {
								const { field, dir } = sort;
								const aVal = a[field];
								const bVal = b[field];
								if (aVal === bVal) continue;
								const comparison = aVal < bVal ? -1 : 1;
								return dir === 'desc' ? -comparison : comparison;
							}
							return 0;
						}
						);
					}
				} catch {
					// Invalid sorts format, skip
				}
			}

			// Apply pagination
			if (query?.page && query?.take) {
				const skip = (query.page - 1) * query.take;
				results = results.slice(skip, skip + query.take);
			} else if (query?.take) {
				results = results.slice(0, query.take);
			}

			return results as GeologyCombinedLog[];
		}
		const response = await apiClient.geologyCombinedLogControllerFindAll(query);
		return (response.data as any) || [];
	},

	/**
	 * Create a new GeologyCombinedLog
	 * @param geologyCombinedLog - The GeologyCombinedLog data to create
	 * @returns Promise<GeologyCombinedLog>
	 */
	async geologyCombinedLogControllerCreate(geologyCombinedLog: GeologyCombinedLog): Promise<GeologyCombinedLog> {
		if (getMode() === WorkMode.OFFLINE) {
			await db.Geology_GeologyCombinedLog.add(geologyCombinedLog);
			const result = await db.Geology_GeologyCombinedLog.get(geologyCombinedLog.GeologyCombinedLogId);
			if (!result) {
				throw new Error(`Failed to create GeologyCombinedLog: ${geologyCombinedLog.GeologyCombinedLogId}`);
			}
			return result;
		}
		return (await apiClient.geologyCombinedLogControllerCreate(geologyCombinedLog)).data;
	},

	/**
	 * Update a GeologyCombinedLog
	 * @param geologyCombinedLogId - The GeologyCombinedLogId to update
	 * @param geologyCombinedLog - The updated GeologyCombinedLog data
	 * @returns Promise<GeologyCombinedLog>
	 */
	async geologyCombinedLogControllerUpdate(geologyCombinedLogId: string, geologyCombinedLog: GeologyCombinedLog): Promise<GeologyCombinedLog> {
		if (getMode() === WorkMode.OFFLINE) {
			const numAffected = await db.Geology_GeologyCombinedLog.update(geologyCombinedLogId, geologyCombinedLog as any);
			let result;
			if (numAffected > 0) {
				result = await db.Geology_GeologyCombinedLog.get(geologyCombinedLogId);
			}
			if (!result) {
				throw new Error(`GeologyCombinedLog not found: ${geologyCombinedLogId}`);
			}
			return result;
		}
		return (await apiClient.geologyCombinedLogControllerUpdate(geologyCombinedLogId, geologyCombinedLog)).data;
	},

	/**
	 * Remove (soft delete) a GeologyCombinedLog
	 * Calls the API Remove endpoint which sets ActiveInd to false
	 * @param geologyCombinedLogId - The GeologyCombinedLogId to remove
	 * @param geologyCombinedLog - The GeologyCombinedLog data
	 * @returns Promise<GeologyCombinedLog>
	 */
	async geologyCombinedLogControllerRemove(geologyCombinedLogId: string, geologyCombinedLog: GeologyCombinedLog): Promise<GeologyCombinedLog> {
		if (getMode() === WorkMode.OFFLINE) {
			// In offline mode, soft delete by updating ActiveInd
			const numAffected = await db.Geology_GeologyCombinedLog.update(geologyCombinedLogId, { ...geologyCombinedLog, ActiveInd: false });
			let result;
			if (numAffected > 0) {
				result = await db.Geology_GeologyCombinedLog.get(geologyCombinedLogId);
			}
			if (!result) {
				throw new Error(`GeologyCombinedLog not found: ${geologyCombinedLogId}`);
			}
			return result;
		}
		// In online mode, call the API's Remove endpoint
		return (await apiClient.geologyCombinedLogControllerUpdate(geologyCombinedLogId, { ...geologyCombinedLog, ActiveInd: false })).data;
	},

	/**
	 * Find a single ShearLog by ID
	 * @param shearLogId - The ShearLogId to find
	 * @returns Promise<ShearLog>
	 */
	async shearLogControllerFindOne(shearLogId: string): Promise<ShearLog> {
		if (getMode() === WorkMode.OFFLINE) {
			const result = await db.Geology_ShearLog.get(shearLogId);
			if (!result) {
				throw new Error(`ShearLog not found: ${shearLogId}`);
			}
			return result;
		}
		return (await apiClient.shearLogControllerFindOne(shearLogId)).data;
	},

	/**
	 * Find all ShearLog records with optional filtering
	 * @param query - Optional query parameters for filtering, pagination, etc.
	 * @returns Promise<ShearLog[]>
	 */
	async shearLogControllerFindAll(query?: {
		page?: number;
		take?: number;
		order?: "ASC" | "DESC";
		search?: string;
		filters?: string | FilterInput;
		sorts?: string;
	}): Promise<ShearLog[]> {
		if (getMode() === WorkMode.OFFLINE) {
			let collection = db.Geology_ShearLog.toCollection();

			// Get results as array
			let results = await collection.toArray();

			// Apply ALL filters on array
			if (query?.filters) {
				const filters = parseFiltersForDexie(query.filters);
				if (filters.length > 0) {
					for (const filter of filters) {
						const { field, op, value } = filter;
						switch (op) {
							case 'eq':
								results = results.filter((item: any) => item[field] === value);
								break;
							case 'neq':
								results = results.filter((item: any) => item[field] !== value);
								break;
							case 'gt':
								results = results.filter((item: any) => item[field] > value);
								break;
							case 'gte':
								results = results.filter((item: any) => item[field] >= value);
								break;
							case 'lt':
								results = results.filter((item: any) => item[field] < value);
								break;
							case 'lte':
								results = results.filter((item: any) => item[field] <= value);
								break;
							case 'contains':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().includes(String(value).toLowerCase())
								);
								break;
							case 'startsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().startsWith(String(value).toLowerCase())
								);
								break;
							case 'endsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().endsWith(String(value).toLowerCase())
								);
								break;
							case 'in':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => value.includes(item[field]));
								}
								break;
							case 'notIn':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => !value.includes(item[field]));
								}
								break;
						}
					}
				}
			}

			// Apply search (on array)
			if (query?.search) {
				const searchLower = query.search.toLowerCase();
				results = results.filter((item: any) =>
					Object.values(item).some(val =>
						typeof val === 'string' && val.toLowerCase().includes(searchLower)
					)
				);
			}

			// Apply sorting
			if (query?.sorts) {
				try {
					const sortFields = JSON.parse(query.sorts);
					if (Array.isArray(sortFields) && sortFields.length > 0) {
						results.sort((a: any, b: any) => {
							for (const sort of sortFields) {
								const { field, dir } = sort;
								const aVal = a[field];
								const bVal = b[field];
								if (aVal === bVal) continue;
								const comparison = aVal < bVal ? -1 : 1;
								return dir === 'desc' ? -comparison : comparison;
							}
							return 0;
						}
						);
					}
				} catch {
					// Invalid sorts format, skip
				}
			}

			// Apply pagination
			if (query?.page && query?.take) {
				const skip = (query.page - 1) * query.take;
				results = results.slice(skip, skip + query.take);
			} else if (query?.take) {
				results = results.slice(0, query.take);
			}

			return results as ShearLog[];
		}
		const response = await apiClient.shearLogControllerFindAll(query);
		return (response.data as any) || [];
	},

	/**
	 * Create a new ShearLog
	 * @param shearLog - The ShearLog data to create
	 * @returns Promise<ShearLog>
	 */
	async shearLogControllerCreate(shearLog: ShearLog): Promise<ShearLog> {
		if (getMode() === WorkMode.OFFLINE) {
			await db.Geology_ShearLog.add(shearLog);
			const result = await db.Geology_ShearLog.get(shearLog.ShearLogId);
			if (!result) {
				throw new Error(`Failed to create ShearLog: ${shearLog.ShearLogId}`);
			}
			return result;
		}
		return (await apiClient.shearLogControllerCreate(shearLog)).data;
	},

	/**
	 * Update a ShearLog
	 * @param shearLogId - The ShearLogId to update
	 * @param shearLog - The updated ShearLog data
	 * @returns Promise<ShearLog>
	 */
	async shearLogControllerUpdate(shearLogId: string, shearLog: ShearLog): Promise<ShearLog> {
		if (getMode() === WorkMode.OFFLINE) {
			const numAffected = await db.Geology_ShearLog.update(shearLogId, shearLog as any);
			let result;
			if (numAffected > 0) {
				result = await db.Geology_ShearLog.get(shearLogId);
			}
			if (!result) {
				throw new Error(`ShearLog not found: ${shearLogId}`);
			}
			return result;
		}
		return (await apiClient.shearLogControllerUpdate(shearLogId, shearLog)).data;
	},

	/**
	 * Remove (soft delete) a ShearLog
	 * Calls the API Remove endpoint which sets ActiveInd to false
	 * @param shearLogId - The ShearLogId to remove
	 * @param shearLog - The ShearLog data
	 * @returns Promise<ShearLog>
	 */
	async shearLogControllerRemove(shearLogId: string, shearLog: ShearLog): Promise<ShearLog> {
		if (getMode() === WorkMode.OFFLINE) {
			// In offline mode, soft delete by updating ActiveInd
			const numAffected = await db.Geology_ShearLog.update(shearLogId, { ...shearLog, ActiveInd: false });
			let result;
			if (numAffected > 0) {
				result = await db.Geology_ShearLog.get(shearLogId);
			}
			if (!result) {
				throw new Error(`ShearLog not found: ${shearLogId}`);
			}
			return result;
		}
		// In online mode, call the API's Remove endpoint
		return (await apiClient.shearLogControllerUpdate(shearLogId, { ...shearLog, ActiveInd: false })).data;
	},

	/**
	 * Find a single StructureLog by ID
	 * @param structureLogId - The StructureLogId to find
	 * @returns Promise<StructureLog>
	 */
	async structureLogControllerFindOne(structureLogId: string): Promise<StructureLog> {
		if (getMode() === WorkMode.OFFLINE) {
			const result = await db.Geology_StructureLog.get(structureLogId);
			if (!result) {
				throw new Error(`StructureLog not found: ${structureLogId}`);
			}
			return result;
		}
		return (await apiClient.structureLogControllerFindOne(structureLogId)).data;
	},

	/**
	 * Find all StructureLog records with optional filtering
	 * @param query - Optional query parameters for filtering, pagination, etc.
	 * @returns Promise<StructureLog[]>
	 */
	async structureLogControllerFindAll(query?: {
		page?: number;
		take?: number;
		order?: "ASC" | "DESC";
		search?: string;
		filters?: string | FilterInput;
		sorts?: string;
	}): Promise<StructureLog[]> {
		if (getMode() === WorkMode.OFFLINE) {
			let collection = db.Geology_StructureLog.toCollection();

			// Get results as array
			let results = await collection.toArray();

			// Apply ALL filters on array
			if (query?.filters) {
				const filters = parseFiltersForDexie(query.filters);
				if (filters.length > 0) {
					for (const filter of filters) {
						const { field, op, value } = filter;
						switch (op) {
							case 'eq':
								results = results.filter((item: any) => item[field] === value);
								break;
							case 'neq':
								results = results.filter((item: any) => item[field] !== value);
								break;
							case 'gt':
								results = results.filter((item: any) => item[field] > value);
								break;
							case 'gte':
								results = results.filter((item: any) => item[field] >= value);
								break;
							case 'lt':
								results = results.filter((item: any) => item[field] < value);
								break;
							case 'lte':
								results = results.filter((item: any) => item[field] <= value);
								break;
							case 'contains':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().includes(String(value).toLowerCase())
								);
								break;
							case 'startsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().startsWith(String(value).toLowerCase())
								);
								break;
							case 'endsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().endsWith(String(value).toLowerCase())
								);
								break;
							case 'in':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => value.includes(item[field]));
								}
								break;
							case 'notIn':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => !value.includes(item[field]));
								}
								break;
						}
					}
				}
			}

			// Apply search (on array)
			if (query?.search) {
				const searchLower = query.search.toLowerCase();
				results = results.filter((item: any) =>
					Object.values(item).some(val =>
						typeof val === 'string' && val.toLowerCase().includes(searchLower)
					)
				);
			}

			// Apply sorting
			if (query?.sorts) {
				try {
					const sortFields = JSON.parse(query.sorts);
					if (Array.isArray(sortFields) && sortFields.length > 0) {
						results.sort((a: any, b: any) => {
							for (const sort of sortFields) {
								const { field, dir } = sort;
								const aVal = a[field];
								const bVal = b[field];
								if (aVal === bVal) continue;
								const comparison = aVal < bVal ? -1 : 1;
								return dir === 'desc' ? -comparison : comparison;
							}
							return 0;
						}
						);
					}
				} catch {
					// Invalid sorts format, skip
				}
			}

			// Apply pagination
			if (query?.page && query?.take) {
				const skip = (query.page - 1) * query.take;
				results = results.slice(skip, skip + query.take);
			} else if (query?.take) {
				results = results.slice(0, query.take);
			}

			return results as StructureLog[];
		}
		const response = await apiClient.structureLogControllerFindAll(query);
		return (response.data as any) || [];
	},

	/**
	 * Create a new StructureLog
	 * @param structureLog - The StructureLog data to create
	 * @returns Promise<StructureLog>
	 */
	async structureLogControllerCreate(structureLog: StructureLog): Promise<StructureLog> {
		if (getMode() === WorkMode.OFFLINE) {
			await db.Geology_StructureLog.add(structureLog);
			const result = await db.Geology_StructureLog.get(structureLog.StructureLogId);
			if (!result) {
				throw new Error(`Failed to create StructureLog: ${structureLog.StructureLogId}`);
			}
			return result;
		}
		return (await apiClient.structureLogControllerCreate(structureLog)).data;
	},

	/**
	 * Update a StructureLog
	 * @param structureLogId - The StructureLogId to update
	 * @param structureLog - The updated StructureLog data
	 * @returns Promise<StructureLog>
	 */
	async structureLogControllerUpdate(structureLogId: string, structureLog: StructureLog): Promise<StructureLog> {
		if (getMode() === WorkMode.OFFLINE) {
			const numAffected = await db.Geology_StructureLog.update(structureLogId, structureLog as any);
			let result;
			if (numAffected > 0) {
				result = await db.Geology_StructureLog.get(structureLogId);
			}
			if (!result) {
				throw new Error(`StructureLog not found: ${structureLogId}`);
			}
			return result;
		}
		return (await apiClient.structureLogControllerUpdate(structureLogId, structureLog)).data;
	},

	/**
	 * Remove (soft delete) a StructureLog
	 * Calls the API Remove endpoint which sets ActiveInd to false
	 * @param structureLogId - The StructureLogId to remove
	 * @param structureLog - The StructureLog data
	 * @returns Promise<StructureLog>
	 */
	async structureLogControllerRemove(structureLogId: string, structureLog: StructureLog): Promise<StructureLog> {
		if (getMode() === WorkMode.OFFLINE) {
			// In offline mode, soft delete by updating ActiveInd
			const numAffected = await db.Geology_StructureLog.update(structureLogId, { ...structureLog, ActiveInd: false });
			let result;
			if (numAffected > 0) {
				result = await db.Geology_StructureLog.get(structureLogId);
			}
			if (!result) {
				throw new Error(`StructureLog not found: ${structureLogId}`);
			}
			return result;
		}
		// In online mode, call the API's Remove endpoint
		return (await apiClient.structureLogControllerUpdate(structureLogId, { ...structureLog, ActiveInd: false })).data;
	},

	/**
	 * Find a single StructurePtLog by ID
	 * @param structurePtLogId - The StructurePtLogId to find
	 * @returns Promise<StructurePtLog>
	 */
	async structurePtLogControllerFindOne(structurePtLogId: string): Promise<StructurePtLog> {
		if (getMode() === WorkMode.OFFLINE) {
			const result = await db.Geology_StructurePtLog.get(structurePtLogId);
			if (!result) {
				throw new Error(`StructurePtLog not found: ${structurePtLogId}`);
			}
			return result;
		}
		return (await apiClient.structurePtLogControllerFindOne(structurePtLogId)).data;
	},

	/**
	 * Find all StructurePtLog records with optional filtering
	 * @param query - Optional query parameters for filtering, pagination, etc.
	 * @returns Promise<StructurePtLog[]>
	 */
	async structurePtLogControllerFindAll(query?: {
		page?: number;
		take?: number;
		order?: "ASC" | "DESC";
		search?: string;
		filters?: string | FilterInput;
		sorts?: string;
	}): Promise<StructurePtLog[]> {
		if (getMode() === WorkMode.OFFLINE) {
			let collection = db.Geology_StructurePtLog.toCollection();

			// Get results as array
			let results = await collection.toArray();

			// Apply ALL filters on array
			if (query?.filters) {
				const filters = parseFiltersForDexie(query.filters);
				if (filters.length > 0) {
					for (const filter of filters) {
						const { field, op, value } = filter;
						switch (op) {
							case 'eq':
								results = results.filter((item: any) => item[field] === value);
								break;
							case 'neq':
								results = results.filter((item: any) => item[field] !== value);
								break;
							case 'gt':
								results = results.filter((item: any) => item[field] > value);
								break;
							case 'gte':
								results = results.filter((item: any) => item[field] >= value);
								break;
							case 'lt':
								results = results.filter((item: any) => item[field] < value);
								break;
							case 'lte':
								results = results.filter((item: any) => item[field] <= value);
								break;
							case 'contains':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().includes(String(value).toLowerCase())
								);
								break;
							case 'startsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().startsWith(String(value).toLowerCase())
								);
								break;
							case 'endsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().endsWith(String(value).toLowerCase())
								);
								break;
							case 'in':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => value.includes(item[field]));
								}
								break;
							case 'notIn':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => !value.includes(item[field]));
								}
								break;
						}
					}
				}
			}

			// Apply search (on array)
			if (query?.search) {
				const searchLower = query.search.toLowerCase();
				results = results.filter((item: any) =>
					Object.values(item).some(val =>
						typeof val === 'string' && val.toLowerCase().includes(searchLower)
					)
				);
			}

			// Apply sorting
			if (query?.sorts) {
				try {
					const sortFields = JSON.parse(query.sorts);
					if (Array.isArray(sortFields) && sortFields.length > 0) {
						results.sort((a: any, b: any) => {
							for (const sort of sortFields) {
								const { field, dir } = sort;
								const aVal = a[field];
								const bVal = b[field];
								if (aVal === bVal) continue;
								const comparison = aVal < bVal ? -1 : 1;
								return dir === 'desc' ? -comparison : comparison;
							}
							return 0;
						}
						);
					}
				} catch {
					// Invalid sorts format, skip
				}
			}

			// Apply pagination
			if (query?.page && query?.take) {
				const skip = (query.page - 1) * query.take;
				results = results.slice(skip, skip + query.take);
			} else if (query?.take) {
				results = results.slice(0, query.take);
			}

			return results as StructurePtLog[];
		}
		const response = await apiClient.structurePtLogControllerFindAll(query);
		return (response.data as any) || [];
	},

	/**
	 * Create a new StructurePtLog
	 * @param structurePtLog - The StructurePtLog data to create
	 * @returns Promise<StructurePtLog>
	 */
	async structurePtLogControllerCreate(structurePtLog: StructurePtLog): Promise<StructurePtLog> {
		if (getMode() === WorkMode.OFFLINE) {
			await db.Geology_StructurePtLog.add(structurePtLog);
			const result = await db.Geology_StructurePtLog.get(structurePtLog.StructurePtLogId);
			if (!result) {
				throw new Error(`Failed to create StructurePtLog: ${structurePtLog.StructurePtLogId}`);
			}
			return result;
		}
		return (await apiClient.structurePtLogControllerCreate(structurePtLog)).data;
	},

	/**
	 * Update a StructurePtLog
	 * @param structurePtLogId - The StructurePtLogId to update
	 * @param structurePtLog - The updated StructurePtLog data
	 * @returns Promise<StructurePtLog>
	 */
	async structurePtLogControllerUpdate(structurePtLogId: string, structurePtLog: StructurePtLog): Promise<StructurePtLog> {
		if (getMode() === WorkMode.OFFLINE) {
			const numAffected = await db.Geology_StructurePtLog.update(structurePtLogId, structurePtLog as any);
			let result;
			if (numAffected > 0) {
				result = await db.Geology_StructurePtLog.get(structurePtLogId);
			}
			if (!result) {
				throw new Error(`StructurePtLog not found: ${structurePtLogId}`);
			}
			return result;
		}
		return (await apiClient.structurePtLogControllerUpdate(structurePtLogId, structurePtLog)).data;
	},

	/**
	 * Remove (soft delete) a StructurePtLog
	 * Calls the API Remove endpoint which sets ActiveInd to false
	 * @param structurePtLogId - The StructurePtLogId to remove
	 * @param structurePtLog - The StructurePtLog data
	 * @returns Promise<StructurePtLog>
	 */
	async structurePtLogControllerRemove(structurePtLogId: string, structurePtLog: StructurePtLog): Promise<StructurePtLog> {
		if (getMode() === WorkMode.OFFLINE) {
			// In offline mode, soft delete by updating ActiveInd
			const numAffected = await db.Geology_StructurePtLog.update(structurePtLogId, { ...structurePtLog, ActiveInd: false });
			let result;
			if (numAffected > 0) {
				result = await db.Geology_StructurePtLog.get(structurePtLogId);
			}
			if (!result) {
				throw new Error(`StructurePtLog not found: ${structurePtLogId}`);
			}
			return result;
		}
		// In online mode, call the API's Remove endpoint
		return (await apiClient.structurePtLogControllerUpdate(structurePtLogId, { ...structurePtLog, ActiveInd: false })).data;
	},

	/**
	 * Find a single CoreRecoveryRunLog by ID
	 * @param coreRecoveryRunLogId - The CoreRecoveryRunLogId to find
	 * @returns Promise<CoreRecoveryRunLog>
	 */
	async coreRecoveryRunLogControllerFindOne(coreRecoveryRunLogId: string): Promise<CoreRecoveryRunLog> {
		if (getMode() === WorkMode.OFFLINE) {
			const result = await db.Geotech_CoreRecoveryRunLog.get(coreRecoveryRunLogId);
			if (!result) {
				throw new Error(`CoreRecoveryRunLog not found: ${coreRecoveryRunLogId}`);
			}
			return result;
		}
		return (await apiClient.coreRecoveryRunLogControllerFindOne(coreRecoveryRunLogId)).data;
	},

	/**
	 * Find all CoreRecoveryRunLog records with optional filtering
	 * @param query - Optional query parameters for filtering, pagination, etc.
	 * @returns Promise<CoreRecoveryRunLog[]>
	 */
	async coreRecoveryRunLogControllerFindAll(query?: {
		page?: number;
		take?: number;
		order?: "ASC" | "DESC";
		search?: string;
		filters?: string | FilterInput;
		sorts?: string;
	}): Promise<CoreRecoveryRunLog[]> {
		if (getMode() === WorkMode.OFFLINE) {
			let collection = db.Geotech_CoreRecoveryRunLog.toCollection();

			// Get results as array
			let results = await collection.toArray();

			// Apply ALL filters on array
			if (query?.filters) {
				const filters = parseFiltersForDexie(query.filters);
				if (filters.length > 0) {
					for (const filter of filters) {
						const { field, op, value } = filter;
						switch (op) {
							case 'eq':
								results = results.filter((item: any) => item[field] === value);
								break;
							case 'neq':
								results = results.filter((item: any) => item[field] !== value);
								break;
							case 'gt':
								results = results.filter((item: any) => item[field] > value);
								break;
							case 'gte':
								results = results.filter((item: any) => item[field] >= value);
								break;
							case 'lt':
								results = results.filter((item: any) => item[field] < value);
								break;
							case 'lte':
								results = results.filter((item: any) => item[field] <= value);
								break;
							case 'contains':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().includes(String(value).toLowerCase())
								);
								break;
							case 'startsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().startsWith(String(value).toLowerCase())
								);
								break;
							case 'endsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().endsWith(String(value).toLowerCase())
								);
								break;
							case 'in':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => value.includes(item[field]));
								}
								break;
							case 'notIn':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => !value.includes(item[field]));
								}
								break;
						}
					}
				}
			}

			// Apply search (on array)
			if (query?.search) {
				const searchLower = query.search.toLowerCase();
				results = results.filter((item: any) =>
					Object.values(item).some(val =>
						typeof val === 'string' && val.toLowerCase().includes(searchLower)
					)
				);
			}

			// Apply sorting
			if (query?.sorts) {
				try {
					const sortFields = JSON.parse(query.sorts);
					if (Array.isArray(sortFields) && sortFields.length > 0) {
						results.sort((a: any, b: any) => {
							for (const sort of sortFields) {
								const { field, dir } = sort;
								const aVal = a[field];
								const bVal = b[field];
								if (aVal === bVal) continue;
								const comparison = aVal < bVal ? -1 : 1;
								return dir === 'desc' ? -comparison : comparison;
							}
							return 0;
						}
						);
					}
				} catch {
					// Invalid sorts format, skip
				}
			}

			// Apply pagination
			if (query?.page && query?.take) {
				const skip = (query.page - 1) * query.take;
				results = results.slice(skip, skip + query.take);
			} else if (query?.take) {
				results = results.slice(0, query.take);
			}

			return results as CoreRecoveryRunLog[];
		}
		const response = await apiClient.coreRecoveryRunLogControllerFindAll(query);
		return (response.data as any) || [];
	},

	/**
	 * Create a new CoreRecoveryRunLog
	 * @param coreRecoveryRunLog - The CoreRecoveryRunLog data to create
	 * @returns Promise<CoreRecoveryRunLog>
	 */
	async coreRecoveryRunLogControllerCreate(coreRecoveryRunLog: CoreRecoveryRunLog): Promise<CoreRecoveryRunLog> {
		if (getMode() === WorkMode.OFFLINE) {
			await db.Geotech_CoreRecoveryRunLog.add(coreRecoveryRunLog);
			const result = await db.Geotech_CoreRecoveryRunLog.get(coreRecoveryRunLog.CoreRecoveryRunLogId);
			if (!result) {
				throw new Error(`Failed to create CoreRecoveryRunLog: ${coreRecoveryRunLog.CoreRecoveryRunLogId}`);
			}
			return result;
		}
		return (await apiClient.coreRecoveryRunLogControllerCreate(coreRecoveryRunLog)).data;
	},

	/**
	 * Update a CoreRecoveryRunLog
	 * @param coreRecoveryRunLogId - The CoreRecoveryRunLogId to update
	 * @param coreRecoveryRunLog - The updated CoreRecoveryRunLog data
	 * @returns Promise<CoreRecoveryRunLog>
	 */
	async coreRecoveryRunLogControllerUpdate(coreRecoveryRunLogId: string, coreRecoveryRunLog: CoreRecoveryRunLog): Promise<CoreRecoveryRunLog> {
		if (getMode() === WorkMode.OFFLINE) {
			const numAffected = await db.Geotech_CoreRecoveryRunLog.update(coreRecoveryRunLogId, coreRecoveryRunLog as any);
			let result;
			if (numAffected > 0) {
				result = await db.Geotech_CoreRecoveryRunLog.get(coreRecoveryRunLogId);
			}
			if (!result) {
				throw new Error(`CoreRecoveryRunLog not found: ${coreRecoveryRunLogId}`);
			}
			return result;
		}
		return (await apiClient.coreRecoveryRunLogControllerUpdate(coreRecoveryRunLogId, coreRecoveryRunLog)).data;
	},

	/**
	 * Remove (soft delete) a CoreRecoveryRunLog
	 * Calls the API Remove endpoint which sets ActiveInd to false
	 * @param coreRecoveryRunLogId - The CoreRecoveryRunLogId to remove
	 * @param coreRecoveryRunLog - The CoreRecoveryRunLog data
	 * @returns Promise<CoreRecoveryRunLog>
	 */
	async coreRecoveryRunLogControllerRemove(coreRecoveryRunLogId: string, coreRecoveryRunLog: CoreRecoveryRunLog): Promise<CoreRecoveryRunLog> {
		if (getMode() === WorkMode.OFFLINE) {
			// In offline mode, soft delete by updating ActiveInd
			const numAffected = await db.Geotech_CoreRecoveryRunLog.update(coreRecoveryRunLogId, { ...coreRecoveryRunLog, ActiveInd: false });
			let result;
			if (numAffected > 0) {
				result = await db.Geotech_CoreRecoveryRunLog.get(coreRecoveryRunLogId);
			}
			if (!result) {
				throw new Error(`CoreRecoveryRunLog not found: ${coreRecoveryRunLogId}`);
			}
			return result;
		}
		// In online mode, call the API's Remove endpoint
		return (await apiClient.coreRecoveryRunLogControllerUpdate(coreRecoveryRunLogId, { ...coreRecoveryRunLog, ActiveInd: false })).data;
	},

	/**
	 * Find a single FractureCountLog by ID
	 * @param fractureCountLogId - The FractureCountLogId to find
	 * @returns Promise<FractureCountLog>
	 */
	async fractureCountLogControllerFindOne(fractureCountLogId: string): Promise<FractureCountLog> {
		if (getMode() === WorkMode.OFFLINE) {
			const result = await db.Geotech_FractureCountLog.get(fractureCountLogId);
			if (!result) {
				throw new Error(`FractureCountLog not found: ${fractureCountLogId}`);
			}
			return result;
		}
		return (await apiClient.fractureCountLogControllerFindOne(fractureCountLogId)).data;
	},

	/**
	 * Find all FractureCountLog records with optional filtering
	 * @param query - Optional query parameters for filtering, pagination, etc.
	 * @returns Promise<FractureCountLog[]>
	 */
	async fractureCountLogControllerFindAll(query?: {
		page?: number;
		take?: number;
		order?: "ASC" | "DESC";
		search?: string;
		filters?: string | FilterInput;
		sorts?: string;
	}): Promise<FractureCountLog[]> {
		if (getMode() === WorkMode.OFFLINE) {
			let collection = db.Geotech_FractureCountLog.toCollection();

			// Get results as array
			let results = await collection.toArray();

			// Apply ALL filters on array
			if (query?.filters) {
				const filters = parseFiltersForDexie(query.filters);
				if (filters.length > 0) {
					for (const filter of filters) {
						const { field, op, value } = filter;
						switch (op) {
							case 'eq':
								results = results.filter((item: any) => item[field] === value);
								break;
							case 'neq':
								results = results.filter((item: any) => item[field] !== value);
								break;
							case 'gt':
								results = results.filter((item: any) => item[field] > value);
								break;
							case 'gte':
								results = results.filter((item: any) => item[field] >= value);
								break;
							case 'lt':
								results = results.filter((item: any) => item[field] < value);
								break;
							case 'lte':
								results = results.filter((item: any) => item[field] <= value);
								break;
							case 'contains':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().includes(String(value).toLowerCase())
								);
								break;
							case 'startsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().startsWith(String(value).toLowerCase())
								);
								break;
							case 'endsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().endsWith(String(value).toLowerCase())
								);
								break;
							case 'in':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => value.includes(item[field]));
								}
								break;
							case 'notIn':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => !value.includes(item[field]));
								}
								break;
						}
					}
				}
			}

			// Apply search (on array)
			if (query?.search) {
				const searchLower = query.search.toLowerCase();
				results = results.filter((item: any) =>
					Object.values(item).some(val =>
						typeof val === 'string' && val.toLowerCase().includes(searchLower)
					)
				);
			}

			// Apply sorting
			if (query?.sorts) {
				try {
					const sortFields = JSON.parse(query.sorts);
					if (Array.isArray(sortFields) && sortFields.length > 0) {
						results.sort((a: any, b: any) => {
							for (const sort of sortFields) {
								const { field, dir } = sort;
								const aVal = a[field];
								const bVal = b[field];
								if (aVal === bVal) continue;
								const comparison = aVal < bVal ? -1 : 1;
								return dir === 'desc' ? -comparison : comparison;
							}
							return 0;
						}
						);
					}
				} catch {
					// Invalid sorts format, skip
				}
			}

			// Apply pagination
			if (query?.page && query?.take) {
				const skip = (query.page - 1) * query.take;
				results = results.slice(skip, skip + query.take);
			} else if (query?.take) {
				results = results.slice(0, query.take);
			}

			return results as FractureCountLog[];
		}
		const response = await apiClient.fractureCountLogControllerFindAll(query);
		return (response.data as any) || [];
	},

	/**
	 * Create a new FractureCountLog
	 * @param fractureCountLog - The FractureCountLog data to create
	 * @returns Promise<FractureCountLog>
	 */
	async fractureCountLogControllerCreate(fractureCountLog: FractureCountLog): Promise<FractureCountLog> {
		if (getMode() === WorkMode.OFFLINE) {
			await db.Geotech_FractureCountLog.add(fractureCountLog);
			const result = await db.Geotech_FractureCountLog.get(fractureCountLog.FractureCountLogId);
			if (!result) {
				throw new Error(`Failed to create FractureCountLog: ${fractureCountLog.FractureCountLogId}`);
			}
			return result;
		}
		return (await apiClient.fractureCountLogControllerCreate(fractureCountLog)).data;
	},

	/**
	 * Update a FractureCountLog
	 * @param fractureCountLogId - The FractureCountLogId to update
	 * @param fractureCountLog - The updated FractureCountLog data
	 * @returns Promise<FractureCountLog>
	 */
	async fractureCountLogControllerUpdate(fractureCountLogId: string, fractureCountLog: FractureCountLog): Promise<FractureCountLog> {
		if (getMode() === WorkMode.OFFLINE) {
			const numAffected = await db.Geotech_FractureCountLog.update(fractureCountLogId, fractureCountLog as any);
			let result;
			if (numAffected > 0) {
				result = await db.Geotech_FractureCountLog.get(fractureCountLogId);
			}
			if (!result) {
				throw new Error(`FractureCountLog not found: ${fractureCountLogId}`);
			}
			return result;
		}
		return (await apiClient.fractureCountLogControllerUpdate(fractureCountLogId, fractureCountLog)).data;
	},

	/**
	 * Remove (soft delete) a FractureCountLog
	 * Calls the API Remove endpoint which sets ActiveInd to false
	 * @param fractureCountLogId - The FractureCountLogId to remove
	 * @param fractureCountLog - The FractureCountLog data
	 * @returns Promise<FractureCountLog>
	 */
	async fractureCountLogControllerRemove(fractureCountLogId: string, fractureCountLog: FractureCountLog): Promise<FractureCountLog> {
		if (getMode() === WorkMode.OFFLINE) {
			// In offline mode, soft delete by updating ActiveInd
			const numAffected = await db.Geotech_FractureCountLog.update(fractureCountLogId, { ...fractureCountLog, ActiveInd: false });
			let result;
			if (numAffected > 0) {
				result = await db.Geotech_FractureCountLog.get(fractureCountLogId);
			}
			if (!result) {
				throw new Error(`FractureCountLog not found: ${fractureCountLogId}`);
			}
			return result;
		}
		// In online mode, call the API's Remove endpoint
		return (await apiClient.fractureCountLogControllerUpdate(fractureCountLogId, { ...fractureCountLog, ActiveInd: false })).data;
	},

	/**
	 * Find a single MagSusLog by ID
	 * @param magSusLogId - The MagSusLogId to find
	 * @returns Promise<MagSusLog>
	 */
	async magSusLogControllerFindOne(magSusLogId: string): Promise<MagSusLog> {
		if (getMode() === WorkMode.OFFLINE) {
			const result = await db.Geotech_MagSusLog.get(magSusLogId);
			if (!result) {
				throw new Error(`MagSusLog not found: ${magSusLogId}`);
			}
			return result;
		}
		return (await apiClient.magSusLogControllerFindOne(magSusLogId)).data;
	},

	/**
	 * Find all MagSusLog records with optional filtering
	 * @param query - Optional query parameters for filtering, pagination, etc.
	 * @returns Promise<MagSusLog[]>
	 */
	async magSusLogControllerFindAll(query?: {
		page?: number;
		take?: number;
		order?: "ASC" | "DESC";
		search?: string;
		filters?: string | FilterInput;
		sorts?: string;
	}): Promise<MagSusLog[]> {
		if (getMode() === WorkMode.OFFLINE) {
			let collection = db.Geotech_MagSusLog.toCollection();

			// Get results as array
			let results = await collection.toArray();

			// Apply ALL filters on array
			if (query?.filters) {
				const filters = parseFiltersForDexie(query.filters);
				if (filters.length > 0) {
					for (const filter of filters) {
						const { field, op, value } = filter;
						switch (op) {
							case 'eq':
								results = results.filter((item: any) => item[field] === value);
								break;
							case 'neq':
								results = results.filter((item: any) => item[field] !== value);
								break;
							case 'gt':
								results = results.filter((item: any) => item[field] > value);
								break;
							case 'gte':
								results = results.filter((item: any) => item[field] >= value);
								break;
							case 'lt':
								results = results.filter((item: any) => item[field] < value);
								break;
							case 'lte':
								results = results.filter((item: any) => item[field] <= value);
								break;
							case 'contains':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().includes(String(value).toLowerCase())
								);
								break;
							case 'startsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().startsWith(String(value).toLowerCase())
								);
								break;
							case 'endsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().endsWith(String(value).toLowerCase())
								);
								break;
							case 'in':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => value.includes(item[field]));
								}
								break;
							case 'notIn':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => !value.includes(item[field]));
								}
								break;
						}
					}
				}
			}

			// Apply search (on array)
			if (query?.search) {
				const searchLower = query.search.toLowerCase();
				results = results.filter((item: any) =>
					Object.values(item).some(val =>
						typeof val === 'string' && val.toLowerCase().includes(searchLower)
					)
				);
			}

			// Apply sorting
			if (query?.sorts) {
				try {
					const sortFields = JSON.parse(query.sorts);
					if (Array.isArray(sortFields) && sortFields.length > 0) {
						results.sort((a: any, b: any) => {
							for (const sort of sortFields) {
								const { field, dir } = sort;
								const aVal = a[field];
								const bVal = b[field];
								if (aVal === bVal) continue;
								const comparison = aVal < bVal ? -1 : 1;
								return dir === 'desc' ? -comparison : comparison;
							}
							return 0;
						}
						);
					}
				} catch {
					// Invalid sorts format, skip
				}
			}

			// Apply pagination
			if (query?.page && query?.take) {
				const skip = (query.page - 1) * query.take;
				results = results.slice(skip, skip + query.take);
			} else if (query?.take) {
				results = results.slice(0, query.take);
			}

			return results as MagSusLog[];
		}
		const response = await apiClient.magSusLogControllerFindAll(query);
		return (response.data as any) || [];
	},

	/**
	 * Create a new MagSusLog
	 * @param magSusLog - The MagSusLog data to create
	 * @returns Promise<MagSusLog>
	 */
	async magSusLogControllerCreate(magSusLog: MagSusLog): Promise<MagSusLog> {
		if (getMode() === WorkMode.OFFLINE) {
			await db.Geotech_MagSusLog.add(magSusLog);
			const result = await db.Geotech_MagSusLog.get(magSusLog.MagSusLogId);
			if (!result) {
				throw new Error(`Failed to create MagSusLog: ${magSusLog.MagSusLogId}`);
			}
			return result;
		}
		return (await apiClient.magSusLogControllerCreate(magSusLog)).data;
	},

	/**
	 * Update a MagSusLog
	 * @param magSusLogId - The MagSusLogId to update
	 * @param magSusLog - The updated MagSusLog data
	 * @returns Promise<MagSusLog>
	 */
	async magSusLogControllerUpdate(magSusLogId: string, magSusLog: MagSusLog): Promise<MagSusLog> {
		if (getMode() === WorkMode.OFFLINE) {
			const numAffected = await db.Geotech_MagSusLog.update(magSusLogId, magSusLog as any);
			let result;
			if (numAffected > 0) {
				result = await db.Geotech_MagSusLog.get(magSusLogId);
			}
			if (!result) {
				throw new Error(`MagSusLog not found: ${magSusLogId}`);
			}
			return result;
		}
		return (await apiClient.magSusLogControllerUpdate(magSusLogId, magSusLog)).data;
	},

	/**
	 * Remove (soft delete) a MagSusLog
	 * Calls the API Remove endpoint which sets ActiveInd to false
	 * @param magSusLogId - The MagSusLogId to remove
	 * @param magSusLog - The MagSusLog data
	 * @returns Promise<MagSusLog>
	 */
	async magSusLogControllerRemove(magSusLogId: string, magSusLog: MagSusLog): Promise<MagSusLog> {
		if (getMode() === WorkMode.OFFLINE) {
			// In offline mode, soft delete by updating ActiveInd
			const numAffected = await db.Geotech_MagSusLog.update(magSusLogId, { ...magSusLog, ActiveInd: false });
			let result;
			if (numAffected > 0) {
				result = await db.Geotech_MagSusLog.get(magSusLogId);
			}
			if (!result) {
				throw new Error(`MagSusLog not found: ${magSusLogId}`);
			}
			return result;
		}
		// In online mode, call the API's Remove endpoint
		return (await apiClient.magSusLogControllerUpdate(magSusLogId, { ...magSusLog, ActiveInd: false })).data;
	},

	/**
	 * Find a single RockMechanicLog by ID
	 * @param rockMechanicLogId - The RockMechanicLogId to find
	 * @returns Promise<RockMechanicLog>
	 */
	async rockMechanicLogControllerFindOne(rockMechanicLogId: string): Promise<RockMechanicLog> {
		if (getMode() === WorkMode.OFFLINE) {
			const result = await db.Geotech_RockMechanicLog.get(rockMechanicLogId);
			if (!result) {
				throw new Error(`RockMechanicLog not found: ${rockMechanicLogId}`);
			}
			return result;
		}
		return (await apiClient.rockMechanicLogControllerFindOne(rockMechanicLogId)).data;
	},

	/**
	 * Find all RockMechanicLog records with optional filtering
	 * @param query - Optional query parameters for filtering, pagination, etc.
	 * @returns Promise<RockMechanicLog[]>
	 */
	async rockMechanicLogControllerFindAll(query?: {
		page?: number;
		take?: number;
		order?: "ASC" | "DESC";
		search?: string;
		filters?: string | FilterInput;
		sorts?: string;
	}): Promise<RockMechanicLog[]> {
		if (getMode() === WorkMode.OFFLINE) {
			let collection = db.Geotech_RockMechanicLog.toCollection();

			// Get results as array
			let results = await collection.toArray();

			// Apply ALL filters on array
			if (query?.filters) {
				const filters = parseFiltersForDexie(query.filters);
				if (filters.length > 0) {
					for (const filter of filters) {
						const { field, op, value } = filter;
						switch (op) {
							case 'eq':
								results = results.filter((item: any) => item[field] === value);
								break;
							case 'neq':
								results = results.filter((item: any) => item[field] !== value);
								break;
							case 'gt':
								results = results.filter((item: any) => item[field] > value);
								break;
							case 'gte':
								results = results.filter((item: any) => item[field] >= value);
								break;
							case 'lt':
								results = results.filter((item: any) => item[field] < value);
								break;
							case 'lte':
								results = results.filter((item: any) => item[field] <= value);
								break;
							case 'contains':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().includes(String(value).toLowerCase())
								);
								break;
							case 'startsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().startsWith(String(value).toLowerCase())
								);
								break;
							case 'endsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().endsWith(String(value).toLowerCase())
								);
								break;
							case 'in':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => value.includes(item[field]));
								}
								break;
							case 'notIn':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => !value.includes(item[field]));
								}
								break;
						}
					}
				}
			}

			// Apply search (on array)
			if (query?.search) {
				const searchLower = query.search.toLowerCase();
				results = results.filter((item: any) =>
					Object.values(item).some(val =>
						typeof val === 'string' && val.toLowerCase().includes(searchLower)
					)
				);
			}

			// Apply sorting
			if (query?.sorts) {
				try {
					const sortFields = JSON.parse(query.sorts);
					if (Array.isArray(sortFields) && sortFields.length > 0) {
						results.sort((a: any, b: any) => {
							for (const sort of sortFields) {
								const { field, dir } = sort;
								const aVal = a[field];
								const bVal = b[field];
								if (aVal === bVal) continue;
								const comparison = aVal < bVal ? -1 : 1;
								return dir === 'desc' ? -comparison : comparison;
							}
							return 0;
						}
						);
					}
				} catch {
					// Invalid sorts format, skip
				}
			}

			// Apply pagination
			if (query?.page && query?.take) {
				const skip = (query.page - 1) * query.take;
				results = results.slice(skip, skip + query.take);
			} else if (query?.take) {
				results = results.slice(0, query.take);
			}

			return results as RockMechanicLog[];
		}
		const response = await apiClient.rockMechanicLogControllerFindAll(query);
		return (response.data as any) || [];
	},

	/**
	 * Create a new RockMechanicLog
	 * @param rockMechanicLog - The RockMechanicLog data to create
	 * @returns Promise<RockMechanicLog>
	 */
	async rockMechanicLogControllerCreate(rockMechanicLog: RockMechanicLog): Promise<RockMechanicLog> {
		if (getMode() === WorkMode.OFFLINE) {
			await db.Geotech_RockMechanicLog.add(rockMechanicLog);
			const result = await db.Geotech_RockMechanicLog.get(rockMechanicLog.RockMechanicLogId);
			if (!result) {
				throw new Error(`Failed to create RockMechanicLog: ${rockMechanicLog.RockMechanicLogId}`);
			}
			return result;
		}
		return (await apiClient.rockMechanicLogControllerCreate(rockMechanicLog)).data;
	},

	/**
	 * Update a RockMechanicLog
	 * @param rockMechanicLogId - The RockMechanicLogId to update
	 * @param rockMechanicLog - The updated RockMechanicLog data
	 * @returns Promise<RockMechanicLog>
	 */
	async rockMechanicLogControllerUpdate(rockMechanicLogId: string, rockMechanicLog: RockMechanicLog): Promise<RockMechanicLog> {
		if (getMode() === WorkMode.OFFLINE) {
			const numAffected = await db.Geotech_RockMechanicLog.update(rockMechanicLogId, rockMechanicLog as any);
			let result;
			if (numAffected > 0) {
				result = await db.Geotech_RockMechanicLog.get(rockMechanicLogId);
			}
			if (!result) {
				throw new Error(`RockMechanicLog not found: ${rockMechanicLogId}`);
			}
			return result;
		}
		return (await apiClient.rockMechanicLogControllerUpdate(rockMechanicLogId, rockMechanicLog)).data;
	},

	/**
	 * Remove (soft delete) a RockMechanicLog
	 * Calls the API Remove endpoint which sets ActiveInd to false
	 * @param rockMechanicLogId - The RockMechanicLogId to remove
	 * @param rockMechanicLog - The RockMechanicLog data
	 * @returns Promise<RockMechanicLog>
	 */
	async rockMechanicLogControllerRemove(rockMechanicLogId: string, rockMechanicLog: RockMechanicLog): Promise<RockMechanicLog> {
		if (getMode() === WorkMode.OFFLINE) {
			// In offline mode, soft delete by updating ActiveInd
			const numAffected = await db.Geotech_RockMechanicLog.update(rockMechanicLogId, { ...rockMechanicLog, ActiveInd: false });
			let result;
			if (numAffected > 0) {
				result = await db.Geotech_RockMechanicLog.get(rockMechanicLogId);
			}
			if (!result) {
				throw new Error(`RockMechanicLog not found: ${rockMechanicLogId}`);
			}
			return result;
		}
		// In online mode, call the API's Remove endpoint
		return (await apiClient.rockMechanicLogControllerUpdate(rockMechanicLogId, { ...rockMechanicLog, ActiveInd: false })).data;
	},

	/**
	 * Find a single RockQualityDesignationLog by ID
	 * @param rockQualityDesignationLogId - The RockQualityDesignationLogId to find
	 * @returns Promise<RockQualityDesignationLog>
	 */
	async rockQualityDesignationLogControllerFindOne(rockQualityDesignationLogId: string): Promise<RockQualityDesignationLog> {
		if (getMode() === WorkMode.OFFLINE) {
			const result = await db.Geotech_RockQualityDesignationLog.get(rockQualityDesignationLogId);
			if (!result) {
				throw new Error(`RockQualityDesignationLog not found: ${rockQualityDesignationLogId}`);
			}
			return result;
		}
		return (await apiClient.rockQualityDesignationLogControllerFindOne(rockQualityDesignationLogId)).data;
	},

	/**
	 * Find all RockQualityDesignationLog records with optional filtering
	 * @param query - Optional query parameters for filtering, pagination, etc.
	 * @returns Promise<RockQualityDesignationLog[]>
	 */
	async rockQualityDesignationLogControllerFindAll(query?: {
		page?: number;
		take?: number;
		order?: "ASC" | "DESC";
		search?: string;
		filters?: string | FilterInput;
		sorts?: string;
	}): Promise<RockQualityDesignationLog[]> {
		if (getMode() === WorkMode.OFFLINE) {
			let collection = db.Geotech_RockQualityDesignationLog.toCollection();

			// Get results as array
			let results = await collection.toArray();

			// Apply ALL filters on array
			if (query?.filters) {
				const filters = parseFiltersForDexie(query.filters);
				if (filters.length > 0) {
					for (const filter of filters) {
						const { field, op, value } = filter;
						switch (op) {
							case 'eq':
								results = results.filter((item: any) => item[field] === value);
								break;
							case 'neq':
								results = results.filter((item: any) => item[field] !== value);
								break;
							case 'gt':
								results = results.filter((item: any) => item[field] > value);
								break;
							case 'gte':
								results = results.filter((item: any) => item[field] >= value);
								break;
							case 'lt':
								results = results.filter((item: any) => item[field] < value);
								break;
							case 'lte':
								results = results.filter((item: any) => item[field] <= value);
								break;
							case 'contains':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().includes(String(value).toLowerCase())
								);
								break;
							case 'startsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().startsWith(String(value).toLowerCase())
								);
								break;
							case 'endsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().endsWith(String(value).toLowerCase())
								);
								break;
							case 'in':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => value.includes(item[field]));
								}
								break;
							case 'notIn':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => !value.includes(item[field]));
								}
								break;
						}
					}
				}
			}

			// Apply search (on array)
			if (query?.search) {
				const searchLower = query.search.toLowerCase();
				results = results.filter((item: any) =>
					Object.values(item).some(val =>
						typeof val === 'string' && val.toLowerCase().includes(searchLower)
					)
				);
			}

			// Apply sorting
			if (query?.sorts) {
				try {
					const sortFields = JSON.parse(query.sorts);
					if (Array.isArray(sortFields) && sortFields.length > 0) {
						results.sort((a: any, b: any) => {
							for (const sort of sortFields) {
								const { field, dir } = sort;
								const aVal = a[field];
								const bVal = b[field];
								if (aVal === bVal) continue;
								const comparison = aVal < bVal ? -1 : 1;
								return dir === 'desc' ? -comparison : comparison;
							}
							return 0;
						}
						);
					}
				} catch {
					// Invalid sorts format, skip
				}
			}

			// Apply pagination
			if (query?.page && query?.take) {
				const skip = (query.page - 1) * query.take;
				results = results.slice(skip, skip + query.take);
			} else if (query?.take) {
				results = results.slice(0, query.take);
			}

			return results as RockQualityDesignationLog[];
		}
		const response = await apiClient.rockQualityDesignationLogControllerFindAll(query);
		return (response.data as any) || [];
	},

	/**
	 * Create a new RockQualityDesignationLog
	 * @param rockQualityDesignationLog - The RockQualityDesignationLog data to create
	 * @returns Promise<RockQualityDesignationLog>
	 */
	async rockQualityDesignationLogControllerCreate(rockQualityDesignationLog: RockQualityDesignationLog): Promise<RockQualityDesignationLog> {
		if (getMode() === WorkMode.OFFLINE) {
			await db.Geotech_RockQualityDesignationLog.add(rockQualityDesignationLog);
			const result = await db.Geotech_RockQualityDesignationLog.get(rockQualityDesignationLog.RockQualityDesignationLogId);
			if (!result) {
				throw new Error(`Failed to create RockQualityDesignationLog: ${rockQualityDesignationLog.RockQualityDesignationLogId}`);
			}
			return result;
		}
		return (await apiClient.rockQualityDesignationLogControllerCreate(rockQualityDesignationLog)).data;
	},

	/**
	 * Update a RockQualityDesignationLog
	 * @param rockQualityDesignationLogId - The RockQualityDesignationLogId to update
	 * @param rockQualityDesignationLog - The updated RockQualityDesignationLog data
	 * @returns Promise<RockQualityDesignationLog>
	 */
	async rockQualityDesignationLogControllerUpdate(rockQualityDesignationLogId: string, rockQualityDesignationLog: RockQualityDesignationLog): Promise<RockQualityDesignationLog> {
		if (getMode() === WorkMode.OFFLINE) {
			const numAffected = await db.Geotech_RockQualityDesignationLog.update(rockQualityDesignationLogId, rockQualityDesignationLog as any);
			let result;
			if (numAffected > 0) {
				result = await db.Geotech_RockQualityDesignationLog.get(rockQualityDesignationLogId);
			}
			if (!result) {
				throw new Error(`RockQualityDesignationLog not found: ${rockQualityDesignationLogId}`);
			}
			return result;
		}
		return (await apiClient.rockQualityDesignationLogControllerUpdate(rockQualityDesignationLogId, rockQualityDesignationLog)).data;
	},

	/**
	 * Remove (soft delete) a RockQualityDesignationLog
	 * Calls the API Remove endpoint which sets ActiveInd to false
	 * @param rockQualityDesignationLogId - The RockQualityDesignationLogId to remove
	 * @param rockQualityDesignationLog - The RockQualityDesignationLog data
	 * @returns Promise<RockQualityDesignationLog>
	 */
	async rockQualityDesignationLogControllerRemove(rockQualityDesignationLogId: string, rockQualityDesignationLog: RockQualityDesignationLog): Promise<RockQualityDesignationLog> {
		if (getMode() === WorkMode.OFFLINE) {
			// In offline mode, soft delete by updating ActiveInd
			const numAffected = await db.Geotech_RockQualityDesignationLog.update(rockQualityDesignationLogId, { ...rockQualityDesignationLog, ActiveInd: false });
			let result;
			if (numAffected > 0) {
				result = await db.Geotech_RockQualityDesignationLog.get(rockQualityDesignationLogId);
			}
			if (!result) {
				throw new Error(`RockQualityDesignationLog not found: ${rockQualityDesignationLogId}`);
			}
			return result;
		}
		// In online mode, call the API's Remove endpoint
		return (await apiClient.rockQualityDesignationLogControllerUpdate(rockQualityDesignationLogId, { ...rockQualityDesignationLog, ActiveInd: false })).data;
	},

	/**
	 * Find a single SpecificGravityPtLog by ID
	 * @param specificGravityPtLogId - The SpecificGravityPtLogId to find
	 * @returns Promise<SpecificGravityPtLog>
	 */
	async specificGravityPtLogControllerFindOne(specificGravityPtLogId: string): Promise<SpecificGravityPtLog> {
		if (getMode() === WorkMode.OFFLINE) {
			const result = await db.Geotech_SpecificGravityPtLog.get(specificGravityPtLogId);
			if (!result) {
				throw new Error(`SpecificGravityPtLog not found: ${specificGravityPtLogId}`);
			}
			return result;
		}
		return (await apiClient.specificGravityPtLogControllerFindOne(specificGravityPtLogId)).data;
	},

	/**
	 * Find all SpecificGravityPtLog records with optional filtering
	 * @param query - Optional query parameters for filtering, pagination, etc.
	 * @returns Promise<SpecificGravityPtLog[]>
	 */
	async specificGravityPtLogControllerFindAll(query?: {
		page?: number;
		take?: number;
		order?: "ASC" | "DESC";
		search?: string;
		filters?: string | FilterInput;
		sorts?: string;
	}): Promise<SpecificGravityPtLog[]> {
		if (getMode() === WorkMode.OFFLINE) {
			let collection = db.Geotech_SpecificGravityPtLog.toCollection();

			// Get results as array
			let results = await collection.toArray();

			// Apply ALL filters on array
			if (query?.filters) {
				const filters = parseFiltersForDexie(query.filters);
				if (filters.length > 0) {
					for (const filter of filters) {
						const { field, op, value } = filter;
						switch (op) {
							case 'eq':
								results = results.filter((item: any) => item[field] === value);
								break;
							case 'neq':
								results = results.filter((item: any) => item[field] !== value);
								break;
							case 'gt':
								results = results.filter((item: any) => item[field] > value);
								break;
							case 'gte':
								results = results.filter((item: any) => item[field] >= value);
								break;
							case 'lt':
								results = results.filter((item: any) => item[field] < value);
								break;
							case 'lte':
								results = results.filter((item: any) => item[field] <= value);
								break;
							case 'contains':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().includes(String(value).toLowerCase())
								);
								break;
							case 'startsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().startsWith(String(value).toLowerCase())
								);
								break;
							case 'endsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().endsWith(String(value).toLowerCase())
								);
								break;
							case 'in':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => value.includes(item[field]));
								}
								break;
							case 'notIn':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => !value.includes(item[field]));
								}
								break;
						}
					}
				}
			}

			// Apply search (on array)
			if (query?.search) {
				const searchLower = query.search.toLowerCase();
				results = results.filter((item: any) =>
					Object.values(item).some(val =>
						typeof val === 'string' && val.toLowerCase().includes(searchLower)
					)
				);
			}

			// Apply sorting
			if (query?.sorts) {
				try {
					const sortFields = JSON.parse(query.sorts);
					if (Array.isArray(sortFields) && sortFields.length > 0) {
						results.sort((a: any, b: any) => {
							for (const sort of sortFields) {
								const { field, dir } = sort;
								const aVal = a[field];
								const bVal = b[field];
								if (aVal === bVal) continue;
								const comparison = aVal < bVal ? -1 : 1;
								return dir === 'desc' ? -comparison : comparison;
							}
							return 0;
						}
						);
					}
				} catch {
					// Invalid sorts format, skip
				}
			}

			// Apply pagination
			if (query?.page && query?.take) {
				const skip = (query.page - 1) * query.take;
				results = results.slice(skip, skip + query.take);
			} else if (query?.take) {
				results = results.slice(0, query.take);
			}

			return results as SpecificGravityPtLog[];
		}
		const response = await apiClient.specificGravityPtLogControllerFindAll(query);
		return (response.data as any) || [];
	},

	/**
	 * Create a new SpecificGravityPtLog
	 * @param specificGravityPtLog - The SpecificGravityPtLog data to create
	 * @returns Promise<SpecificGravityPtLog>
	 */
	async specificGravityPtLogControllerCreate(specificGravityPtLog: SpecificGravityPtLog): Promise<SpecificGravityPtLog> {
		if (getMode() === WorkMode.OFFLINE) {
			await db.Geotech_SpecificGravityPtLog.add(specificGravityPtLog);
			const result = await db.Geotech_SpecificGravityPtLog.get(specificGravityPtLog.SpecificGravityPtLogId);
			if (!result) {
				throw new Error(`Failed to create SpecificGravityPtLog: ${specificGravityPtLog.SpecificGravityPtLogId}`);
			}
			return result;
		}
		return (await apiClient.specificGravityPtLogControllerCreate(specificGravityPtLog)).data;
	},

	/**
	 * Update a SpecificGravityPtLog
	 * @param specificGravityPtLogId - The SpecificGravityPtLogId to update
	 * @param specificGravityPtLog - The updated SpecificGravityPtLog data
	 * @returns Promise<SpecificGravityPtLog>
	 */
	async specificGravityPtLogControllerUpdate(specificGravityPtLogId: string, specificGravityPtLog: SpecificGravityPtLog): Promise<SpecificGravityPtLog> {
		if (getMode() === WorkMode.OFFLINE) {
			const numAffected = await db.Geotech_SpecificGravityPtLog.update(specificGravityPtLogId, specificGravityPtLog as any);
			let result;
			if (numAffected > 0) {
				result = await db.Geotech_SpecificGravityPtLog.get(specificGravityPtLogId);
			}
			if (!result) {
				throw new Error(`SpecificGravityPtLog not found: ${specificGravityPtLogId}`);
			}
			return result;
		}
		return (await apiClient.specificGravityPtLogControllerUpdate(specificGravityPtLogId, specificGravityPtLog)).data;
	},

	/**
	 * Remove (soft delete) a SpecificGravityPtLog
	 * Calls the API Remove endpoint which sets ActiveInd to false
	 * @param specificGravityPtLogId - The SpecificGravityPtLogId to remove
	 * @param specificGravityPtLog - The SpecificGravityPtLog data
	 * @returns Promise<SpecificGravityPtLog>
	 */
	async specificGravityPtLogControllerRemove(specificGravityPtLogId: string, specificGravityPtLog: SpecificGravityPtLog): Promise<SpecificGravityPtLog> {
		if (getMode() === WorkMode.OFFLINE) {
			// In offline mode, soft delete by updating ActiveInd
			const numAffected = await db.Geotech_SpecificGravityPtLog.update(specificGravityPtLogId, { ...specificGravityPtLog, ActiveInd: false });
			let result;
			if (numAffected > 0) {
				result = await db.Geotech_SpecificGravityPtLog.get(specificGravityPtLogId);
			}
			if (!result) {
				throw new Error(`SpecificGravityPtLog not found: ${specificGravityPtLogId}`);
			}
			return result;
		}
		// In online mode, call the API's Remove endpoint
		return (await apiClient.specificGravityPtLogControllerUpdate(specificGravityPtLogId, { ...specificGravityPtLog, ActiveInd: false })).data;
	},

	/**
	 * Find a single CollarCoordinate by ID
	 * @param collarCoordinateId - The CollarCoordinateId to find
	 * @returns Promise<CollarCoordinate>
	 */
	async collarCoordinateControllerFindOne(collarCoordinateId: string): Promise<CollarCoordinate> {
		if (getMode() === WorkMode.OFFLINE) {
			const result = await db.DrillHole_CollarCoordinate.get(collarCoordinateId);
			if (!result) {
				throw new Error(`CollarCoordinate not found: ${collarCoordinateId}`);
			}
			return result;
		}
		return (await apiClient.collarCoordinateControllerFindOne(collarCoordinateId)).data;
	},

	/**
	 * Find all CollarCoordinate records with optional filtering
	 * @param query - Optional query parameters for filtering, pagination, etc.
	 * @returns Promise<CollarCoordinate[]>
	 */
	async collarCoordinateControllerFindAll(query?: {
		page?: number;
		take?: number;
		order?: "ASC" | "DESC";
		search?: string;
		filters?: string | FilterInput;
		sorts?: string;
	}): Promise<CollarCoordinate[]> {
		if (getMode() === WorkMode.OFFLINE) {
			let collection = db.DrillHole_CollarCoordinate.toCollection();

			// Get results as array
			let results = await collection.toArray();

			// Apply ALL filters on array
			if (query?.filters) {
				const filters = parseFiltersForDexie(query.filters);
				if (filters.length > 0) {
					for (const filter of filters) {
						const { field, op, value } = filter;
						switch (op) {
							case 'eq':
								results = results.filter((item: any) => item[field] === value);
								break;
							case 'neq':
								results = results.filter((item: any) => item[field] !== value);
								break;
							case 'gt':
								results = results.filter((item: any) => item[field] > value);
								break;
							case 'gte':
								results = results.filter((item: any) => item[field] >= value);
								break;
							case 'lt':
								results = results.filter((item: any) => item[field] < value);
								break;
							case 'lte':
								results = results.filter((item: any) => item[field] <= value);
								break;
							case 'contains':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().includes(String(value).toLowerCase())
								);
								break;
							case 'startsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().startsWith(String(value).toLowerCase())
								);
								break;
							case 'endsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().endsWith(String(value).toLowerCase())
								);
								break;
							case 'in':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => value.includes(item[field]));
								}
								break;
							case 'notIn':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => !value.includes(item[field]));
								}
								break;
						}
					}
				}
			}

			// Apply search (on array)
			if (query?.search) {
				const searchLower = query.search.toLowerCase();
				results = results.filter((item: any) =>
					Object.values(item).some(val =>
						typeof val === 'string' && val.toLowerCase().includes(searchLower)
					)
				);
			}

			// Apply sorting
			if (query?.sorts) {
				try {
					const sortFields = JSON.parse(query.sorts);
					if (Array.isArray(sortFields) && sortFields.length > 0) {
						results.sort((a: any, b: any) => {
							for (const sort of sortFields) {
								const { field, dir } = sort;
								const aVal = a[field];
								const bVal = b[field];
								if (aVal === bVal) continue;
								const comparison = aVal < bVal ? -1 : 1;
								return dir === 'desc' ? -comparison : comparison;
							}
							return 0;
						}
						);
					}
				} catch {
					// Invalid sorts format, skip
				}
			}

			// Apply pagination
			if (query?.page && query?.take) {
				const skip = (query.page - 1) * query.take;
				results = results.slice(skip, skip + query.take);
			} else if (query?.take) {
				results = results.slice(0, query.take);
			}

			return results as CollarCoordinate[];
		}
		const response = await apiClient.collarCoordinateControllerFindAll(query);
		return (response.data as any) || [];
	},

	/**
	 * Create a new CollarCoordinate
	 * @param collarCoordinate - The CollarCoordinate data to create
	 * @returns Promise<CollarCoordinate>
	 */
	async collarCoordinateControllerCreate(collarCoordinate: CollarCoordinate): Promise<CollarCoordinate> {
		if (getMode() === WorkMode.OFFLINE) {
			await db.DrillHole_CollarCoordinate.add(collarCoordinate);
			const result = await db.DrillHole_CollarCoordinate.get(collarCoordinate.CollarCoordinateId);
			if (!result) {
				throw new Error(`Failed to create CollarCoordinate: ${collarCoordinate.CollarCoordinateId}`);
			}
			return result;
		}
		return (await apiClient.collarCoordinateControllerCreate(collarCoordinate)).data;
	},

	/**
	 * Update a CollarCoordinate
	 * @param collarCoordinateId - The CollarCoordinateId to update
	 * @param collarCoordinate - The updated CollarCoordinate data
	 * @returns Promise<CollarCoordinate>
	 */
	async collarCoordinateControllerUpdate(collarCoordinateId: string, collarCoordinate: CollarCoordinate): Promise<CollarCoordinate> {
		if (getMode() === WorkMode.OFFLINE) {
			const numAffected = await db.DrillHole_CollarCoordinate.update(collarCoordinateId, collarCoordinate as any);
			let result;
			if (numAffected > 0) {
				result = await db.DrillHole_CollarCoordinate.get(collarCoordinateId);
			}
			if (!result) {
				throw new Error(`CollarCoordinate not found: ${collarCoordinateId}`);
			}
			return result;
		}
		return (await apiClient.collarCoordinateControllerUpdate(collarCoordinateId, collarCoordinate)).data;
	},

	/**
	 * Remove (soft delete) a CollarCoordinate
	 * Calls the API Remove endpoint which sets ActiveInd to false
	 * @param collarCoordinateId - The CollarCoordinateId to remove
	 * @param collarCoordinate - The CollarCoordinate data
	 * @returns Promise<CollarCoordinate>
	 */
	async collarCoordinateControllerRemove(collarCoordinateId: string, collarCoordinate: CollarCoordinate): Promise<CollarCoordinate> {
		if (getMode() === WorkMode.OFFLINE) {
			// In offline mode, soft delete by updating ActiveInd
			const numAffected = await db.DrillHole_CollarCoordinate.update(collarCoordinateId, { ...collarCoordinate, ActiveInd: false });
			let result;
			if (numAffected > 0) {
				result = await db.DrillHole_CollarCoordinate.get(collarCoordinateId);
			}
			if (!result) {
				throw new Error(`CollarCoordinate not found: ${collarCoordinateId}`);
			}
			return result;
		}
		// In online mode, call the API's Remove endpoint
		return (await apiClient.collarCoordinateControllerUpdate(collarCoordinateId, { ...collarCoordinate, ActiveInd: false })).data;
	},

	/**
	 * Find a single CycloneCleaning by ID
	 * @param cycloneCleaningId - The CycloneCleaningId to find
	 * @returns Promise<CycloneCleaning>
	 */
	async cycloneCleaningControllerFindOne(cycloneCleaningId: string): Promise<CycloneCleaning> {
		if (getMode() === WorkMode.OFFLINE) {
			const result = await db.DrillHole_CycloneCleaning.get(cycloneCleaningId);
			if (!result) {
				throw new Error(`CycloneCleaning not found: ${cycloneCleaningId}`);
			}
			return result;
		}
		return (await apiClient.cycloneCleaningControllerFindOne(cycloneCleaningId)).data;
	},

	/**
	 * Find all CycloneCleaning records with optional filtering
	 * @param query - Optional query parameters for filtering, pagination, etc.
	 * @returns Promise<CycloneCleaning[]>
	 */
	async cycloneCleaningControllerFindAll(query?: {
		page?: number;
		take?: number;
		order?: "ASC" | "DESC";
		search?: string;
		filters?: string | FilterInput;
		sorts?: string;
	}): Promise<CycloneCleaning[]> {
		if (getMode() === WorkMode.OFFLINE) {
			let collection = db.DrillHole_CycloneCleaning.toCollection();

			// Get results as array
			let results = await collection.toArray();

			// Apply ALL filters on array
			if (query?.filters) {
				const filters = parseFiltersForDexie(query.filters);
				if (filters.length > 0) {
					for (const filter of filters) {
						const { field, op, value } = filter;
						switch (op) {
							case 'eq':
								results = results.filter((item: any) => item[field] === value);
								break;
							case 'neq':
								results = results.filter((item: any) => item[field] !== value);
								break;
							case 'gt':
								results = results.filter((item: any) => item[field] > value);
								break;
							case 'gte':
								results = results.filter((item: any) => item[field] >= value);
								break;
							case 'lt':
								results = results.filter((item: any) => item[field] < value);
								break;
							case 'lte':
								results = results.filter((item: any) => item[field] <= value);
								break;
							case 'contains':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().includes(String(value).toLowerCase())
								);
								break;
							case 'startsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().startsWith(String(value).toLowerCase())
								);
								break;
							case 'endsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().endsWith(String(value).toLowerCase())
								);
								break;
							case 'in':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => value.includes(item[field]));
								}
								break;
							case 'notIn':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => !value.includes(item[field]));
								}
								break;
						}
					}
				}
			}

			// Apply search (on array)
			if (query?.search) {
				const searchLower = query.search.toLowerCase();
				results = results.filter((item: any) =>
					Object.values(item).some(val =>
						typeof val === 'string' && val.toLowerCase().includes(searchLower)
					)
				);
			}

			// Apply sorting
			if (query?.sorts) {
				try {
					const sortFields = JSON.parse(query.sorts);
					if (Array.isArray(sortFields) && sortFields.length > 0) {
						results.sort((a: any, b: any) => {
							for (const sort of sortFields) {
								const { field, dir } = sort;
								const aVal = a[field];
								const bVal = b[field];
								if (aVal === bVal) continue;
								const comparison = aVal < bVal ? -1 : 1;
								return dir === 'desc' ? -comparison : comparison;
							}
							return 0;
						}
						);
					}
				} catch {
					// Invalid sorts format, skip
				}
			}

			// Apply pagination
			if (query?.page && query?.take) {
				const skip = (query.page - 1) * query.take;
				results = results.slice(skip, skip + query.take);
			} else if (query?.take) {
				results = results.slice(0, query.take);
			}

			return results as CycloneCleaning[];
		}
		const response = await apiClient.cycloneCleaningControllerFindAll(query);
		return (response.data as any) || [];
	},

	/**
	 * Create a new CycloneCleaning
	 * @param cycloneCleaning - The CycloneCleaning data to create
	 * @returns Promise<CycloneCleaning>
	 */
	async cycloneCleaningControllerCreate(cycloneCleaning: CycloneCleaning): Promise<CycloneCleaning> {
		if (getMode() === WorkMode.OFFLINE) {
			await db.DrillHole_CycloneCleaning.add(cycloneCleaning);
			const result = await db.DrillHole_CycloneCleaning.get(cycloneCleaning.CycloneCleaningId);
			if (!result) {
				throw new Error(`Failed to create CycloneCleaning: ${cycloneCleaning.CycloneCleaningId}`);
			}
			return result;
		}
		return (await apiClient.cycloneCleaningControllerCreate(cycloneCleaning)).data;
	},

	/**
	 * Update a CycloneCleaning
	 * @param cycloneCleaningId - The CycloneCleaningId to update
	 * @param cycloneCleaning - The updated CycloneCleaning data
	 * @returns Promise<CycloneCleaning>
	 */
	async cycloneCleaningControllerUpdate(cycloneCleaningId: string, cycloneCleaning: CycloneCleaning): Promise<CycloneCleaning> {
		if (getMode() === WorkMode.OFFLINE) {
			const numAffected = await db.DrillHole_CycloneCleaning.update(cycloneCleaningId, cycloneCleaning as any);
			let result;
			if (numAffected > 0) {
				result = await db.DrillHole_CycloneCleaning.get(cycloneCleaningId);
			}
			if (!result) {
				throw new Error(`CycloneCleaning not found: ${cycloneCleaningId}`);
			}
			return result;
		}
		return (await apiClient.cycloneCleaningControllerUpdate(cycloneCleaningId, cycloneCleaning)).data;
	},

	/**
	 * Remove (soft delete) a CycloneCleaning
	 * Calls the API Remove endpoint which sets ActiveInd to false
	 * @param cycloneCleaningId - The CycloneCleaningId to remove
	 * @param cycloneCleaning - The CycloneCleaning data
	 * @returns Promise<CycloneCleaning>
	 */
	async cycloneCleaningControllerRemove(cycloneCleaningId: string, cycloneCleaning: CycloneCleaning): Promise<CycloneCleaning> {
		if (getMode() === WorkMode.OFFLINE) {
			// In offline mode, soft delete by updating ActiveInd
			const numAffected = await db.DrillHole_CycloneCleaning.update(cycloneCleaningId, { ...cycloneCleaning, ActiveInd: false });
			let result;
			if (numAffected > 0) {
				result = await db.DrillHole_CycloneCleaning.get(cycloneCleaningId);
			}
			if (!result) {
				throw new Error(`CycloneCleaning not found: ${cycloneCleaningId}`);
			}
			return result;
		}
		// In online mode, call the API's Remove endpoint
		return (await apiClient.cycloneCleaningControllerUpdate(cycloneCleaningId, { ...cycloneCleaning, ActiveInd: false })).data;
	},

	/**
	 * Find a single DrillMethod by ID
	 * @param drillMethodId - The DrillMethodId to find
	 * @returns Promise<DrillMethod>
	 */
	async drillMethodControllerFindOne(drillMethodId: string): Promise<DrillMethod> {
		if (getMode() === WorkMode.OFFLINE) {
			const result = await db.DrillHole_DrillMethod.get(drillMethodId);
			if (!result) {
				throw new Error(`DrillMethod not found: ${drillMethodId}`);
			}
			return result;
		}
		return (await apiClient.drillMethodControllerFindOne(drillMethodId)).data;
	},

	/**
	 * Find all DrillMethod records with optional filtering
	 * @param query - Optional query parameters for filtering, pagination, etc.
	 * @returns Promise<DrillMethod[]>
	 */
	async drillMethodControllerFindAll(query?: {
		page?: number;
		take?: number;
		order?: "ASC" | "DESC";
		search?: string;
		filters?: string | FilterInput;
		sorts?: string;
	}): Promise<DrillMethod[]> {
		if (getMode() === WorkMode.OFFLINE) {
			let collection = db.DrillHole_DrillMethod.toCollection();

			// Get results as array
			let results = await collection.toArray();

			// Apply ALL filters on array
			if (query?.filters) {
				const filters = parseFiltersForDexie(query.filters);
				if (filters.length > 0) {
					for (const filter of filters) {
						const { field, op, value } = filter;
						switch (op) {
							case 'eq':
								results = results.filter((item: any) => item[field] === value);
								break;
							case 'neq':
								results = results.filter((item: any) => item[field] !== value);
								break;
							case 'gt':
								results = results.filter((item: any) => item[field] > value);
								break;
							case 'gte':
								results = results.filter((item: any) => item[field] >= value);
								break;
							case 'lt':
								results = results.filter((item: any) => item[field] < value);
								break;
							case 'lte':
								results = results.filter((item: any) => item[field] <= value);
								break;
							case 'contains':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().includes(String(value).toLowerCase())
								);
								break;
							case 'startsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().startsWith(String(value).toLowerCase())
								);
								break;
							case 'endsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().endsWith(String(value).toLowerCase())
								);
								break;
							case 'in':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => value.includes(item[field]));
								}
								break;
							case 'notIn':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => !value.includes(item[field]));
								}
								break;
						}
					}
				}
			}

			// Apply search (on array)
			if (query?.search) {
				const searchLower = query.search.toLowerCase();
				results = results.filter((item: any) =>
					Object.values(item).some(val =>
						typeof val === 'string' && val.toLowerCase().includes(searchLower)
					)
				);
			}

			// Apply sorting
			if (query?.sorts) {
				try {
					const sortFields = JSON.parse(query.sorts);
					if (Array.isArray(sortFields) && sortFields.length > 0) {
						results.sort((a: any, b: any) => {
							for (const sort of sortFields) {
								const { field, dir } = sort;
								const aVal = a[field];
								const bVal = b[field];
								if (aVal === bVal) continue;
								const comparison = aVal < bVal ? -1 : 1;
								return dir === 'desc' ? -comparison : comparison;
							}
							return 0;
						}
						);
					}
				} catch {
					// Invalid sorts format, skip
				}
			}

			// Apply pagination
			if (query?.page && query?.take) {
				const skip = (query.page - 1) * query.take;
				results = results.slice(skip, skip + query.take);
			} else if (query?.take) {
				results = results.slice(0, query.take);
			}

			return results as DrillMethod[];
		}
		const response = await apiClient.drillMethodControllerFindAll(query);
		return (response.data as any) || [];
	},

	/**
	 * Create a new DrillMethod
	 * @param drillMethod - The DrillMethod data to create
	 * @returns Promise<DrillMethod>
	 */
	async drillMethodControllerCreate(drillMethod: DrillMethod): Promise<DrillMethod> {
		if (getMode() === WorkMode.OFFLINE) {
			await db.DrillHole_DrillMethod.add(drillMethod);
			const result = await db.DrillHole_DrillMethod.get(drillMethod.DrillMethodId);
			if (!result) {
				throw new Error(`Failed to create DrillMethod: ${drillMethod.DrillMethodId}`);
			}
			return result;
		}
		return (await apiClient.drillMethodControllerCreate(drillMethod)).data;
	},

	/**
	 * Update a DrillMethod
	 * @param drillMethodId - The DrillMethodId to update
	 * @param drillMethod - The updated DrillMethod data
	 * @returns Promise<DrillMethod>
	 */
	async drillMethodControllerUpdate(drillMethodId: string, drillMethod: DrillMethod): Promise<DrillMethod> {
		if (getMode() === WorkMode.OFFLINE) {
			const numAffected = await db.DrillHole_DrillMethod.update(drillMethodId, drillMethod as any);
			let result;
			if (numAffected > 0) {
				result = await db.DrillHole_DrillMethod.get(drillMethodId);
			}
			if (!result) {
				throw new Error(`DrillMethod not found: ${drillMethodId}`);
			}
			return result;
		}
		return (await apiClient.drillMethodControllerUpdate(drillMethodId, drillMethod)).data;
	},

	/**
	 * Remove (soft delete) a DrillMethod
	 * Calls the API Remove endpoint which sets ActiveInd to false
	 * @param drillMethodId - The DrillMethodId to remove
	 * @param drillMethod - The DrillMethod data
	 * @returns Promise<DrillMethod>
	 */
	async drillMethodControllerRemove(drillMethodId: string, drillMethod: DrillMethod): Promise<DrillMethod> {
		if (getMode() === WorkMode.OFFLINE) {
			// In offline mode, soft delete by updating ActiveInd
			const numAffected = await db.DrillHole_DrillMethod.update(drillMethodId, { ...drillMethod, ActiveInd: false });
			let result;
			if (numAffected > 0) {
				result = await db.DrillHole_DrillMethod.get(drillMethodId);
			}
			if (!result) {
				throw new Error(`DrillMethod not found: ${drillMethodId}`);
			}
			return result;
		}
		// In online mode, call the API's Remove endpoint
		return (await apiClient.drillMethodControllerUpdate(drillMethodId, { ...drillMethod, ActiveInd: false })).data;
	},

	/**
	 * Find a single Hole by ID
	 * @param holeId - The HoleId to find
	 * @returns Promise<Hole>
	 */
	async holeControllerFindOne(holeId: string): Promise<Hole> {
		if (getMode() === WorkMode.OFFLINE) {
			const result = await db.DrillHole_Hole.get(holeId);
			if (!result) {
				throw new Error(`Hole not found: ${holeId}`);
			}
			return result;
		}
		return (await apiClient.holeControllerFindOne(holeId)).data;
	},

	/**
	 * Find all Hole records with optional filtering
	 * @param query - Optional query parameters for filtering, pagination, etc.
	 * @returns Promise<Hole[]>
	 */
	async holeControllerFindAll(query?: {
		page?: number;
		take?: number;
		order?: "ASC" | "DESC";
		search?: string;
		filters?: string | FilterInput;
		sorts?: string;
	}): Promise<Hole[]> {
		if (getMode() === WorkMode.OFFLINE) {
			let collection = db.DrillHole_Hole.toCollection();

			// Get results as array
			let results = await collection.toArray();

			// Apply ALL filters on array
			if (query?.filters) {
				const filters = parseFiltersForDexie(query.filters);
				if (filters.length > 0) {
					for (const filter of filters) {
						const { field, op, value } = filter;
						switch (op) {
							case 'eq':
								results = results.filter((item: any) => item[field] === value);
								break;
							case 'neq':
								results = results.filter((item: any) => item[field] !== value);
								break;
							case 'gt':
								results = results.filter((item: any) => item[field] > value);
								break;
							case 'gte':
								results = results.filter((item: any) => item[field] >= value);
								break;
							case 'lt':
								results = results.filter((item: any) => item[field] < value);
								break;
							case 'lte':
								results = results.filter((item: any) => item[field] <= value);
								break;
							case 'contains':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().includes(String(value).toLowerCase())
								);
								break;
							case 'startsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().startsWith(String(value).toLowerCase())
								);
								break;
							case 'endsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().endsWith(String(value).toLowerCase())
								);
								break;
							case 'in':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => value.includes(item[field]));
								}
								break;
							case 'notIn':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => !value.includes(item[field]));
								}
								break;
						}
					}
				}
			}

			// Apply search (on array)
			if (query?.search) {
				const searchLower = query.search.toLowerCase();
				results = results.filter((item: any) =>
					Object.values(item).some(val =>
						typeof val === 'string' && val.toLowerCase().includes(searchLower)
					)
				);
			}

			// Apply sorting
			if (query?.sorts) {
				try {
					const sortFields = JSON.parse(query.sorts);
					if (Array.isArray(sortFields) && sortFields.length > 0) {
						results.sort((a: any, b: any) => {
							for (const sort of sortFields) {
								const { field, dir } = sort;
								const aVal = a[field];
								const bVal = b[field];
								if (aVal === bVal) continue;
								const comparison = aVal < bVal ? -1 : 1;
								return dir === 'desc' ? -comparison : comparison;
							}
							return 0;
						}
						);
					}
				} catch {
					// Invalid sorts format, skip
				}
			}

			// Apply pagination
			if (query?.page && query?.take) {
				const skip = (query.page - 1) * query.take;
				results = results.slice(skip, skip + query.take);
			} else if (query?.take) {
				results = results.slice(0, query.take);
			}

			return results as Hole[];
		}
		const response = await apiClient.holeControllerFindAll(query);
		return (response.data as any) || [];
	},

	/**
	 * Create a new Hole
	 * @param hole - The Hole data to create
	 * @returns Promise<Hole>
	 */
	async holeControllerCreate(hole: Hole): Promise<Hole> {
		if (getMode() === WorkMode.OFFLINE) {
			await db.DrillHole_Hole.add(hole);
			const result = await db.DrillHole_Hole.get(hole.HoleId);
			if (!result) {
				throw new Error(`Failed to create Hole: ${hole.HoleId}`);
			}
			return result;
		}
		return (await apiClient.holeControllerCreate(hole)).data;
	},

	/**
	 * Update a Hole
	 * @param holeId - The HoleId to update
	 * @param hole - The updated Hole data
	 * @returns Promise<Hole>
	 */
	async holeControllerUpdate(holeId: string, hole: Hole): Promise<Hole> {
		if (getMode() === WorkMode.OFFLINE) {
			const numAffected = await db.DrillHole_Hole.update(holeId, hole as any);
			let result;
			if (numAffected > 0) {
				result = await db.DrillHole_Hole.get(holeId);
			}
			if (!result) {
				throw new Error(`Hole not found: ${holeId}`);
			}
			return result;
		}
		return (await apiClient.holeControllerUpdate(holeId, hole)).data;
	},

	/**
	 * Remove (soft delete) a Hole
	 * Calls the API Remove endpoint which sets ActiveInd to false
	 * @param holeId - The HoleId to remove
	 * @param hole - The Hole data
	 * @returns Promise<Hole>
	 */
	async holeControllerRemove(holeId: string, hole: Hole): Promise<Hole> {
		if (getMode() === WorkMode.OFFLINE) {
			// In offline mode, soft delete by updating ActiveInd
			const numAffected = await db.DrillHole_Hole.update(holeId, { ...hole, ActiveInd: false });
			let result;
			if (numAffected > 0) {
				result = await db.DrillHole_Hole.get(holeId);
			}
			if (!result) {
				throw new Error(`Hole not found: ${holeId}`);
			}
			return result;
		}
		// In online mode, call the API's Remove endpoint
		return (await apiClient.holeControllerUpdate(holeId, { ...hole, ActiveInd: false })).data;
	},

	/**
	 * Find a single HoleName by ID
	 * @param holeNameId - The HoleNameId to find
	 * @returns Promise<HoleName>
	 */
	async holeNameControllerFindOne(holeNameId: string): Promise<HoleName> {
		if (getMode() === WorkMode.OFFLINE) {
			const result = await db.DrillHole_HoleName.get(holeNameId);
			if (!result) {
				throw new Error(`HoleName not found: ${holeNameId}`);
			}
			return result;
		}
		return (await apiClient.holeNameControllerFindOne(holeNameId)).data;
	},

	/**
	 * Find all HoleName records with optional filtering
	 * @param query - Optional query parameters for filtering, pagination, etc.
	 * @returns Promise<HoleName[]>
	 */
	async holeNameControllerFindAll(query?: {
		page?: number;
		take?: number;
		order?: "ASC" | "DESC";
		search?: string;
		filters?: string | FilterInput;
		sorts?: string;
	}): Promise<HoleName[]> {
		if (getMode() === WorkMode.OFFLINE) {
			let collection = db.DrillHole_HoleName.toCollection();

			// Get results as array
			let results = await collection.toArray();

			// Apply ALL filters on array
			if (query?.filters) {
				const filters = parseFiltersForDexie(query.filters);
				if (filters.length > 0) {
					for (const filter of filters) {
						const { field, op, value } = filter;
						switch (op) {
							case 'eq':
								results = results.filter((item: any) => item[field] === value);
								break;
							case 'neq':
								results = results.filter((item: any) => item[field] !== value);
								break;
							case 'gt':
								results = results.filter((item: any) => item[field] > value);
								break;
							case 'gte':
								results = results.filter((item: any) => item[field] >= value);
								break;
							case 'lt':
								results = results.filter((item: any) => item[field] < value);
								break;
							case 'lte':
								results = results.filter((item: any) => item[field] <= value);
								break;
							case 'contains':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().includes(String(value).toLowerCase())
								);
								break;
							case 'startsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().startsWith(String(value).toLowerCase())
								);
								break;
							case 'endsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().endsWith(String(value).toLowerCase())
								);
								break;
							case 'in':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => value.includes(item[field]));
								}
								break;
							case 'notIn':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => !value.includes(item[field]));
								}
								break;
						}
					}
				}
			}

			// Apply search (on array)
			if (query?.search) {
				const searchLower = query.search.toLowerCase();
				results = results.filter((item: any) =>
					Object.values(item).some(val =>
						typeof val === 'string' && val.toLowerCase().includes(searchLower)
					)
				);
			}

			// Apply sorting
			if (query?.sorts) {
				try {
					const sortFields = JSON.parse(query.sorts);
					if (Array.isArray(sortFields) && sortFields.length > 0) {
						results.sort((a: any, b: any) => {
							for (const sort of sortFields) {
								const { field, dir } = sort;
								const aVal = a[field];
								const bVal = b[field];
								if (aVal === bVal) continue;
								const comparison = aVal < bVal ? -1 : 1;
								return dir === 'desc' ? -comparison : comparison;
							}
							return 0;
						}
						);
					}
				} catch {
					// Invalid sorts format, skip
				}
			}

			// Apply pagination
			if (query?.page && query?.take) {
				const skip = (query.page - 1) * query.take;
				results = results.slice(skip, skip + query.take);
			} else if (query?.take) {
				results = results.slice(0, query.take);
			}

			return results as HoleName[];
		}
		const response = await apiClient.holeNameControllerFindAll(query);
		return (response.data as any) || [];
	},

	/**
	 * Create a new HoleName
	 * @param holeName - The HoleName data to create
	 * @returns Promise<HoleName>
	 */
	async holeNameControllerCreate(holeName: HoleName): Promise<HoleName> {
		if (getMode() === WorkMode.OFFLINE) {
			await db.DrillHole_HoleName.add(holeName);
			const result = await db.DrillHole_HoleName.get(holeName.HoleNameId);
			if (!result) {
				throw new Error(`Failed to create HoleName: ${holeName.HoleNameId}`);
			}
			return result;
		}
		return (await apiClient.holeNameControllerCreate(holeName)).data;
	},

	/**
	 * Update a HoleName
	 * @param holeNameId - The HoleNameId to update
	 * @param holeName - The updated HoleName data
	 * @returns Promise<HoleName>
	 */
	async holeNameControllerUpdate(holeNameId: string, holeName: HoleName): Promise<HoleName> {
		if (getMode() === WorkMode.OFFLINE) {
			const numAffected = await db.DrillHole_HoleName.update(holeNameId, holeName as any);
			let result;
			if (numAffected > 0) {
				result = await db.DrillHole_HoleName.get(holeNameId);
			}
			if (!result) {
				throw new Error(`HoleName not found: ${holeNameId}`);
			}
			return result;
		}
		return (await apiClient.holeNameControllerUpdate(holeNameId, holeName)).data;
	},

	/**
	 * Remove (soft delete) a HoleName
	 * Calls the API Remove endpoint which sets ActiveInd to false
	 * @param holeNameId - The HoleNameId to remove
	 * @param holeName - The HoleName data
	 * @returns Promise<HoleName>
	 */
	async holeNameControllerRemove(holeNameId: string, holeName: HoleName): Promise<HoleName> {
		if (getMode() === WorkMode.OFFLINE) {
			// In offline mode, soft delete by updating ActiveInd
			const numAffected = await db.DrillHole_HoleName.update(holeNameId, { ...holeName, ActiveInd: false });
			let result;
			if (numAffected > 0) {
				result = await db.DrillHole_HoleName.get(holeNameId);
			}
			if (!result) {
				throw new Error(`HoleName not found: ${holeNameId}`);
			}
			return result;
		}
		// In online mode, call the API's Remove endpoint
		return (await apiClient.holeNameControllerUpdate(holeNameId, { ...holeName, ActiveInd: false })).data;
	},

	/**
	 * Find a single LoggingEvent by ID
	 * @param loggingEventId - The LoggingEventId to find
	 * @returns Promise<LoggingEvent>
	 */
	async loggingEventControllerFindOne(loggingEventId: string): Promise<LoggingEvent> {
		if (getMode() === WorkMode.OFFLINE) {
			const result = await db.DrillHole_LoggingEvent.get(loggingEventId);
			if (!result) {
				throw new Error(`LoggingEvent not found: ${loggingEventId}`);
			}
			return result;
		}
		return (await apiClient.loggingEventControllerFindOne(loggingEventId)).data;
	},

	/**
	 * Find all LoggingEvent records with optional filtering
	 * @param query - Optional query parameters for filtering, pagination, etc.
	 * @returns Promise<LoggingEvent[]>
	 */
	async loggingEventControllerFindAll(query?: {
		page?: number;
		take?: number;
		order?: "ASC" | "DESC";
		search?: string;
		filters?: string | FilterInput;
		sorts?: string;
	}): Promise<LoggingEvent[]> {
		if (getMode() === WorkMode.OFFLINE) {
			let collection = db.DrillHole_LoggingEvent.toCollection();

			// Get results as array
			let results = await collection.toArray();

			// Apply ALL filters on array
			if (query?.filters) {
				const filters = parseFiltersForDexie(query.filters);
				if (filters.length > 0) {
					for (const filter of filters) {
						const { field, op, value } = filter;
						switch (op) {
							case 'eq':
								results = results.filter((item: any) => item[field] === value);
								break;
							case 'neq':
								results = results.filter((item: any) => item[field] !== value);
								break;
							case 'gt':
								results = results.filter((item: any) => item[field] > value);
								break;
							case 'gte':
								results = results.filter((item: any) => item[field] >= value);
								break;
							case 'lt':
								results = results.filter((item: any) => item[field] < value);
								break;
							case 'lte':
								results = results.filter((item: any) => item[field] <= value);
								break;
							case 'contains':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().includes(String(value).toLowerCase())
								);
								break;
							case 'startsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().startsWith(String(value).toLowerCase())
								);
								break;
							case 'endsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().endsWith(String(value).toLowerCase())
								);
								break;
							case 'in':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => value.includes(item[field]));
								}
								break;
							case 'notIn':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => !value.includes(item[field]));
								}
								break;
						}
					}
				}
			}

			// Apply search (on array)
			if (query?.search) {
				const searchLower = query.search.toLowerCase();
				results = results.filter((item: any) =>
					Object.values(item).some(val =>
						typeof val === 'string' && val.toLowerCase().includes(searchLower)
					)
				);
			}

			// Apply sorting
			if (query?.sorts) {
				try {
					const sortFields = JSON.parse(query.sorts);
					if (Array.isArray(sortFields) && sortFields.length > 0) {
						results.sort((a: any, b: any) => {
							for (const sort of sortFields) {
								const { field, dir } = sort;
								const aVal = a[field];
								const bVal = b[field];
								if (aVal === bVal) continue;
								const comparison = aVal < bVal ? -1 : 1;
								return dir === 'desc' ? -comparison : comparison;
							}
							return 0;
						}
						);
					}
				} catch {
					// Invalid sorts format, skip
				}
			}

			// Apply pagination
			if (query?.page && query?.take) {
				const skip = (query.page - 1) * query.take;
				results = results.slice(skip, skip + query.take);
			} else if (query?.take) {
				results = results.slice(0, query.take);
			}

			return results as LoggingEvent[];
		}
		const response = await apiClient.loggingEventControllerFindAll(query);
		return (response.data as any) || [];
	},

	/**
	 * Create a new LoggingEvent
	 * @param loggingEvent - The LoggingEvent data to create
	 * @returns Promise<LoggingEvent>
	 */
	async loggingEventControllerCreate(loggingEvent: LoggingEvent): Promise<LoggingEvent> {
		if (getMode() === WorkMode.OFFLINE) {
			await db.DrillHole_LoggingEvent.add(loggingEvent);
			const result = await db.DrillHole_LoggingEvent.get(loggingEvent.LoggingEventId);
			if (!result) {
				throw new Error(`Failed to create LoggingEvent: ${loggingEvent.LoggingEventId}`);
			}
			return result;
		}
		return (await apiClient.loggingEventControllerCreate(loggingEvent)).data;
	},

	/**
	 * Update a LoggingEvent
	 * @param loggingEventId - The LoggingEventId to update
	 * @param loggingEvent - The updated LoggingEvent data
	 * @returns Promise<LoggingEvent>
	 */
	async loggingEventControllerUpdate(loggingEventId: string, loggingEvent: LoggingEvent): Promise<LoggingEvent> {
		if (getMode() === WorkMode.OFFLINE) {
			const numAffected = await db.DrillHole_LoggingEvent.update(loggingEventId, loggingEvent as any);
			let result;
			if (numAffected > 0) {
				result = await db.DrillHole_LoggingEvent.get(loggingEventId);
			}
			if (!result) {
				throw new Error(`LoggingEvent not found: ${loggingEventId}`);
			}
			return result;
		}
		return (await apiClient.loggingEventControllerUpdate(loggingEventId, loggingEvent)).data;
	},

	/**
	 * Remove (soft delete) a LoggingEvent
	 * Calls the API Remove endpoint which sets ActiveInd to false
	 * @param loggingEventId - The LoggingEventId to remove
	 * @param loggingEvent - The LoggingEvent data
	 * @returns Promise<LoggingEvent>
	 */
	async loggingEventControllerRemove(loggingEventId: string, loggingEvent: LoggingEvent): Promise<LoggingEvent> {
		if (getMode() === WorkMode.OFFLINE) {
			// In offline mode, soft delete by updating ActiveInd
			const numAffected = await db.DrillHole_LoggingEvent.update(loggingEventId, { ...loggingEvent, ActiveInd: false });
			let result;
			if (numAffected > 0) {
				result = await db.DrillHole_LoggingEvent.get(loggingEventId);
			}
			if (!result) {
				throw new Error(`LoggingEvent not found: ${loggingEventId}`);
			}
			return result;
		}
		// In online mode, call the API's Remove endpoint
		return (await apiClient.loggingEventControllerUpdate(loggingEventId, { ...loggingEvent, ActiveInd: false })).data;
	},

	/**
	 * Find a single MetaDataLog by ID
	 * @param metaDataLogId - The MetaDataLogId to find
	 * @returns Promise<MetaDataLog>
	 */
	async metaDataLogControllerFindOne(metaDataLogId: string): Promise<MetaDataLog> {
		if (getMode() === WorkMode.OFFLINE) {
			const result = await db.DrillHole_MetaDataLog.get(metaDataLogId);
			if (!result) {
				throw new Error(`MetaDataLog not found: ${metaDataLogId}`);
			}
			return result;
		}
		return (await apiClient.metaDataLogControllerFindOne(metaDataLogId)).data;
	},

	/**
	 * Find all MetaDataLog records with optional filtering
	 * @param query - Optional query parameters for filtering, pagination, etc.
	 * @returns Promise<MetaDataLog[]>
	 */
	async metaDataLogControllerFindAll(query?: {
		page?: number;
		take?: number;
		order?: "ASC" | "DESC";
		search?: string;
		filters?: string | FilterInput;
		sorts?: string;
	}): Promise<MetaDataLog[]> {
		if (getMode() === WorkMode.OFFLINE) {
			let collection = db.DrillHole_MetaDataLog.toCollection();

			// Get results as array
			let results = await collection.toArray();

			// Apply ALL filters on array
			if (query?.filters) {
				const filters = parseFiltersForDexie(query.filters);
				if (filters.length > 0) {
					for (const filter of filters) {
						const { field, op, value } = filter;
						switch (op) {
							case 'eq':
								results = results.filter((item: any) => item[field] === value);
								break;
							case 'neq':
								results = results.filter((item: any) => item[field] !== value);
								break;
							case 'gt':
								results = results.filter((item: any) => item[field] > value);
								break;
							case 'gte':
								results = results.filter((item: any) => item[field] >= value);
								break;
							case 'lt':
								results = results.filter((item: any) => item[field] < value);
								break;
							case 'lte':
								results = results.filter((item: any) => item[field] <= value);
								break;
							case 'contains':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().includes(String(value).toLowerCase())
								);
								break;
							case 'startsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().startsWith(String(value).toLowerCase())
								);
								break;
							case 'endsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().endsWith(String(value).toLowerCase())
								);
								break;
							case 'in':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => value.includes(item[field]));
								}
								break;
							case 'notIn':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => !value.includes(item[field]));
								}
								break;
						}
					}
				}
			}

			// Apply search (on array)
			if (query?.search) {
				const searchLower = query.search.toLowerCase();
				results = results.filter((item: any) =>
					Object.values(item).some(val =>
						typeof val === 'string' && val.toLowerCase().includes(searchLower)
					)
				);
			}

			// Apply sorting
			if (query?.sorts) {
				try {
					const sortFields = JSON.parse(query.sorts);
					if (Array.isArray(sortFields) && sortFields.length > 0) {
						results.sort((a: any, b: any) => {
							for (const sort of sortFields) {
								const { field, dir } = sort;
								const aVal = a[field];
								const bVal = b[field];
								if (aVal === bVal) continue;
								const comparison = aVal < bVal ? -1 : 1;
								return dir === 'desc' ? -comparison : comparison;
							}
							return 0;
						}
						);
					}
				} catch {
					// Invalid sorts format, skip
				}
			}

			// Apply pagination
			if (query?.page && query?.take) {
				const skip = (query.page - 1) * query.take;
				results = results.slice(skip, skip + query.take);
			} else if (query?.take) {
				results = results.slice(0, query.take);
			}

			return results as MetaDataLog[];
		}
		const response = await apiClient.metaDataLogControllerFindAll(query);
		return (response.data as any) || [];
	},

	/**
	 * Create a new MetaDataLog
	 * @param metaDataLog - The MetaDataLog data to create
	 * @returns Promise<MetaDataLog>
	 */
	async metaDataLogControllerCreate(metaDataLog: MetaDataLog): Promise<MetaDataLog> {
		if (getMode() === WorkMode.OFFLINE) {
			await db.DrillHole_MetaDataLog.add(metaDataLog);
			const result = await db.DrillHole_MetaDataLog.get(metaDataLog.MetaDataLogId);
			if (!result) {
				throw new Error(`Failed to create MetaDataLog: ${metaDataLog.MetaDataLogId}`);
			}
			return result;
		}
		return (await apiClient.metaDataLogControllerCreate(metaDataLog)).data;
	},

	/**
	 * Update a MetaDataLog
	 * @param metaDataLogId - The MetaDataLogId to update
	 * @param metaDataLog - The updated MetaDataLog data
	 * @returns Promise<MetaDataLog>
	 */
	async metaDataLogControllerUpdate(metaDataLogId: string, metaDataLog: MetaDataLog): Promise<MetaDataLog> {
		if (getMode() === WorkMode.OFFLINE) {
			const numAffected = await db.DrillHole_MetaDataLog.update(metaDataLogId, metaDataLog as any);
			let result;
			if (numAffected > 0) {
				result = await db.DrillHole_MetaDataLog.get(metaDataLogId);
			}
			if (!result) {
				throw new Error(`MetaDataLog not found: ${metaDataLogId}`);
			}
			return result;
		}
		return (await apiClient.metaDataLogControllerUpdate(metaDataLogId, metaDataLog)).data;
	},

	/**
	 * Remove (soft delete) a MetaDataLog
	 * Calls the API Remove endpoint which sets ActiveInd to false
	 * @param metaDataLogId - The MetaDataLogId to remove
	 * @param metaDataLog - The MetaDataLog data
	 * @returns Promise<MetaDataLog>
	 */
	async metaDataLogControllerRemove(metaDataLogId: string, metaDataLog: MetaDataLog): Promise<MetaDataLog> {
		if (getMode() === WorkMode.OFFLINE) {
			// In offline mode, soft delete by updating ActiveInd
			const numAffected = await db.DrillHole_MetaDataLog.update(metaDataLogId, { ...metaDataLog, ActiveInd: false });
			let result;
			if (numAffected > 0) {
				result = await db.DrillHole_MetaDataLog.get(metaDataLogId);
			}
			if (!result) {
				throw new Error(`MetaDataLog not found: ${metaDataLogId}`);
			}
			return result;
		}
		// In online mode, call the API's Remove endpoint
		return (await apiClient.metaDataLogControllerUpdate(metaDataLogId, { ...metaDataLog, ActiveInd: false })).data;
	},

	/**
	 * Find a single RigSetup by ID
	 * @param rigSetupId - The RigSetupId to find
	 * @returns Promise<RigSetup>
	 */
	async rigSetupControllerFindOne(rigSetupId: string): Promise<RigSetup> {
		if (getMode() === WorkMode.OFFLINE) {
			const result = await db.DrillHole_RigSetup.get(rigSetupId);
			if (!result) {
				throw new Error(`RigSetup not found: ${rigSetupId}`);
			}
			return result;
		}
		return (await apiClient.rigSetupControllerFindOne(rigSetupId)).data;
	},

	/**
	 * Find all RigSetup records with optional filtering
	 * @param query - Optional query parameters for filtering, pagination, etc.
	 * @returns Promise<RigSetup[]>
	 */
	// async rigSetupControllerFindAll(query?: {
	// 	page?: number;
	// 	take?: number;
	// 	order?: "ASC" | "DESC";
	// 	search?: string;
	// 	filters?: string | FilterInput;
	// 	sorts?: string;
	// }): Promise<PageDto> {

	// 	if (getMode() === WorkMode.OFFLINE) {

	// 		const page = query?.page ?? 1;
	// 		const take = query?.take ?? 25;
	// 		const skip = (page - 1) * take;

	// 		let collection: Dexie.Collection<any, any> =
	// 			db.DrillHole_RigSetup.toCollection();

	// 		// ‚ö†Ô∏è If filtering by indexed field, use where() instead of filtering later
	// 		// Otherwise fallback to JS filtering

	// 		let results = await collection.toArray();

	// 		// ---- FILTERING (same as you have now) ----
	// 		if (query?.filters) {
	// 			const filters = parseFiltersForDexie(query.filters);
	// 			for (const filter of filters) {
	// 				const { field, op, value } = filter;

	// 				switch (op) {
	// 					case 'eq':
	// 						results = results.filter(r => r[field] === value);
	// 						break;
	// 					// keep your other cases
	// 				}
	// 			}
	// 		}

	// 		// ---- SEARCH ----
	// 		if (query?.search) {
	// 			const searchLower = query.search.toLowerCase();
	// 			results = results.filter(item =>
	// 				Object.values(item).some(val =>
	// 					typeof val === 'string' &&
	// 					val.toLowerCase().includes(searchLower)
	// 				)
	// 			);
	// 		}

	// 		const totalCount = results.length;

	// 		// ---- SORT ----
	// 		if (query?.sorts) {
	// 			const sortFields = JSON.parse(query.sorts);

	// 			results.sort((a, b) => {
	// 				for (const sort of sortFields) {
	// 					const { field, dir } = sort;
	// 					if (a[field] === b[field]) continue;
	// 					const comparison = a[field] < b[field] ? -1 : 1;
	// 					return dir === 'desc' ? -comparison : comparison;
	// 				}
	// 				return 0;
	// 			});
	// 		}

	// 		// ---- PAGE ----
	// 		const paged = results.slice(skip, skip + take);

	// 		const pageCount = Math.ceil(totalCount / take);

	// 		return {
	// 			data: paged,
	// 			meta: {
	// 				page,
	// 				take,
	// 				itemCount: totalCount,
	// 				pageCount,
	// 				hasPreviousPage: page > 1,
	// 				hasNextPage: page < pageCount
	// 			}
	// 		};
	// 	}

	// 	return await apiClient.rigSetupControllerFindAll(query);
	// },

	async rigSetupControllerFindAll(query?: {
		page?: number;
		take?: number;
		order?: "ASC" | "DESC";
		search?: string;
		filters?: string | FilterInput;
		sorts?: string;
	}): Promise<RigSetup[]> {
		if (getMode() === WorkMode.OFFLINE) {
			let collection = db.DrillHole_RigSetup.toCollection();

			// Get results as array
			let results = await collection.toArray();

			// Apply ALL filters on array
			if (query?.filters) {
				const filters = parseFiltersForDexie(query.filters);
				if (filters.length > 0) {
					for (const filter of filters) {
						const { field, op, value } = filter;
						switch (op) {
							case 'eq':
								results = results.filter((item: any) => item[field] === value);
								break;
							case 'neq':
								results = results.filter((item: any) => item[field] !== value);
								break;
							case 'gt':
								results = results.filter((item: any) => item[field] > value);
								break;
							case 'gte':
								results = results.filter((item: any) => item[field] >= value);
								break;
							case 'lt':
								results = results.filter((item: any) => item[field] < value);
								break;
							case 'lte':
								results = results.filter((item: any) => item[field] <= value);
								break;
							case 'contains':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().includes(String(value).toLowerCase())
								);
								break;
							case 'startsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().startsWith(String(value).toLowerCase())
								);
								break;
							case 'endsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().endsWith(String(value).toLowerCase())
								);
								break;
							case 'in':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => value.includes(item[field]));
								}
								break;
							case 'notIn':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => !value.includes(item[field]));
								}
								break;
						}
					}
				}
			}

			// Apply search (on array)
			if (query?.search) {
				const searchLower = query.search.toLowerCase();
				results = results.filter((item: any) =>
					Object.values(item).some(val =>
						typeof val === 'string' && val.toLowerCase().includes(searchLower)
					)
				);
			}

			// Apply sorting
			if (query?.sorts) {
				try {
					const sortFields = JSON.parse(query.sorts);
					if (Array.isArray(sortFields) && sortFields.length > 0) {
						results.sort((a: any, b: any) => {
							for (const sort of sortFields) {
								const { field, dir } = sort;
								const aVal = a[field];
								const bVal = b[field];
								if (aVal === bVal) continue;
								const comparison = aVal < bVal ? -1 : 1;
								return dir === 'desc' ? -comparison : comparison;
							}
							return 0;
						}
						);
					}
				} catch {
					// Invalid sorts format, skip
				}
			}
			query.take = query?.take || 100000
			// Apply pagination
			if (query?.page && query?.take) {
				const skip = (query.page - 1) * query.take;
				results = results.slice(skip, skip + query.take);
			} else if (query?.take) {
				results = results.slice(0, query.take);
			}

			return results as RigSetup[];
		}
		const response = (await apiClient.rigSetupControllerFindAll(query))?.data?.data ?? [];
		return response
	},

	/**
	 * Create a new RigSetup
	 * @param rigSetup - The RigSetup data to create
	 * @returns Promise<RigSetup>
	 */
	async rigSetupControllerCreate(rigSetup: RigSetup): Promise<RigSetup> {
		if (getMode() === WorkMode.OFFLINE) {
			await db.DrillHole_RigSetup.add(rigSetup);
			const result = await db.DrillHole_RigSetup.get(rigSetup.RigSetupId);
			if (!result) {
				throw new Error(`Failed to create RigSetup: ${rigSetup.RigSetupId}`);
			}
			return result;
		}
		return (await apiClient.rigSetupControllerCreate(rigSetup)).data;
	},

	/**
	 * Update a RigSetup
	 * @param rigSetupId - The RigSetupId to update
	 * @param rigSetup - The updated RigSetup data
	 * @returns Promise<RigSetup>
	 */
	async rigSetupControllerUpdate(rigSetupId: string, rigSetup: RigSetup): Promise<RigSetup> {
		if (getMode() === WorkMode.OFFLINE) {
			const numAffected = await db.DrillHole_RigSetup.update(rigSetupId, rigSetup as any);
			let result;
			if (numAffected > 0) {
				result = await db.DrillHole_RigSetup.get(rigSetupId);
			}
			if (!result) {
				throw new Error(`RigSetup not found: ${rigSetupId}`);
			}
			return result;
		}
		return (await apiClient.rigSetupControllerUpdate(rigSetupId, rigSetup)).data;
	},

	/**
	 * Remove (soft delete) a RigSetup
	 * Calls the API Remove endpoint which sets ActiveInd to false
	 * @param rigSetupId - The RigSetupId to remove
	 * @param rigSetup - The RigSetup data
	 * @returns Promise<RigSetup>
	 */
	async rigSetupControllerRemove(rigSetupId: string, rigSetup: RigSetup): Promise<RigSetup> {
		if (getMode() === WorkMode.OFFLINE) {
			// In offline mode, soft delete by updating ActiveInd
			const numAffected = await db.DrillHole_RigSetup.update(rigSetupId, { ...rigSetup, ActiveInd: false });
			let result;
			if (numAffected > 0) {
				result = await db.DrillHole_RigSetup.get(rigSetupId);
			}
			if (!result) {
				throw new Error(`RigSetup not found: ${rigSetupId}`);
			}
			return result;
		}
		// In online mode, call the API's Remove endpoint
		return (await apiClient.rigSetupControllerUpdate(rigSetupId, { ...rigSetup, ActiveInd: false })).data;
	},

	/**
	 * Find a single Survey by ID
	 * @param surveyId - The SurveyId to find
	 * @returns Promise<Survey>
	 */
	async surveyControllerFindOne(surveyId: string): Promise<Survey> {
		if (getMode() === WorkMode.OFFLINE) {
			const result = await db.DrillHole_Survey.get(surveyId);
			if (!result) {
				throw new Error(`Survey not found: ${surveyId}`);
			}
			return result;
		}
		return (await apiClient.surveyControllerFindOne(surveyId)).data;
	},

	/**
	 * Find all Survey records with optional filtering
	 * @param query - Optional query parameters for filtering, pagination, etc.
	 * @returns Promise<Survey[]>
	 */
	async surveyControllerFindAll(query?: {
		page?: number;
		take?: number;
		order?: "ASC" | "DESC";
		search?: string;
		filters?: string | FilterInput;
		sorts?: string;
	}): Promise<Survey[]> {
		if (getMode() === WorkMode.OFFLINE) {
			let collection = db.DrillHole_Survey.toCollection();

			// Get results as array
			let results = await collection.toArray();

			// Apply ALL filters on array
			if (query?.filters) {
				const filters = parseFiltersForDexie(query.filters);
				if (filters.length > 0) {
					for (const filter of filters) {
						const { field, op, value } = filter;
						switch (op) {
							case 'eq':
								results = results.filter((item: any) => item[field] === value);
								break;
							case 'neq':
								results = results.filter((item: any) => item[field] !== value);
								break;
							case 'gt':
								results = results.filter((item: any) => item[field] > value);
								break;
							case 'gte':
								results = results.filter((item: any) => item[field] >= value);
								break;
							case 'lt':
								results = results.filter((item: any) => item[field] < value);
								break;
							case 'lte':
								results = results.filter((item: any) => item[field] <= value);
								break;
							case 'contains':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().includes(String(value).toLowerCase())
								);
								break;
							case 'startsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().startsWith(String(value).toLowerCase())
								);
								break;
							case 'endsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().endsWith(String(value).toLowerCase())
								);
								break;
							case 'in':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => value.includes(item[field]));
								}
								break;
							case 'notIn':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => !value.includes(item[field]));
								}
								break;
						}
					}
				}
			}

			// Apply search (on array)
			if (query?.search) {
				const searchLower = query.search.toLowerCase();
				results = results.filter((item: any) =>
					Object.values(item).some(val =>
						typeof val === 'string' && val.toLowerCase().includes(searchLower)
					)
				);
			}

			// Apply sorting
			if (query?.sorts) {
				try {
					const sortFields = JSON.parse(query.sorts);
					if (Array.isArray(sortFields) && sortFields.length > 0) {
						results.sort((a: any, b: any) => {
							for (const sort of sortFields) {
								const { field, dir } = sort;
								const aVal = a[field];
								const bVal = b[field];
								if (aVal === bVal) continue;
								const comparison = aVal < bVal ? -1 : 1;
								return dir === 'desc' ? -comparison : comparison;
							}
							return 0;
						}
						);
					}
				} catch {
					// Invalid sorts format, skip
				}
			}

			// Apply pagination
			if (query?.page && query?.take) {
				const skip = (query.page - 1) * query.take;
				results = results.slice(skip, skip + query.take);
			} else if (query?.take) {
				results = results.slice(0, query.take);
			}

			return results as Survey[];
		}
		const response = await apiClient.surveyControllerFindAll(query);
		return (response.data as any) || [];
	},

	/**
	 * Create a new Survey
	 * @param survey - The Survey data to create
	 * @returns Promise<Survey>
	 */
	async surveyControllerCreate(survey: Survey): Promise<Survey> {
		if (getMode() === WorkMode.OFFLINE) {
			await db.DrillHole_Survey.add(survey);
			const result = await db.DrillHole_Survey.get(survey.SurveyId);
			if (!result) {
				throw new Error(`Failed to create Survey: ${survey.SurveyId}`);
			}
			return result;
		}
		return (await apiClient.surveyControllerCreate(survey)).data;
	},

	/**
	 * Update a Survey
	 * @param surveyId - The SurveyId to update
	 * @param survey - The updated Survey data
	 * @returns Promise<Survey>
	 */
	async surveyControllerUpdate(surveyId: string, survey: Survey): Promise<Survey> {
		if (getMode() === WorkMode.OFFLINE) {
			const numAffected = await db.DrillHole_Survey.update(surveyId, survey as any);
			let result;
			if (numAffected > 0) {
				result = await db.DrillHole_Survey.get(surveyId);
			}
			if (!result) {
				throw new Error(`Survey not found: ${surveyId}`);
			}
			return result;
		}
		return (await apiClient.surveyControllerUpdate(surveyId, survey)).data;
	},

	/**
	 * Remove (soft delete) a Survey
	 * Calls the API Remove endpoint which sets ActiveInd to false
	 * @param surveyId - The SurveyId to remove
	 * @param survey - The Survey data
	 * @returns Promise<Survey>
	 */
	async surveyControllerRemove(surveyId: string, survey: Survey): Promise<Survey> {
		if (getMode() === WorkMode.OFFLINE) {
			// In offline mode, soft delete by updating ActiveInd
			const numAffected = await db.DrillHole_Survey.update(surveyId, { ...survey, ActiveInd: false });
			let result;
			if (numAffected > 0) {
				result = await db.DrillHole_Survey.get(surveyId);
			}
			if (!result) {
				throw new Error(`Survey not found: ${surveyId}`);
			}
			return result;
		}
		// In online mode, call the API's Remove endpoint
		return (await apiClient.surveyControllerUpdate(surveyId, { ...survey, ActiveInd: false })).data;
	},

	/**
	 * Find a single SurveyLog by ID
	 * @param surveyLogId - The SurveyLogId to find
	 * @returns Promise<SurveyLog>
	 */
	async surveyLogControllerFindOne(surveyLogId: string): Promise<SurveyLog> {
		if (getMode() === WorkMode.OFFLINE) {
			const result = await db.DrillHole_SurveyLog.get(surveyLogId);
			if (!result) {
				throw new Error(`SurveyLog not found: ${surveyLogId}`);
			}
			return result;
		}
		return (await apiClient.surveyLogControllerFindOne(surveyLogId)).data;
	},

	/**
	 * Find all SurveyLog records with optional filtering
	 * @param query - Optional query parameters for filtering, pagination, etc.
	 * @returns Promise<SurveyLog[]>
	 */
	async surveyLogControllerFindAll(query?: {
		page?: number;
		take?: number;
		order?: "ASC" | "DESC";
		search?: string;
		filters?: string | FilterInput;
		sorts?: string;
	}): Promise<SurveyLog[]> {
		if (getMode() === WorkMode.OFFLINE) {
			let collection = db.DrillHole_SurveyLog.toCollection();

			// Get results as array
			let results = await collection.toArray();

			// Apply ALL filters on array
			if (query?.filters) {
				const filters = parseFiltersForDexie(query.filters);
				if (filters.length > 0) {
					for (const filter of filters) {
						const { field, op, value } = filter;
						switch (op) {
							case 'eq':
								results = results.filter((item: any) => item[field] === value);
								break;
							case 'neq':
								results = results.filter((item: any) => item[field] !== value);
								break;
							case 'gt':
								results = results.filter((item: any) => item[field] > value);
								break;
							case 'gte':
								results = results.filter((item: any) => item[field] >= value);
								break;
							case 'lt':
								results = results.filter((item: any) => item[field] < value);
								break;
							case 'lte':
								results = results.filter((item: any) => item[field] <= value);
								break;
							case 'contains':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().includes(String(value).toLowerCase())
								);
								break;
							case 'startsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().startsWith(String(value).toLowerCase())
								);
								break;
							case 'endsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().endsWith(String(value).toLowerCase())
								);
								break;
							case 'in':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => value.includes(item[field]));
								}
								break;
							case 'notIn':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => !value.includes(item[field]));
								}
								break;
						}
					}
				}
			}

			// Apply search (on array)
			if (query?.search) {
				const searchLower = query.search.toLowerCase();
				results = results.filter((item: any) =>
					Object.values(item).some(val =>
						typeof val === 'string' && val.toLowerCase().includes(searchLower)
					)
				);
			}

			// Apply sorting
			if (query?.sorts) {
				try {
					const sortFields = JSON.parse(query.sorts);
					if (Array.isArray(sortFields) && sortFields.length > 0) {
						results.sort((a: any, b: any) => {
							for (const sort of sortFields) {
								const { field, dir } = sort;
								const aVal = a[field];
								const bVal = b[field];
								if (aVal === bVal) continue;
								const comparison = aVal < bVal ? -1 : 1;
								return dir === 'desc' ? -comparison : comparison;
							}
							return 0;
						}
						);
					}
				} catch {
					// Invalid sorts format, skip
				}
			}

			// Apply pagination
			if (query?.page && query?.take) {
				const skip = (query.page - 1) * query.take;
				results = results.slice(skip, skip + query.take);
			} else if (query?.take) {
				results = results.slice(0, query.take);
			}

			return results as SurveyLog[];
		}
		const response = await apiClient.surveyLogControllerFindAll(query);
		return (response.data as any) || [];
	},

	/**
	 * Create a new SurveyLog
	 * @param surveyLog - The SurveyLog data to create
	 * @returns Promise<SurveyLog>
	 */
	async surveyLogControllerCreate(surveyLog: SurveyLog): Promise<SurveyLog> {
		if (getMode() === WorkMode.OFFLINE) {
			await db.DrillHole_SurveyLog.add(surveyLog);
			const result = await db.DrillHole_SurveyLog.get(surveyLog.SurveyLogId);
			if (!result) {
				throw new Error(`Failed to create SurveyLog: ${surveyLog.SurveyLogId}`);
			}
			return result;
		}
		return (await apiClient.surveyLogControllerCreate(surveyLog)).data;
	},

	/**
	 * Update a SurveyLog
	 * @param surveyLogId - The SurveyLogId to update
	 * @param surveyLog - The updated SurveyLog data
	 * @returns Promise<SurveyLog>
	 */
	async surveyLogControllerUpdate(surveyLogId: string, surveyLog: SurveyLog): Promise<SurveyLog> {
		if (getMode() === WorkMode.OFFLINE) {
			const numAffected = await db.DrillHole_SurveyLog.update(surveyLogId, surveyLog as any);
			let result;
			if (numAffected > 0) {
				result = await db.DrillHole_SurveyLog.get(surveyLogId);
			}
			if (!result) {
				throw new Error(`SurveyLog not found: ${surveyLogId}`);
			}
			return result;
		}
		return (await apiClient.surveyLogControllerUpdate(surveyLogId, surveyLog)).data;
	},

	/**
	 * Remove (soft delete) a SurveyLog
	 * Calls the API Remove endpoint which sets ActiveInd to false
	 * @param surveyLogId - The SurveyLogId to remove
	 * @param surveyLog - The SurveyLog data
	 * @returns Promise<SurveyLog>
	 */
	async surveyLogControllerRemove(surveyLogId: string, surveyLog: SurveyLog): Promise<SurveyLog> {
		if (getMode() === WorkMode.OFFLINE) {
			// In offline mode, soft delete by updating ActiveInd
			const numAffected = await db.DrillHole_SurveyLog.update(surveyLogId, { ...surveyLog, ActiveInd: false });
			let result;
			if (numAffected > 0) {
				result = await db.DrillHole_SurveyLog.get(surveyLogId);
			}
			if (!result) {
				throw new Error(`SurveyLog not found: ${surveyLogId}`);
			}
			return result;
		}
		// In online mode, call the API's Remove endpoint
		return (await apiClient.surveyLogControllerUpdate(surveyLogId, { ...surveyLog, ActiveInd: false })).data;
	},

	/**
	 * Find a single HoleNmPrefix by ID
	 * @param holeNmPrefixId - The HoleNmPrefixId to find
	 * @returns Promise<HoleNmPrefix>
	 */
	async holeNmPrefixControllerFindOne(holeNmPrefixId: string): Promise<HoleNmPrefix> {
		if (getMode() === WorkMode.OFFLINE) {
			const result = await db.Classification_HoleNmPrefix.get(holeNmPrefixId);
			if (!result) {
				throw new Error(`HoleNmPrefix not found: ${holeNmPrefixId}`);
			}
			return result;
		}
		return (await apiClient.holeNmPrefixControllerFindOne(holeNmPrefixId)).data;
	},

	/**
	 * Find all HoleNmPrefix records with optional filtering
	 * @param query - Optional query parameters for filtering, pagination, etc.
	 * @returns Promise<HoleNmPrefix[]>
	 */
	async holeNmPrefixControllerFindAll(query?: {
		page?: number;
		take?: number;
		order?: "ASC" | "DESC";
		search?: string;
		filters?: string | FilterInput;
		sorts?: string;
	}): Promise<HoleNmPrefix[]> {
		if (getMode() === WorkMode.OFFLINE) {
			let collection = db.Classification_HoleNmPrefix.toCollection();

			// Get results as array
			let results = await collection.toArray();

			// Apply ALL filters on array
			if (query?.filters) {
				const filters = parseFiltersForDexie(query.filters);
				if (filters.length > 0) {
					for (const filter of filters) {
						const { field, op, value } = filter;
						switch (op) {
							case 'eq':
								results = results.filter((item: any) => item[field] === value);
								break;
							case 'neq':
								results = results.filter((item: any) => item[field] !== value);
								break;
							case 'gt':
								results = results.filter((item: any) => item[field] > value);
								break;
							case 'gte':
								results = results.filter((item: any) => item[field] >= value);
								break;
							case 'lt':
								results = results.filter((item: any) => item[field] < value);
								break;
							case 'lte':
								results = results.filter((item: any) => item[field] <= value);
								break;
							case 'contains':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().includes(String(value).toLowerCase())
								);
								break;
							case 'startsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().startsWith(String(value).toLowerCase())
								);
								break;
							case 'endsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().endsWith(String(value).toLowerCase())
								);
								break;
							case 'in':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => value.includes(item[field]));
								}
								break;
							case 'notIn':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => !value.includes(item[field]));
								}
								break;
						}
					}
				}
			}

			// Apply search (on array)
			if (query?.search) {
				const searchLower = query.search.toLowerCase();
				results = results.filter((item: any) =>
					Object.values(item).some(val =>
						typeof val === 'string' && val.toLowerCase().includes(searchLower)
					)
				);
			}

			// Apply sorting
			if (query?.sorts) {
				try {
					const sortFields = JSON.parse(query.sorts);
					if (Array.isArray(sortFields) && sortFields.length > 0) {
						results.sort((a: any, b: any) => {
							for (const sort of sortFields) {
								const { field, dir } = sort;
								const aVal = a[field];
								const bVal = b[field];
								if (aVal === bVal) continue;
								const comparison = aVal < bVal ? -1 : 1;
								return dir === 'desc' ? -comparison : comparison;
							}
							return 0;
						}
						);
					}
				} catch {
					// Invalid sorts format, skip
				}
			}

			// Apply pagination
			if (query?.page && query?.take) {
				const skip = (query.page - 1) * query.take;
				results = results.slice(skip, skip + query.take);
			} else if (query?.take) {
				results = results.slice(0, query.take);
			}

			return results as HoleNmPrefix[];
		}
		const response = await apiClient.holeNmPrefixControllerFindAll(query);
		return (response.data as any) || [];
	},

	/**
	 * Create a new HoleNmPrefix
	 * @param holeNmPrefix - The HoleNmPrefix data to create
	 * @returns Promise<HoleNmPrefix>
	 */
	async holeNmPrefixControllerCreate(holeNmPrefix: HoleNmPrefix): Promise<HoleNmPrefix> {
		if (getMode() === WorkMode.OFFLINE) {
			await db.Classification_HoleNmPrefix.add(holeNmPrefix);
			const result = await db.Classification_HoleNmPrefix.get(holeNmPrefix.HoleNmPrefixId);
			if (!result) {
				throw new Error(`Failed to create HoleNmPrefix: ${holeNmPrefix.HoleNmPrefixId}`);
			}
			return result;
		}
		return (await apiClient.holeNmPrefixControllerCreate(holeNmPrefix)).data;
	},

	/**
	 * Update a HoleNmPrefix
	 * @param holeNmPrefixId - The HoleNmPrefixId to update
	 * @param holeNmPrefix - The updated HoleNmPrefix data
	 * @returns Promise<HoleNmPrefix>
	 */
	async holeNmPrefixControllerUpdate(holeNmPrefixId: string, holeNmPrefix: HoleNmPrefix): Promise<HoleNmPrefix> {
		if (getMode() === WorkMode.OFFLINE) {
			const numAffected = await db.Classification_HoleNmPrefix.update(holeNmPrefixId, holeNmPrefix as any);
			let result;
			if (numAffected > 0) {
				result = await db.Classification_HoleNmPrefix.get(holeNmPrefixId);
			}
			if (!result) {
				throw new Error(`HoleNmPrefix not found: ${holeNmPrefixId}`);
			}
			return result;
		}
		return (await apiClient.holeNmPrefixControllerUpdate(holeNmPrefixId, holeNmPrefix)).data;
	},

	/**
	 * Remove (soft delete) a HoleNmPrefix
	 * Calls the API Remove endpoint which sets ActiveInd to false
	 * @param holeNmPrefixId - The HoleNmPrefixId to remove
	 * @param holeNmPrefix - The HoleNmPrefix data
	 * @returns Promise<HoleNmPrefix>
	 */
	async holeNmPrefixControllerRemove(holeNmPrefixId: string, holeNmPrefix: HoleNmPrefix): Promise<HoleNmPrefix> {
		if (getMode() === WorkMode.OFFLINE) {
			// In offline mode, soft delete by updating ActiveInd
			const numAffected = await db.Classification_HoleNmPrefix.update(holeNmPrefixId, { ...holeNmPrefix, ActiveInd: false });
			let result;
			if (numAffected > 0) {
				result = await db.Classification_HoleNmPrefix.get(holeNmPrefixId);
			}
			if (!result) {
				throw new Error(`HoleNmPrefix not found: ${holeNmPrefixId}`);
			}
			return result;
		}
		// In online mode, call the API's Remove endpoint
		return (await apiClient.holeNmPrefixControllerUpdate(holeNmPrefixId, { ...holeNmPrefix, ActiveInd: false })).data;
	},

	/**
	 * Find a single Organization by ID
	 * @param organizationId - The OrganizationId to find
	 * @returns Promise<Organization>
	 */
	async organizationControllerFindOne(organizationId: string): Promise<Organization> {
		if (getMode() === WorkMode.OFFLINE) {
			const result = await db.Classification_Organization.get(organizationId);
			if (!result) {
				throw new Error(`Organization not found: ${organizationId}`);
			}
			return result;
		}
		return (await apiClient.organizationControllerFindOne(organizationId)).data;
	},

	/**
	 * Find all Organization records with optional filtering
	 * @param query - Optional query parameters for filtering, pagination, etc.
	 * @returns Promise<Organization[]>
	 */
	async organizationControllerFindAll(query?: {
		page?: number;
		take?: number;
		order?: "ASC" | "DESC";
		search?: string;
		filters?: string | FilterInput;
		sorts?: string;
	}): Promise<Organization[]> {
		if (getMode() === WorkMode.OFFLINE) {
			let collection = db.Classification_Organization.toCollection();

			// Get results as array
			let results = await collection.toArray();

			// Apply ALL filters on array
			if (query?.filters) {
				const filters = parseFiltersForDexie(query.filters);
				if (filters.length > 0) {
					for (const filter of filters) {
						const { field, op, value } = filter;
						switch (op) {
							case 'eq':
								results = results.filter((item: any) => item[field] === value);
								break;
							case 'neq':
								results = results.filter((item: any) => item[field] !== value);
								break;
							case 'gt':
								results = results.filter((item: any) => item[field] > value);
								break;
							case 'gte':
								results = results.filter((item: any) => item[field] >= value);
								break;
							case 'lt':
								results = results.filter((item: any) => item[field] < value);
								break;
							case 'lte':
								results = results.filter((item: any) => item[field] <= value);
								break;
							case 'contains':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().includes(String(value).toLowerCase())
								);
								break;
							case 'startsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().startsWith(String(value).toLowerCase())
								);
								break;
							case 'endsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().endsWith(String(value).toLowerCase())
								);
								break;
							case 'in':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => value.includes(item[field]));
								}
								break;
							case 'notIn':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => !value.includes(item[field]));
								}
								break;
						}
					}
				}
			}

			// Apply search (on array)
			if (query?.search) {
				const searchLower = query.search.toLowerCase();
				results = results.filter((item: any) =>
					Object.values(item).some(val =>
						typeof val === 'string' && val.toLowerCase().includes(searchLower)
					)
				);
			}

			// Apply sorting
			if (query?.sorts) {
				try {
					const sortFields = JSON.parse(query.sorts);
					if (Array.isArray(sortFields) && sortFields.length > 0) {
						results.sort((a: any, b: any) => {
							for (const sort of sortFields) {
								const { field, dir } = sort;
								const aVal = a[field];
								const bVal = b[field];
								if (aVal === bVal) continue;
								const comparison = aVal < bVal ? -1 : 1;
								return dir === 'desc' ? -comparison : comparison;
							}
							return 0;
						}
						);
					}
				} catch {
					// Invalid sorts format, skip
				}
			}

			// Apply pagination
			if (query?.page && query?.take) {
				const skip = (query.page - 1) * query.take;
				results = results.slice(skip, skip + query.take);
			} else if (query?.take) {
				results = results.slice(0, query.take);
			}

			return results as Organization[];
		}
		const response = await apiClient.organizationControllerFindAll(query);
		return (response.data as any) || [];
	},

	/**
	 * Create a new Organization
	 * @param organization - The Organization data to create
	 * @returns Promise<Organization>
	 */
	async organizationControllerCreate(organization: Organization): Promise<Organization> {
		if (getMode() === WorkMode.OFFLINE) {
			await db.Classification_Organization.add(organization);
			const result = await db.Classification_Organization.get(organization.OrganizationId);
			if (!result) {
				throw new Error(`Failed to create Organization: ${organization.OrganizationId}`);
			}
			return result;
		}
		return (await apiClient.organizationControllerCreate(organization)).data;
	},

	/**
	 * Update a Organization
	 * @param organizationId - The OrganizationId to update
	 * @param organization - The updated Organization data
	 * @returns Promise<Organization>
	 */
	async organizationControllerUpdate(organizationId: string, organization: Organization): Promise<Organization> {
		if (getMode() === WorkMode.OFFLINE) {
			const numAffected = await db.Classification_Organization.update(organizationId, organization as any);
			let result;
			if (numAffected > 0) {
				result = await db.Classification_Organization.get(organizationId);
			}
			if (!result) {
				throw new Error(`Organization not found: ${organizationId}`);
			}
			return result;
		}
		return (await apiClient.organizationControllerUpdate(organizationId, organization)).data;
	},

	/**
	 * Remove (soft delete) a Organization
	 * Calls the API Remove endpoint which sets ActiveInd to false
	 * @param organizationId - The OrganizationId to remove
	 * @param organization - The Organization data
	 * @returns Promise<Organization>
	 */
	async organizationControllerRemove(organizationId: string, organization: Organization): Promise<Organization> {
		if (getMode() === WorkMode.OFFLINE) {
			// In offline mode, soft delete by updating ActiveInd
			const numAffected = await db.Classification_Organization.update(organizationId, { ...organization, ActiveInd: false });
			let result;
			if (numAffected > 0) {
				result = await db.Classification_Organization.get(organizationId);
			}
			if (!result) {
				throw new Error(`Organization not found: ${organizationId}`);
			}
			return result;
		}
		// In online mode, call the API's Remove endpoint
		return (await apiClient.organizationControllerUpdate(organizationId, { ...organization, ActiveInd: false })).data;
	},

	/**
	 * Find a single Phase by ID
	 * @param phaseId - The PhaseId to find
	 * @returns Promise<Phase>
	 */
	async phaseControllerFindOne(phaseId: string): Promise<Phase> {
		if (getMode() === WorkMode.OFFLINE) {
			const result = await db.Classification_Phase.get(phaseId);
			if (!result) {
				throw new Error(`Phase not found: ${phaseId}`);
			}
			return result;
		}
		return (await apiClient.phaseControllerFindOne(phaseId)).data;
	},

	/**
	 * Find all Phase records with optional filtering
	 * @param query - Optional query parameters for filtering, pagination, etc.
	 * @returns Promise<Phase[]>
	 */
	async phaseControllerFindAll(query?: {
		page?: number;
		take?: number;
		order?: "ASC" | "DESC";
		search?: string;
		filters?: string | FilterInput;
		sorts?: string;
	}): Promise<Phase[]> {
		if (getMode() === WorkMode.OFFLINE) {
			let collection = db.Classification_Phase.toCollection();

			// Get results as array
			let results = await collection.toArray();

			// Apply ALL filters on array
			if (query?.filters) {
				const filters = parseFiltersForDexie(query.filters);
				if (filters.length > 0) {
					for (const filter of filters) {
						const { field, op, value } = filter;
						switch (op) {
							case 'eq':
								results = results.filter((item: any) => item[field] === value);
								break;
							case 'neq':
								results = results.filter((item: any) => item[field] !== value);
								break;
							case 'gt':
								results = results.filter((item: any) => item[field] > value);
								break;
							case 'gte':
								results = results.filter((item: any) => item[field] >= value);
								break;
							case 'lt':
								results = results.filter((item: any) => item[field] < value);
								break;
							case 'lte':
								results = results.filter((item: any) => item[field] <= value);
								break;
							case 'contains':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().includes(String(value).toLowerCase())
								);
								break;
							case 'startsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().startsWith(String(value).toLowerCase())
								);
								break;
							case 'endsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().endsWith(String(value).toLowerCase())
								);
								break;
							case 'in':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => value.includes(item[field]));
								}
								break;
							case 'notIn':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => !value.includes(item[field]));
								}
								break;
						}
					}
				}
			}

			// Apply search (on array)
			if (query?.search) {
				const searchLower = query.search.toLowerCase();
				results = results.filter((item: any) =>
					Object.values(item).some(val =>
						typeof val === 'string' && val.toLowerCase().includes(searchLower)
					)
				);
			}

			// Apply sorting
			if (query?.sorts) {
				try {
					const sortFields = JSON.parse(query.sorts);
					if (Array.isArray(sortFields) && sortFields.length > 0) {
						results.sort((a: any, b: any) => {
							for (const sort of sortFields) {
								const { field, dir } = sort;
								const aVal = a[field];
								const bVal = b[field];
								if (aVal === bVal) continue;
								const comparison = aVal < bVal ? -1 : 1;
								return dir === 'desc' ? -comparison : comparison;
							}
							return 0;
						}
						);
					}
				} catch {
					// Invalid sorts format, skip
				}
			}

			// Apply pagination
			if (query?.page && query?.take) {
				const skip = (query.page - 1) * query.take;
				results = results.slice(skip, skip + query.take);
			} else if (query?.take) {
				results = results.slice(0, query.take);
			}

			return results as Phase[];
		}
		const response = await apiClient.phaseControllerFindAll(query);
		return (response.data as any) || [];
	},

	/**
	 * Create a new Phase
	 * @param phase - The Phase data to create
	 * @returns Promise<Phase>
	 */
	async phaseControllerCreate(phase: Phase): Promise<Phase> {
		if (getMode() === WorkMode.OFFLINE) {
			await db.Classification_Phase.add(phase);
			const result = await db.Classification_Phase.get(phase.PhaseId);
			if (!result) {
				throw new Error(`Failed to create Phase: ${phase.PhaseId}`);
			}
			return result;
		}
		return (await apiClient.phaseControllerCreate(phase)).data;
	},

	/**
	 * Update a Phase
	 * @param phaseId - The PhaseId to update
	 * @param phase - The updated Phase data
	 * @returns Promise<Phase>
	 */
	async phaseControllerUpdate(phaseId: string, phase: Phase): Promise<Phase> {
		if (getMode() === WorkMode.OFFLINE) {
			const numAffected = await db.Classification_Phase.update(phaseId, phase as any);
			let result;
			if (numAffected > 0) {
				result = await db.Classification_Phase.get(phaseId);
			}
			if (!result) {
				throw new Error(`Phase not found: ${phaseId}`);
			}
			return result;
		}
		return (await apiClient.phaseControllerUpdate(phaseId, phase)).data;
	},

	/**
	 * Remove (soft delete) a Phase
	 * Calls the API Remove endpoint which sets ActiveInd to false
	 * @param phaseId - The PhaseId to remove
	 * @param phase - The Phase data
	 * @returns Promise<Phase>
	 */
	async phaseControllerRemove(phaseId: string, phase: Phase): Promise<Phase> {
		if (getMode() === WorkMode.OFFLINE) {
			// In offline mode, soft delete by updating ActiveInd
			const numAffected = await db.Classification_Phase.update(phaseId, { ...phase, ActiveInd: false });
			let result;
			if (numAffected > 0) {
				result = await db.Classification_Phase.get(phaseId);
			}
			if (!result) {
				throw new Error(`Phase not found: ${phaseId}`);
			}
			return result;
		}
		// In online mode, call the API's Remove endpoint
		return (await apiClient.phaseControllerUpdate(phaseId, { ...phase, ActiveInd: false })).data;
	},

	/**
	 * Find a single Pit by ID
	 * @param pitId - The PitId to find
	 * @returns Promise<Pit>
	 */
	async pitControllerFindOne(pitId: string): Promise<Pit> {
		if (getMode() === WorkMode.OFFLINE) {
			const result = await db.Classification_Pit.get(pitId);
			if (!result) {
				throw new Error(`Pit not found: ${pitId}`);
			}
			return result;
		}
		return (await apiClient.pitControllerFindOne(pitId)).data;
	},

	/**
	 * Find all Pit records with optional filtering
	 * @param query - Optional query parameters for filtering, pagination, etc.
	 * @returns Promise<Pit[]>
	 */
	async pitControllerFindAll(query?: {
		page?: number;
		take?: number;
		order?: "ASC" | "DESC";
		search?: string;
		filters?: string | FilterInput;
		sorts?: string;
	}): Promise<Pit[]> {
		if (getMode() === WorkMode.OFFLINE) {
			let collection = db.Classification_Pit.toCollection();

			// Get results as array
			let results = await collection.toArray();

			// Apply ALL filters on array
			if (query?.filters) {
				const filters = parseFiltersForDexie(query.filters);
				if (filters.length > 0) {
					for (const filter of filters) {
						const { field, op, value } = filter;
						switch (op) {
							case 'eq':
								results = results.filter((item: any) => item[field] === value);
								break;
							case 'neq':
								results = results.filter((item: any) => item[field] !== value);
								break;
							case 'gt':
								results = results.filter((item: any) => item[field] > value);
								break;
							case 'gte':
								results = results.filter((item: any) => item[field] >= value);
								break;
							case 'lt':
								results = results.filter((item: any) => item[field] < value);
								break;
							case 'lte':
								results = results.filter((item: any) => item[field] <= value);
								break;
							case 'contains':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().includes(String(value).toLowerCase())
								);
								break;
							case 'startsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().startsWith(String(value).toLowerCase())
								);
								break;
							case 'endsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().endsWith(String(value).toLowerCase())
								);
								break;
							case 'in':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => value.includes(item[field]));
								}
								break;
							case 'notIn':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => !value.includes(item[field]));
								}
								break;
						}
					}
				}
			}

			// Apply search (on array)
			if (query?.search) {
				const searchLower = query.search.toLowerCase();
				results = results.filter((item: any) =>
					Object.values(item).some(val =>
						typeof val === 'string' && val.toLowerCase().includes(searchLower)
					)
				);
			}

			// Apply sorting
			if (query?.sorts) {
				try {
					const sortFields = JSON.parse(query.sorts);
					if (Array.isArray(sortFields) && sortFields.length > 0) {
						results.sort((a: any, b: any) => {
							for (const sort of sortFields) {
								const { field, dir } = sort;
								const aVal = a[field];
								const bVal = b[field];
								if (aVal === bVal) continue;
								const comparison = aVal < bVal ? -1 : 1;
								return dir === 'desc' ? -comparison : comparison;
							}
							return 0;
						}
						);
					}
				} catch {
					// Invalid sorts format, skip
				}
			}

			// Apply pagination
			if (query?.page && query?.take) {
				const skip = (query.page - 1) * query.take;
				results = results.slice(skip, skip + query.take);
			} else if (query?.take) {
				results = results.slice(0, query.take);
			}

			return results as Pit[];
		}
		const response = await apiClient.pitControllerFindAll(query);
		return (response.data as any) || [];
	},

	/**
	 * Create a new Pit
	 * @param pit - The Pit data to create
	 * @returns Promise<Pit>
	 */
	async pitControllerCreate(pit: Pit): Promise<Pit> {
		if (getMode() === WorkMode.OFFLINE) {
			await db.Classification_Pit.add(pit);
			const result = await db.Classification_Pit.get(pit.PitId);
			if (!result) {
				throw new Error(`Failed to create Pit: ${pit.PitId}`);
			}
			return result;
		}
		return (await apiClient.pitControllerCreate(pit)).data;
	},

	/**
	 * Update a Pit
	 * @param pitId - The PitId to update
	 * @param pit - The updated Pit data
	 * @returns Promise<Pit>
	 */
	async pitControllerUpdate(pitId: string, pit: Pit): Promise<Pit> {
		if (getMode() === WorkMode.OFFLINE) {
			const numAffected = await db.Classification_Pit.update(pitId, pit as any);
			let result;
			if (numAffected > 0) {
				result = await db.Classification_Pit.get(pitId);
			}
			if (!result) {
				throw new Error(`Pit not found: ${pitId}`);
			}
			return result;
		}
		return (await apiClient.pitControllerUpdate(pitId, pit)).data;
	},

	/**
	 * Remove (soft delete) a Pit
	 * Calls the API Remove endpoint which sets ActiveInd to false
	 * @param pitId - The PitId to remove
	 * @param pit - The Pit data
	 * @returns Promise<Pit>
	 */
	async pitControllerRemove(pitId: string, pit: Pit): Promise<Pit> {
		if (getMode() === WorkMode.OFFLINE) {
			// In offline mode, soft delete by updating ActiveInd
			const numAffected = await db.Classification_Pit.update(pitId, { ...pit, ActiveInd: false });
			let result;
			if (numAffected > 0) {
				result = await db.Classification_Pit.get(pitId);
			}
			if (!result) {
				throw new Error(`Pit not found: ${pitId}`);
			}
			return result;
		}
		// In online mode, call the API's Remove endpoint
		return (await apiClient.pitControllerUpdate(pitId, { ...pit, ActiveInd: false })).data;
	},

	/**
	 * Find a single Project by ID
	 * @param projectId - The ProjectId to find
	 * @returns Promise<Project>
	 */
	async projectControllerFindOne(projectId: string): Promise<Project> {
		if (getMode() === WorkMode.OFFLINE) {
			const result = await db.Classification_Project.get(projectId);
			if (!result) {
				throw new Error(`Project not found: ${projectId}`);
			}
			return result;
		}
		return (await apiClient.projectControllerFindOne(projectId)).data;
	},

	/**
	 * Find all Project records with optional filtering
	 * @param query - Optional query parameters for filtering, pagination, etc.
	 * @returns Promise<Project[]>
	 */
	async projectControllerFindAll(query?: {
		page?: number;
		take?: number;
		order?: "ASC" | "DESC";
		search?: string;
		filters?: string | FilterInput;
		sorts?: string;
	}): Promise<Project[]> {
		if (getMode() === WorkMode.OFFLINE) {
			let collection = db.Classification_Project.toCollection();

			// Get results as array
			let results = await collection.toArray();

			// Apply ALL filters on array
			if (query?.filters) {
				const filters = parseFiltersForDexie(query.filters);
				if (filters.length > 0) {
					for (const filter of filters) {
						const { field, op, value } = filter;
						switch (op) {
							case 'eq':
								results = results.filter((item: any) => item[field] === value);
								break;
							case 'neq':
								results = results.filter((item: any) => item[field] !== value);
								break;
							case 'gt':
								results = results.filter((item: any) => item[field] > value);
								break;
							case 'gte':
								results = results.filter((item: any) => item[field] >= value);
								break;
							case 'lt':
								results = results.filter((item: any) => item[field] < value);
								break;
							case 'lte':
								results = results.filter((item: any) => item[field] <= value);
								break;
							case 'contains':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().includes(String(value).toLowerCase())
								);
								break;
							case 'startsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().startsWith(String(value).toLowerCase())
								);
								break;
							case 'endsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().endsWith(String(value).toLowerCase())
								);
								break;
							case 'in':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => value.includes(item[field]));
								}
								break;
							case 'notIn':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => !value.includes(item[field]));
								}
								break;
						}
					}
				}
			}

			// Apply search (on array)
			if (query?.search) {
				const searchLower = query.search.toLowerCase();
				results = results.filter((item: any) =>
					Object.values(item).some(val =>
						typeof val === 'string' && val.toLowerCase().includes(searchLower)
					)
				);
			}

			// Apply sorting
			if (query?.sorts) {
				try {
					const sortFields = JSON.parse(query.sorts);
					if (Array.isArray(sortFields) && sortFields.length > 0) {
						results.sort((a: any, b: any) => {
							for (const sort of sortFields) {
								const { field, dir } = sort;
								const aVal = a[field];
								const bVal = b[field];
								if (aVal === bVal) continue;
								const comparison = aVal < bVal ? -1 : 1;
								return dir === 'desc' ? -comparison : comparison;
							}
							return 0;
						}
						);
					}
				} catch {
					// Invalid sorts format, skip
				}
			}

			// Apply pagination
			if (query?.page && query?.take) {
				const skip = (query.page - 1) * query.take;
				results = results.slice(skip, skip + query.take);
			} else if (query?.take) {
				results = results.slice(0, query.take);
			}

			return results as Project[];
		}
		const response = await apiClient.projectControllerFindAll(query);
		return (response.data as any) || [];
	},

	/**
	 * Create a new Project
	 * @param project - The Project data to create
	 * @returns Promise<Project>
	 */
	async projectControllerCreate(project: Project): Promise<Project> {
		if (getMode() === WorkMode.OFFLINE) {
			await db.Classification_Project.add(project);
			const result = await db.Classification_Project.get(project.ProjectId);
			if (!result) {
				throw new Error(`Failed to create Project: ${project.ProjectId}`);
			}
			return result;
		}
		return (await apiClient.projectControllerCreate(project)).data;
	},

	/**
	 * Update a Project
	 * @param projectId - The ProjectId to update
	 * @param project - The updated Project data
	 * @returns Promise<Project>
	 */
	async projectControllerUpdate(projectId: string, project: Project): Promise<Project> {
		if (getMode() === WorkMode.OFFLINE) {
			const numAffected = await db.Classification_Project.update(projectId, project as any);
			let result;
			if (numAffected > 0) {
				result = await db.Classification_Project.get(projectId);
			}
			if (!result) {
				throw new Error(`Project not found: ${projectId}`);
			}
			return result;
		}
		return (await apiClient.projectControllerUpdate(projectId, project)).data;
	},

	/**
	 * Remove (soft delete) a Project
	 * Calls the API Remove endpoint which sets ActiveInd to false
	 * @param projectId - The ProjectId to remove
	 * @param project - The Project data
	 * @returns Promise<Project>
	 */
	async projectControllerRemove(projectId: string, project: Project): Promise<Project> {
		if (getMode() === WorkMode.OFFLINE) {
			// In offline mode, soft delete by updating ActiveInd
			const numAffected = await db.Classification_Project.update(projectId, { ...project, ActiveInd: false });
			let result;
			if (numAffected > 0) {
				result = await db.Classification_Project.get(projectId);
			}
			if (!result) {
				throw new Error(`Project not found: ${projectId}`);
			}
			return result;
		}
		// In online mode, call the API's Remove endpoint
		return (await apiClient.projectControllerUpdate(projectId, { ...project, ActiveInd: false })).data;
	},

	/**
	 * Find a single Prospect by ID
	 * @param prospectId - The ProspectId to find
	 * @returns Promise<Prospect>
	 */
	async prospectControllerFindOne(prospectId: string): Promise<Prospect> {
		if (getMode() === WorkMode.OFFLINE) {
			const result = await db.Classification_Prospect.get(prospectId);
			if (!result) {
				throw new Error(`Prospect not found: ${prospectId}`);
			}
			return result;
		}
		return (await apiClient.prospectControllerFindOne(prospectId)).data;
	},

	/**
	 * Find all Prospect records with optional filtering
	 * @param query - Optional query parameters for filtering, pagination, etc.
	 * @returns Promise<Prospect[]>
	 */
	async prospectControllerFindAll(query?: {
		page?: number;
		take?: number;
		order?: "ASC" | "DESC";
		search?: string;
		filters?: string | FilterInput;
		sorts?: string;
	}): Promise<Prospect[]> {
		if (getMode() === WorkMode.OFFLINE) {
			let collection = db.Classification_Prospect.toCollection();

			// Get results as array
			let results = await collection.toArray();

			// Apply ALL filters on array
			if (query?.filters) {
				const filters = parseFiltersForDexie(query.filters);
				if (filters.length > 0) {
					for (const filter of filters) {
						const { field, op, value } = filter;
						switch (op) {
							case 'eq':
								results = results.filter((item: any) => item[field] === value);
								break;
							case 'neq':
								results = results.filter((item: any) => item[field] !== value);
								break;
							case 'gt':
								results = results.filter((item: any) => item[field] > value);
								break;
							case 'gte':
								results = results.filter((item: any) => item[field] >= value);
								break;
							case 'lt':
								results = results.filter((item: any) => item[field] < value);
								break;
							case 'lte':
								results = results.filter((item: any) => item[field] <= value);
								break;
							case 'contains':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().includes(String(value).toLowerCase())
								);
								break;
							case 'startsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().startsWith(String(value).toLowerCase())
								);
								break;
							case 'endsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().endsWith(String(value).toLowerCase())
								);
								break;
							case 'in':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => value.includes(item[field]));
								}
								break;
							case 'notIn':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => !value.includes(item[field]));
								}
								break;
						}
					}
				}
			}

			// Apply search (on array)
			if (query?.search) {
				const searchLower = query.search.toLowerCase();
				results = results.filter((item: any) =>
					Object.values(item).some(val =>
						typeof val === 'string' && val.toLowerCase().includes(searchLower)
					)
				);
			}

			// Apply sorting
			if (query?.sorts) {
				try {
					const sortFields = JSON.parse(query.sorts);
					if (Array.isArray(sortFields) && sortFields.length > 0) {
						results.sort((a: any, b: any) => {
							for (const sort of sortFields) {
								const { field, dir } = sort;
								const aVal = a[field];
								const bVal = b[field];
								if (aVal === bVal) continue;
								const comparison = aVal < bVal ? -1 : 1;
								return dir === 'desc' ? -comparison : comparison;
							}
							return 0;
						}
						);
					}
				} catch {
					// Invalid sorts format, skip
				}
			}

			// Apply pagination
			if (query?.page && query?.take) {
				const skip = (query.page - 1) * query.take;
				results = results.slice(skip, skip + query.take);
			} else if (query?.take) {
				results = results.slice(0, query.take);
			}

			return results as Prospect[];
		}
		const response = await apiClient.prospectControllerFindAll(query);
		return (response.data as any) || [];
	},

	/**
	 * Create a new Prospect
	 * @param prospect - The Prospect data to create
	 * @returns Promise<Prospect>
	 */
	async prospectControllerCreate(prospect: Prospect): Promise<Prospect> {
		if (getMode() === WorkMode.OFFLINE) {
			await db.Classification_Prospect.add(prospect);
			const result = await db.Classification_Prospect.get(prospect.ProspectId);
			if (!result) {
				throw new Error(`Failed to create Prospect: ${prospect.ProspectId}`);
			}
			return result;
		}
		return (await apiClient.prospectControllerCreate(prospect)).data;
	},

	/**
	 * Update a Prospect
	 * @param prospectId - The ProspectId to update
	 * @param prospect - The updated Prospect data
	 * @returns Promise<Prospect>
	 */
	async prospectControllerUpdate(prospectId: string, prospect: Prospect): Promise<Prospect> {
		if (getMode() === WorkMode.OFFLINE) {
			const numAffected = await db.Classification_Prospect.update(prospectId, prospect as any);
			let result;
			if (numAffected > 0) {
				result = await db.Classification_Prospect.get(prospectId);
			}
			if (!result) {
				throw new Error(`Prospect not found: ${prospectId}`);
			}
			return result;
		}
		return (await apiClient.prospectControllerUpdate(prospectId, prospect)).data;
	},

	/**
	 * Remove (soft delete) a Prospect
	 * Calls the API Remove endpoint which sets ActiveInd to false
	 * @param prospectId - The ProspectId to remove
	 * @param prospect - The Prospect data
	 * @returns Promise<Prospect>
	 */
	async prospectControllerRemove(prospectId: string, prospect: Prospect): Promise<Prospect> {
		if (getMode() === WorkMode.OFFLINE) {
			// In offline mode, soft delete by updating ActiveInd
			const numAffected = await db.Classification_Prospect.update(prospectId, { ...prospect, ActiveInd: false });
			let result;
			if (numAffected > 0) {
				result = await db.Classification_Prospect.get(prospectId);
			}
			if (!result) {
				throw new Error(`Prospect not found: ${prospectId}`);
			}
			return result;
		}
		// In online mode, call the API's Remove endpoint
		return (await apiClient.prospectControllerUpdate(prospectId, { ...prospect, ActiveInd: false })).data;
	},

	/**
	 * Find a single Section by ID
	 * @param sectionId - The SectionId to find
	 * @returns Promise<Section>
	 */
	async sectionControllerFindOne(sectionId: string): Promise<Section> {
		if (getMode() === WorkMode.OFFLINE) {
			const result = await db.Classification_Section.get(sectionId);
			if (!result) {
				throw new Error(`Section not found: ${sectionId}`);
			}
			return result;
		}
		return (await apiClient.sectionControllerFindOne(sectionId)).data;
	},

	/**
	 * Find all Section records with optional filtering
	 * @param query - Optional query parameters for filtering, pagination, etc.
	 * @returns Promise<Section[]>
	 */
	async sectionControllerFindAll(query?: {
		page?: number;
		take?: number;
		order?: "ASC" | "DESC";
		search?: string;
		filters?: string | FilterInput;
		sorts?: string;
	}): Promise<Section[]> {
		if (getMode() === WorkMode.OFFLINE) {
			let collection = db.Classification_Section.toCollection();

			// Get results as array
			let results = await collection.toArray();

			// Apply ALL filters on array
			if (query?.filters) {
				const filters = parseFiltersForDexie(query.filters);
				if (filters.length > 0) {
					for (const filter of filters) {
						const { field, op, value } = filter;
						switch (op) {
							case 'eq':
								results = results.filter((item: any) => item[field] === value);
								break;
							case 'neq':
								results = results.filter((item: any) => item[field] !== value);
								break;
							case 'gt':
								results = results.filter((item: any) => item[field] > value);
								break;
							case 'gte':
								results = results.filter((item: any) => item[field] >= value);
								break;
							case 'lt':
								results = results.filter((item: any) => item[field] < value);
								break;
							case 'lte':
								results = results.filter((item: any) => item[field] <= value);
								break;
							case 'contains':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().includes(String(value).toLowerCase())
								);
								break;
							case 'startsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().startsWith(String(value).toLowerCase())
								);
								break;
							case 'endsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().endsWith(String(value).toLowerCase())
								);
								break;
							case 'in':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => value.includes(item[field]));
								}
								break;
							case 'notIn':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => !value.includes(item[field]));
								}
								break;
						}
					}
				}
			}

			// Apply search (on array)
			if (query?.search) {
				const searchLower = query.search.toLowerCase();
				results = results.filter((item: any) =>
					Object.values(item).some(val =>
						typeof val === 'string' && val.toLowerCase().includes(searchLower)
					)
				);
			}

			// Apply sorting
			if (query?.sorts) {
				try {
					const sortFields = JSON.parse(query.sorts);
					if (Array.isArray(sortFields) && sortFields.length > 0) {
						results.sort((a: any, b: any) => {
							for (const sort of sortFields) {
								const { field, dir } = sort;
								const aVal = a[field];
								const bVal = b[field];
								if (aVal === bVal) continue;
								const comparison = aVal < bVal ? -1 : 1;
								return dir === 'desc' ? -comparison : comparison;
							}
							return 0;
						}
						);
					}
				} catch {
					// Invalid sorts format, skip
				}
			}

			// Apply pagination
			if (query?.page && query?.take) {
				const skip = (query.page - 1) * query.take;
				results = results.slice(skip, skip + query.take);
			} else if (query?.take) {
				results = results.slice(0, query.take);
			}

			return results as Section[];
		}
		const response = await apiClient.sectionControllerFindAll(query);
		return (response.data as any) || [];
	},

	/**
	 * Create a new Section
	 * @param section - The Section data to create
	 * @returns Promise<Section>
	 */
	async sectionControllerCreate(section: Section): Promise<Section> {
		if (getMode() === WorkMode.OFFLINE) {
			await db.Classification_Section.add(section);
			const result = await db.Classification_Section.get(section.SectionId);
			if (!result) {
				throw new Error(`Failed to create Section: ${section.SectionId}`);
			}
			return result;
		}
		return (await apiClient.sectionControllerCreate(section)).data;
	},

	/**
	 * Update a Section
	 * @param sectionId - The SectionId to update
	 * @param section - The updated Section data
	 * @returns Promise<Section>
	 */
	async sectionControllerUpdate(sectionId: string, section: Section): Promise<Section> {
		if (getMode() === WorkMode.OFFLINE) {
			const numAffected = await db.Classification_Section.update(sectionId, section as any);
			let result;
			if (numAffected > 0) {
				result = await db.Classification_Section.get(sectionId);
			}
			if (!result) {
				throw new Error(`Section not found: ${sectionId}`);
			}
			return result;
		}
		return (await apiClient.sectionControllerUpdate(sectionId, section)).data;
	},

	/**
	 * Remove (soft delete) a Section
	 * Calls the API Remove endpoint which sets ActiveInd to false
	 * @param sectionId - The SectionId to remove
	 * @param section - The Section data
	 * @returns Promise<Section>
	 */
	async sectionControllerRemove(sectionId: string, section: Section): Promise<Section> {
		if (getMode() === WorkMode.OFFLINE) {
			// In offline mode, soft delete by updating ActiveInd
			const numAffected = await db.Classification_Section.update(sectionId, { ...section, ActiveInd: false });
			let result;
			if (numAffected > 0) {
				result = await db.Classification_Section.get(sectionId);
			}
			if (!result) {
				throw new Error(`Section not found: ${sectionId}`);
			}
			return result;
		}
		// In online mode, call the API's Remove endpoint
		return (await apiClient.sectionControllerUpdate(sectionId, { ...section, ActiveInd: false })).data;
	},

	/**
	 * Find a single SubTarget by ID
	 * @param subTargetId - The SubTargetId to find
	 * @returns Promise<SubTarget>
	 */
	async subTargetControllerFindOne(subTargetId: string): Promise<SubTarget> {
		if (getMode() === WorkMode.OFFLINE) {
			const result = await db.Classification_SubTarget.get(subTargetId);
			if (!result) {
				throw new Error(`SubTarget not found: ${subTargetId}`);
			}
			return result;
		}
		return (await apiClient.subTargetControllerFindOne(subTargetId)).data;
	},

	/**
	 * Find all SubTarget records with optional filtering
	 * @param query - Optional query parameters for filtering, pagination, etc.
	 * @returns Promise<SubTarget[]>
	 */
	async subTargetControllerFindAll(query?: {
		page?: number;
		take?: number;
		order?: "ASC" | "DESC";
		search?: string;
		filters?: string | FilterInput;
		sorts?: string;
	}): Promise<SubTarget[]> {
		if (getMode() === WorkMode.OFFLINE) {
			let collection = db.Classification_SubTarget.toCollection();

			// Get results as array
			let results = await collection.toArray();

			// Apply ALL filters on array
			if (query?.filters) {
				const filters = parseFiltersForDexie(query.filters);
				if (filters.length > 0) {
					for (const filter of filters) {
						const { field, op, value } = filter;
						switch (op) {
							case 'eq':
								results = results.filter((item: any) => item[field] === value);
								break;
							case 'neq':
								results = results.filter((item: any) => item[field] !== value);
								break;
							case 'gt':
								results = results.filter((item: any) => item[field] > value);
								break;
							case 'gte':
								results = results.filter((item: any) => item[field] >= value);
								break;
							case 'lt':
								results = results.filter((item: any) => item[field] < value);
								break;
							case 'lte':
								results = results.filter((item: any) => item[field] <= value);
								break;
							case 'contains':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().includes(String(value).toLowerCase())
								);
								break;
							case 'startsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().startsWith(String(value).toLowerCase())
								);
								break;
							case 'endsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().endsWith(String(value).toLowerCase())
								);
								break;
							case 'in':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => value.includes(item[field]));
								}
								break;
							case 'notIn':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => !value.includes(item[field]));
								}
								break;
						}
					}
				}
			}

			// Apply search (on array)
			if (query?.search) {
				const searchLower = query.search.toLowerCase();
				results = results.filter((item: any) =>
					Object.values(item).some(val =>
						typeof val === 'string' && val.toLowerCase().includes(searchLower)
					)
				);
			}

			// Apply sorting
			if (query?.sorts) {
				try {
					const sortFields = JSON.parse(query.sorts);
					if (Array.isArray(sortFields) && sortFields.length > 0) {
						results.sort((a: any, b: any) => {
							for (const sort of sortFields) {
								const { field, dir } = sort;
								const aVal = a[field];
								const bVal = b[field];
								if (aVal === bVal) continue;
								const comparison = aVal < bVal ? -1 : 1;
								return dir === 'desc' ? -comparison : comparison;
							}
							return 0;
						}
						);
					}
				} catch {
					// Invalid sorts format, skip
				}
			}

			// Apply pagination
			if (query?.page && query?.take) {
				const skip = (query.page - 1) * query.take;
				results = results.slice(skip, skip + query.take);
			} else if (query?.take) {
				results = results.slice(0, query.take);
			}

			return results as SubTarget[];
		}
		const response = await apiClient.subTargetControllerFindAll(query);
		return (response.data as any) || [];
	},

	/**
	 * Create a new SubTarget
	 * @param subTarget - The SubTarget data to create
	 * @returns Promise<SubTarget>
	 */
	async subTargetControllerCreate(subTarget: SubTarget): Promise<SubTarget> {
		if (getMode() === WorkMode.OFFLINE) {
			await db.Classification_SubTarget.add(subTarget);
			const result = await db.Classification_SubTarget.get(subTarget.SubTargetId);
			if (!result) {
				throw new Error(`Failed to create SubTarget: ${subTarget.SubTargetId}`);
			}
			return result;
		}
		return (await apiClient.subTargetControllerCreate(subTarget)).data;
	},

	/**
	 * Update a SubTarget
	 * @param subTargetId - The SubTargetId to update
	 * @param subTarget - The updated SubTarget data
	 * @returns Promise<SubTarget>
	 */
	async subTargetControllerUpdate(subTargetId: string, subTarget: SubTarget): Promise<SubTarget> {
		if (getMode() === WorkMode.OFFLINE) {
			const numAffected = await db.Classification_SubTarget.update(subTargetId, subTarget as any);
			let result;
			if (numAffected > 0) {
				result = await db.Classification_SubTarget.get(subTargetId);
			}
			if (!result) {
				throw new Error(`SubTarget not found: ${subTargetId}`);
			}
			return result;
		}
		return (await apiClient.subTargetControllerUpdate(subTargetId, subTarget)).data;
	},

	/**
	 * Remove (soft delete) a SubTarget
	 * Calls the API Remove endpoint which sets ActiveInd to false
	 * @param subTargetId - The SubTargetId to remove
	 * @param subTarget - The SubTarget data
	 * @returns Promise<SubTarget>
	 */
	async subTargetControllerRemove(subTargetId: string, subTarget: SubTarget): Promise<SubTarget> {
		if (getMode() === WorkMode.OFFLINE) {
			// In offline mode, soft delete by updating ActiveInd
			const numAffected = await db.Classification_SubTarget.update(subTargetId, { ...subTarget, ActiveInd: false });
			let result;
			if (numAffected > 0) {
				result = await db.Classification_SubTarget.get(subTargetId);
			}
			if (!result) {
				throw new Error(`SubTarget not found: ${subTargetId}`);
			}
			return result;
		}
		// In online mode, call the API's Remove endpoint
		return (await apiClient.subTargetControllerUpdate(subTargetId, { ...subTarget, ActiveInd: false })).data;
	},

	/**
	 * Find a single Target by ID
	 * @param targetId - The TargetId to find
	 * @returns Promise<Target>
	 */
	async targetControllerFindOne(targetId: string): Promise<Target> {
		if (getMode() === WorkMode.OFFLINE) {
			const result = await db.Classification_Target.get(targetId);
			if (!result) {
				throw new Error(`Target not found: ${targetId}`);
			}
			return result;
		}
		return (await apiClient.targetControllerFindOne(targetId)).data;
	},

	/**
	 * Find all Target records with optional filtering
	 * @param query - Optional query parameters for filtering, pagination, etc.
	 * @returns Promise<Target[]>
	 */
	async targetControllerFindAll(query?: {
		page?: number;
		take?: number;
		order?: "ASC" | "DESC";
		search?: string;
		filters?: string | FilterInput;
		sorts?: string;
	}): Promise<Target[]> {
		if (getMode() === WorkMode.OFFLINE) {
			let collection = db.Classification_Target.toCollection();

			// Get results as array
			let results = await collection.toArray();

			// Apply ALL filters on array
			if (query?.filters) {
				const filters = parseFiltersForDexie(query.filters);
				if (filters.length > 0) {
					for (const filter of filters) {
						const { field, op, value } = filter;
						switch (op) {
							case 'eq':
								results = results.filter((item: any) => item[field] === value);
								break;
							case 'neq':
								results = results.filter((item: any) => item[field] !== value);
								break;
							case 'gt':
								results = results.filter((item: any) => item[field] > value);
								break;
							case 'gte':
								results = results.filter((item: any) => item[field] >= value);
								break;
							case 'lt':
								results = results.filter((item: any) => item[field] < value);
								break;
							case 'lte':
								results = results.filter((item: any) => item[field] <= value);
								break;
							case 'contains':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().includes(String(value).toLowerCase())
								);
								break;
							case 'startsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().startsWith(String(value).toLowerCase())
								);
								break;
							case 'endsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().endsWith(String(value).toLowerCase())
								);
								break;
							case 'in':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => value.includes(item[field]));
								}
								break;
							case 'notIn':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => !value.includes(item[field]));
								}
								break;
						}
					}
				}
			}

			// Apply search (on array)
			if (query?.search) {
				const searchLower = query.search.toLowerCase();
				results = results.filter((item: any) =>
					Object.values(item).some(val =>
						typeof val === 'string' && val.toLowerCase().includes(searchLower)
					)
				);
			}

			// Apply sorting
			if (query?.sorts) {
				try {
					const sortFields = JSON.parse(query.sorts);
					if (Array.isArray(sortFields) && sortFields.length > 0) {
						results.sort((a: any, b: any) => {
							for (const sort of sortFields) {
								const { field, dir } = sort;
								const aVal = a[field];
								const bVal = b[field];
								if (aVal === bVal) continue;
								const comparison = aVal < bVal ? -1 : 1;
								return dir === 'desc' ? -comparison : comparison;
							}
							return 0;
						}
						);
					}
				} catch {
					// Invalid sorts format, skip
				}
			}

			// Apply pagination
			if (query?.page && query?.take) {
				const skip = (query.page - 1) * query.take;
				results = results.slice(skip, skip + query.take);
			} else if (query?.take) {
				results = results.slice(0, query.take);
			}

			return results as Target[];
		}
		const response = await apiClient.targetControllerFindAll(query);
		return (response.data as any) || [];
	},

	/**
	 * Create a new Target
	 * @param target - The Target data to create
	 * @returns Promise<Target>
	 */
	async targetControllerCreate(target: Target): Promise<Target> {
		if (getMode() === WorkMode.OFFLINE) {
			await db.Classification_Target.add(target);
			const result = await db.Classification_Target.get(target.TargetId);
			if (!result) {
				throw new Error(`Failed to create Target: ${target.TargetId}`);
			}
			return result;
		}
		return (await apiClient.targetControllerCreate(target)).data;
	},

	/**
	 * Update a Target
	 * @param targetId - The TargetId to update
	 * @param target - The updated Target data
	 * @returns Promise<Target>
	 */
	async targetControllerUpdate(targetId: string, target: Target): Promise<Target> {
		if (getMode() === WorkMode.OFFLINE) {
			const numAffected = await db.Classification_Target.update(targetId, target as any);
			let result;
			if (numAffected > 0) {
				result = await db.Classification_Target.get(targetId);
			}
			if (!result) {
				throw new Error(`Target not found: ${targetId}`);
			}
			return result;
		}
		return (await apiClient.targetControllerUpdate(targetId, target)).data;
	},

	/**
	 * Remove (soft delete) a Target
	 * Calls the API Remove endpoint which sets ActiveInd to false
	 * @param targetId - The TargetId to remove
	 * @param target - The Target data
	 * @returns Promise<Target>
	 */
	async targetControllerRemove(targetId: string, target: Target): Promise<Target> {
		if (getMode() === WorkMode.OFFLINE) {
			// In offline mode, soft delete by updating ActiveInd
			const numAffected = await db.Classification_Target.update(targetId, { ...target, ActiveInd: false });
			let result;
			if (numAffected > 0) {
				result = await db.Classification_Target.get(targetId);
			}
			if (!result) {
				throw new Error(`Target not found: ${targetId}`);
			}
			return result;
		}
		// In online mode, call the API's Remove endpoint
		return (await apiClient.targetControllerUpdate(targetId, { ...target, ActiveInd: false })).data;
	},

	/**
	 * Find a single Tenement by ID
	 * @param tenementId - The TenementId to find
	 * @returns Promise<Tenement>
	 */
	async tenementControllerFindOne(tenementId: string): Promise<Tenement> {
		if (getMode() === WorkMode.OFFLINE) {
			const result = await db.Classification_Tenement.get(tenementId);
			if (!result) {
				throw new Error(`Tenement not found: ${tenementId}`);
			}
			return result;
		}
		return (await apiClient.tenementControllerFindOne(tenementId)).data;
	},

	/**
	 * Find all Tenement records with optional filtering
	 * @param query - Optional query parameters for filtering, pagination, etc.
	 * @returns Promise<Tenement[]>
	 */
	async tenementControllerFindAll(query?: {
		page?: number;
		take?: number;
		order?: "ASC" | "DESC";
		search?: string;
		filters?: string | FilterInput;
		sorts?: string;
	}): Promise<Tenement[]> {
		if (getMode() === WorkMode.OFFLINE) {
			let collection = db.Classification_Tenement.toCollection();

			// Get results as array
			let results = await collection.toArray();

			// Apply ALL filters on array
			if (query?.filters) {
				const filters = parseFiltersForDexie(query.filters);
				if (filters.length > 0) {
					for (const filter of filters) {
						const { field, op, value } = filter;
						switch (op) {
							case 'eq':
								results = results.filter((item: any) => item[field] === value);
								break;
							case 'neq':
								results = results.filter((item: any) => item[field] !== value);
								break;
							case 'gt':
								results = results.filter((item: any) => item[field] > value);
								break;
							case 'gte':
								results = results.filter((item: any) => item[field] >= value);
								break;
							case 'lt':
								results = results.filter((item: any) => item[field] < value);
								break;
							case 'lte':
								results = results.filter((item: any) => item[field] <= value);
								break;
							case 'contains':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().includes(String(value).toLowerCase())
								);
								break;
							case 'startsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().startsWith(String(value).toLowerCase())
								);
								break;
							case 'endsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().endsWith(String(value).toLowerCase())
								);
								break;
							case 'in':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => value.includes(item[field]));
								}
								break;
							case 'notIn':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => !value.includes(item[field]));
								}
								break;
						}
					}
				}
			}

			// Apply search (on array)
			if (query?.search) {
				const searchLower = query.search.toLowerCase();
				results = results.filter((item: any) =>
					Object.values(item).some(val =>
						typeof val === 'string' && val.toLowerCase().includes(searchLower)
					)
				);
			}

			// Apply sorting
			if (query?.sorts) {
				try {
					const sortFields = JSON.parse(query.sorts);
					if (Array.isArray(sortFields) && sortFields.length > 0) {
						results.sort((a: any, b: any) => {
							for (const sort of sortFields) {
								const { field, dir } = sort;
								const aVal = a[field];
								const bVal = b[field];
								if (aVal === bVal) continue;
								const comparison = aVal < bVal ? -1 : 1;
								return dir === 'desc' ? -comparison : comparison;
							}
							return 0;
						}
						);
					}
				} catch {
					// Invalid sorts format, skip
				}
			}

			// Apply pagination
			if (query?.page && query?.take) {
				const skip = (query.page - 1) * query.take;
				results = results.slice(skip, skip + query.take);
			} else if (query?.take) {
				results = results.slice(0, query.take);
			}

			return results as Tenement[];
		}
		const response = await apiClient.tenementControllerFindAll(query);
		return (response.data as any) || [];
	},

	/**
	 * Create a new Tenement
	 * @param tenement - The Tenement data to create
	 * @returns Promise<Tenement>
	 */
	async tenementControllerCreate(tenement: Tenement): Promise<Tenement> {
		if (getMode() === WorkMode.OFFLINE) {
			await db.Classification_Tenement.add(tenement);
			const result = await db.Classification_Tenement.get(tenement.TenementId);
			if (!result) {
				throw new Error(`Failed to create Tenement: ${tenement.TenementId}`);
			}
			return result;
		}
		return (await apiClient.tenementControllerCreate(tenement)).data;
	},

	/**
	 * Update a Tenement
	 * @param tenementId - The TenementId to update
	 * @param tenement - The updated Tenement data
	 * @returns Promise<Tenement>
	 */
	async tenementControllerUpdate(tenementId: string, tenement: Tenement): Promise<Tenement> {
		if (getMode() === WorkMode.OFFLINE) {
			const numAffected = await db.Classification_Tenement.update(tenementId, tenement as any);
			let result;
			if (numAffected > 0) {
				result = await db.Classification_Tenement.get(tenementId);
			}
			if (!result) {
				throw new Error(`Tenement not found: ${tenementId}`);
			}
			return result;
		}
		return (await apiClient.tenementControllerUpdate(tenementId, tenement)).data;
	},

	/**
	 * Remove (soft delete) a Tenement
	 * Calls the API Remove endpoint which sets ActiveInd to false
	 * @param tenementId - The TenementId to remove
	 * @param tenement - The Tenement data
	 * @returns Promise<Tenement>
	 */
	async tenementControllerRemove(tenementId: string, tenement: Tenement): Promise<Tenement> {
		if (getMode() === WorkMode.OFFLINE) {
			// In offline mode, soft delete by updating ActiveInd
			const numAffected = await db.Classification_Tenement.update(tenementId, { ...tenement, ActiveInd: false });
			let result;
			if (numAffected > 0) {
				result = await db.Classification_Tenement.get(tenementId);
			}
			if (!result) {
				throw new Error(`Tenement not found: ${tenementId}`);
			}
			return result;
		}
		// In online mode, call the API's Remove endpoint
		return (await apiClient.tenementControllerUpdate(tenementId, { ...tenement, ActiveInd: false })).data;
	},

	/**
	 * Find a single Zone by ID
	 * @param zoneId - The ZoneId to find
	 * @returns Promise<Zone>
	 */
	async zoneControllerFindOne(zoneId: string): Promise<Zone> {
		if (getMode() === WorkMode.OFFLINE) {
			const result = await db.Classification_Zone.get(zoneId);
			if (!result) {
				throw new Error(`Zone not found: ${zoneId}`);
			}
			return result;
		}
		return (await apiClient.zoneControllerFindOne(zoneId)).data;
	},

	/**
	 * Find all Zone records with optional filtering
	 * @param query - Optional query parameters for filtering, pagination, etc.
	 * @returns Promise<Zone[]>
	 */
	async zoneControllerFindAll(query?: {
		page?: number;
		take?: number;
		order?: "ASC" | "DESC";
		search?: string;
		filters?: string | FilterInput;
		sorts?: string;
	}): Promise<Zone[]> {
		if (getMode() === WorkMode.OFFLINE) {
			let collection = db.Classification_Zone.toCollection();

			// Get results as array
			let results = await collection.toArray();

			// Apply ALL filters on array
			if (query?.filters) {
				const filters = parseFiltersForDexie(query.filters);
				if (filters.length > 0) {
					for (const filter of filters) {
						const { field, op, value } = filter;
						switch (op) {
							case 'eq':
								results = results.filter((item: any) => item[field] === value);
								break;
							case 'neq':
								results = results.filter((item: any) => item[field] !== value);
								break;
							case 'gt':
								results = results.filter((item: any) => item[field] > value);
								break;
							case 'gte':
								results = results.filter((item: any) => item[field] >= value);
								break;
							case 'lt':
								results = results.filter((item: any) => item[field] < value);
								break;
							case 'lte':
								results = results.filter((item: any) => item[field] <= value);
								break;
							case 'contains':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().includes(String(value).toLowerCase())
								);
								break;
							case 'startsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().startsWith(String(value).toLowerCase())
								);
								break;
							case 'endsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().endsWith(String(value).toLowerCase())
								);
								break;
							case 'in':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => value.includes(item[field]));
								}
								break;
							case 'notIn':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => !value.includes(item[field]));
								}
								break;
						}
					}
				}
			}

			// Apply search (on array)
			if (query?.search) {
				const searchLower = query.search.toLowerCase();
				results = results.filter((item: any) =>
					Object.values(item).some(val =>
						typeof val === 'string' && val.toLowerCase().includes(searchLower)
					)
				);
			}

			// Apply sorting
			if (query?.sorts) {
				try {
					const sortFields = JSON.parse(query.sorts);
					if (Array.isArray(sortFields) && sortFields.length > 0) {
						results.sort((a: any, b: any) => {
							for (const sort of sortFields) {
								const { field, dir } = sort;
								const aVal = a[field];
								const bVal = b[field];
								if (aVal === bVal) continue;
								const comparison = aVal < bVal ? -1 : 1;
								return dir === 'desc' ? -comparison : comparison;
							}
							return 0;
						}
						);
					}
				} catch {
					// Invalid sorts format, skip
				}
			}

			// Apply pagination
			if (query?.page && query?.take) {
				const skip = (query.page - 1) * query.take;
				results = results.slice(skip, skip + query.take);
			} else if (query?.take) {
				results = results.slice(0, query.take);
			}

			return results as Zone[];
		}
		const response = await apiClient.zoneControllerFindAll(query);
		return (response.data as any) || [];
	},

	/**
	 * Create a new Zone
	 * @param zone - The Zone data to create
	 * @returns Promise<Zone>
	 */
	async zoneControllerCreate(zone: Zone): Promise<Zone> {
		if (getMode() === WorkMode.OFFLINE) {
			await db.Classification_Zone.add(zone);
			const result = await db.Classification_Zone.get(zone.ZoneId);
			if (!result) {
				throw new Error(`Failed to create Zone: ${zone.ZoneId}`);
			}
			return result;
		}
		return (await apiClient.zoneControllerCreate(zone)).data;
	},

	/**
	 * Update a Zone
	 * @param zoneId - The ZoneId to update
	 * @param zone - The updated Zone data
	 * @returns Promise<Zone>
	 */
	async zoneControllerUpdate(zoneId: string, zone: Zone): Promise<Zone> {
		if (getMode() === WorkMode.OFFLINE) {
			const numAffected = await db.Classification_Zone.update(zoneId, zone as any);
			let result;
			if (numAffected > 0) {
				result = await db.Classification_Zone.get(zoneId);
			}
			if (!result) {
				throw new Error(`Zone not found: ${zoneId}`);
			}
			return result;
		}
		return (await apiClient.zoneControllerUpdate(zoneId, zone)).data;
	},

	/**
	 * Remove (soft delete) a Zone
	 * Calls the API Remove endpoint which sets ActiveInd to false
	 * @param zoneId - The ZoneId to remove
	 * @param zone - The Zone data
	 * @returns Promise<Zone>
	 */
	async zoneControllerRemove(zoneId: string, zone: Zone): Promise<Zone> {
		if (getMode() === WorkMode.OFFLINE) {
			// In offline mode, soft delete by updating ActiveInd
			const numAffected = await db.Classification_Zone.update(zoneId, { ...zone, ActiveInd: false });
			let result;
			if (numAffected > 0) {
				result = await db.Classification_Zone.get(zoneId);
			}
			if (!result) {
				throw new Error(`Zone not found: ${zoneId}`);
			}
			return result;
		}
		// In online mode, call the API's Remove endpoint
		return (await apiClient.zoneControllerUpdate(zoneId, { ...zone, ActiveInd: false })).data;
	},

	/**
	 * Find a single DrillPattern by ID
	 * @param drillPatternId - The DrillPatternId to find
	 * @returns Promise<DrillPattern>
	 */
	async drillPatternControllerFindOne(drillPatternId: string): Promise<DrillPattern> {
		if (getMode() === WorkMode.OFFLINE) {
			const result = await db.Planning_DrillPattern.get(drillPatternId);
			if (!result) {
				throw new Error(`DrillPattern not found: ${drillPatternId}`);
			}
			return result;
		}
		return (await apiClient.drillPatternControllerFindOne(drillPatternId)).data;
	},

	/**
	 * Find all DrillPattern records with optional filtering
	 * @param query - Optional query parameters for filtering, pagination, etc.
	 * @returns Promise<DrillPattern[]>
	 */
	async drillPatternControllerFindAll(query?: {
		page?: number;
		take?: number;
		order?: "ASC" | "DESC";
		search?: string;
		filters?: string | FilterInput;
		sorts?: string;
	}): Promise<DrillPattern[]> {
		if (getMode() === WorkMode.OFFLINE) {
			let collection = db.Planning_DrillPattern.toCollection();

			// Get results as array
			let results = await collection.toArray();

			// Apply ALL filters on array
			if (query?.filters) {
				const filters = parseFiltersForDexie(query.filters);
				if (filters.length > 0) {
					for (const filter of filters) {
						const { field, op, value } = filter;
						switch (op) {
							case 'eq':
								results = results.filter((item: any) => item[field] === value);
								break;
							case 'neq':
								results = results.filter((item: any) => item[field] !== value);
								break;
							case 'gt':
								results = results.filter((item: any) => item[field] > value);
								break;
							case 'gte':
								results = results.filter((item: any) => item[field] >= value);
								break;
							case 'lt':
								results = results.filter((item: any) => item[field] < value);
								break;
							case 'lte':
								results = results.filter((item: any) => item[field] <= value);
								break;
							case 'contains':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().includes(String(value).toLowerCase())
								);
								break;
							case 'startsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().startsWith(String(value).toLowerCase())
								);
								break;
							case 'endsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().endsWith(String(value).toLowerCase())
								);
								break;
							case 'in':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => value.includes(item[field]));
								}
								break;
							case 'notIn':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => !value.includes(item[field]));
								}
								break;
						}
					}
				}
			}

			// Apply search (on array)
			if (query?.search) {
				const searchLower = query.search.toLowerCase();
				results = results.filter((item: any) =>
					Object.values(item).some(val =>
						typeof val === 'string' && val.toLowerCase().includes(searchLower)
					)
				);
			}

			// Apply sorting
			if (query?.sorts) {
				try {
					const sortFields = JSON.parse(query.sorts);
					if (Array.isArray(sortFields) && sortFields.length > 0) {
						results.sort((a: any, b: any) => {
							for (const sort of sortFields) {
								const { field, dir } = sort;
								const aVal = a[field];
								const bVal = b[field];
								if (aVal === bVal) continue;
								const comparison = aVal < bVal ? -1 : 1;
								return dir === 'desc' ? -comparison : comparison;
							}
							return 0;
						}
						);
					}
				} catch {
					// Invalid sorts format, skip
				}
			}

			// Apply pagination
			if (query?.page && query?.take) {
				const skip = (query.page - 1) * query.take;
				results = results.slice(skip, skip + query.take);
			} else if (query?.take) {
				results = results.slice(0, query.take);
			}

			return results as DrillPattern[];
		}
		const response = await apiClient.drillPatternControllerFindAll(query);
		return (response.data as any) || [];
	},

	/**
	 * Create a new DrillPattern
	 * @param drillPattern - The DrillPattern data to create
	 * @returns Promise<DrillPattern>
	 */
	async drillPatternControllerCreate(drillPattern: DrillPattern): Promise<DrillPattern> {
		if (getMode() === WorkMode.OFFLINE) {
			await db.Planning_DrillPattern.add(drillPattern);
			const result = await db.Planning_DrillPattern.get(drillPattern.DrillPatternId);
			if (!result) {
				throw new Error(`Failed to create DrillPattern: ${drillPattern.DrillPatternId}`);
			}
			return result;
		}
		return (await apiClient.drillPatternControllerCreate(drillPattern)).data;
	},

	/**
	 * Update a DrillPattern
	 * @param drillPatternId - The DrillPatternId to update
	 * @param drillPattern - The updated DrillPattern data
	 * @returns Promise<DrillPattern>
	 */
	async drillPatternControllerUpdate(drillPatternId: string, drillPattern: DrillPattern): Promise<DrillPattern> {
		if (getMode() === WorkMode.OFFLINE) {
			const numAffected = await db.Planning_DrillPattern.update(drillPatternId, drillPattern as any);
			let result;
			if (numAffected > 0) {
				result = await db.Planning_DrillPattern.get(drillPatternId);
			}
			if (!result) {
				throw new Error(`DrillPattern not found: ${drillPatternId}`);
			}
			return result;
		}
		return (await apiClient.drillPatternControllerUpdate(drillPatternId, drillPattern)).data;
	},

	/**
	 * Remove (soft delete) a DrillPattern
	 * Calls the API Remove endpoint which sets ActiveInd to false
	 * @param drillPatternId - The DrillPatternId to remove
	 * @param drillPattern - The DrillPattern data
	 * @returns Promise<DrillPattern>
	 */
	async drillPatternControllerRemove(drillPatternId: string, drillPattern: DrillPattern): Promise<DrillPattern> {
		if (getMode() === WorkMode.OFFLINE) {
			// In offline mode, soft delete by updating ActiveInd
			const numAffected = await db.Planning_DrillPattern.update(drillPatternId, { ...drillPattern, ActiveInd: false });
			let result;
			if (numAffected > 0) {
				result = await db.Planning_DrillPattern.get(drillPatternId);
			}
			if (!result) {
				throw new Error(`DrillPattern not found: ${drillPatternId}`);
			}
			return result;
		}
		// In online mode, call the API's Remove endpoint
		return (await apiClient.drillPatternControllerUpdate(drillPatternId, { ...drillPattern, ActiveInd: false })).data;
	},

	/**
	 * Find a single DrillPlanStatusHistory by ID
	 * @param drillPlanStatusHistoryId - The DrillPlanStatusHistoryId to find
	 * @returns Promise<DrillPlanStatusHistory>
	 */
	async drillPlanStatusHistoryControllerFindOne(drillPlanStatusHistoryId: string): Promise<DrillPlanStatusHistory> {
		if (getMode() === WorkMode.OFFLINE) {
			const result = await db.Planning_DrillPlanStatusHistory.get(drillPlanStatusHistoryId);
			if (!result) {
				throw new Error(`DrillPlanStatusHistory not found: ${drillPlanStatusHistoryId}`);
			}
			return result;
		}
		return (await apiClient.drillPlanStatusHistoryControllerFindOne(drillPlanStatusHistoryId)).data;
	},

	/**
	 * Find all DrillPlanStatusHistory records with optional filtering
	 * @param query - Optional query parameters for filtering, pagination, etc.
	 * @returns Promise<DrillPlanStatusHistory[]>
	 */
	async drillPlanStatusHistoryControllerFindAll(query?: {
		page?: number;
		take?: number;
		order?: "ASC" | "DESC";
		search?: string;
		filters?: string | FilterInput;
		sorts?: string;
	}): Promise<DrillPlanStatusHistory[]> {
		if (getMode() === WorkMode.OFFLINE) {
			let collection = db.Planning_DrillPlanStatusHistory.toCollection();

			// Get results as array
			let results = await collection.toArray();

			// Apply ALL filters on array
			if (query?.filters) {
				const filters = parseFiltersForDexie(query.filters);
				if (filters.length > 0) {
					for (const filter of filters) {
						const { field, op, value } = filter;
						switch (op) {
							case 'eq':
								results = results.filter((item: any) => item[field] === value);
								break;
							case 'neq':
								results = results.filter((item: any) => item[field] !== value);
								break;
							case 'gt':
								results = results.filter((item: any) => item[field] > value);
								break;
							case 'gte':
								results = results.filter((item: any) => item[field] >= value);
								break;
							case 'lt':
								results = results.filter((item: any) => item[field] < value);
								break;
							case 'lte':
								results = results.filter((item: any) => item[field] <= value);
								break;
							case 'contains':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().includes(String(value).toLowerCase())
								);
								break;
							case 'startsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().startsWith(String(value).toLowerCase())
								);
								break;
							case 'endsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().endsWith(String(value).toLowerCase())
								);
								break;
							case 'in':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => value.includes(item[field]));
								}
								break;
							case 'notIn':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => !value.includes(item[field]));
								}
								break;
						}
					}
				}
			}

			// Apply search (on array)
			if (query?.search) {
				const searchLower = query.search.toLowerCase();
				results = results.filter((item: any) =>
					Object.values(item).some(val =>
						typeof val === 'string' && val.toLowerCase().includes(searchLower)
					)
				);
			}

			// Apply sorting
			if (query?.sorts) {
				try {
					const sortFields = JSON.parse(query.sorts);
					if (Array.isArray(sortFields) && sortFields.length > 0) {
						results.sort((a: any, b: any) => {
							for (const sort of sortFields) {
								const { field, dir } = sort;
								const aVal = a[field];
								const bVal = b[field];
								if (aVal === bVal) continue;
								const comparison = aVal < bVal ? -1 : 1;
								return dir === 'desc' ? -comparison : comparison;
							}
							return 0;
						}
						);
					}
				} catch {
					// Invalid sorts format, skip
				}
			}

			// Apply pagination
			if (query?.page && query?.take) {
				const skip = (query.page - 1) * query.take;
				results = results.slice(skip, skip + query.take);
			} else if (query?.take) {
				results = results.slice(0, query.take);
			}

			return results as DrillPlanStatusHistory[];
		}
		const response = await apiClient.drillPlanStatusHistoryControllerFindAll(query);
		return (response.data as any) || [];
	},

	/**
	 * Create a new DrillPlanStatusHistory
	 * @param drillPlanStatusHistory - The DrillPlanStatusHistory data to create
	 * @returns Promise<DrillPlanStatusHistory>
	 */
	async drillPlanStatusHistoryControllerCreate(drillPlanStatusHistory: DrillPlanStatusHistory): Promise<DrillPlanStatusHistory> {
		if (getMode() === WorkMode.OFFLINE) {
			await db.Planning_DrillPlanStatusHistory.add(drillPlanStatusHistory);
			const result = await db.Planning_DrillPlanStatusHistory.get(drillPlanStatusHistory.DrillPlanStatusHistoryId);
			if (!result) {
				throw new Error(`Failed to create DrillPlanStatusHistory: ${drillPlanStatusHistory.DrillPlanStatusHistoryId}`);
			}
			return result;
		}
		return (await apiClient.drillPlanStatusHistoryControllerCreate(drillPlanStatusHistory)).data;
	},

	/**
	 * Update a DrillPlanStatusHistory
	 * @param drillPlanStatusHistoryId - The DrillPlanStatusHistoryId to update
	 * @param drillPlanStatusHistory - The updated DrillPlanStatusHistory data
	 * @returns Promise<DrillPlanStatusHistory>
	 */
	async drillPlanStatusHistoryControllerUpdate(drillPlanStatusHistoryId: string, drillPlanStatusHistory: DrillPlanStatusHistory): Promise<DrillPlanStatusHistory> {
		if (getMode() === WorkMode.OFFLINE) {
			const numAffected = await db.Planning_DrillPlanStatusHistory.update(drillPlanStatusHistoryId, drillPlanStatusHistory as any);
			let result;
			if (numAffected > 0) {
				result = await db.Planning_DrillPlanStatusHistory.get(drillPlanStatusHistoryId);
			}
			if (!result) {
				throw new Error(`DrillPlanStatusHistory not found: ${drillPlanStatusHistoryId}`);
			}
			return result;
		}
		return (await apiClient.drillPlanStatusHistoryControllerUpdate(drillPlanStatusHistoryId, drillPlanStatusHistory)).data;
	},

	/**
	 * Remove (soft delete) a DrillPlanStatusHistory
	 * Calls the API Remove endpoint which sets ActiveInd to false
	 * @param drillPlanStatusHistoryId - The DrillPlanStatusHistoryId to remove
	 * @param drillPlanStatusHistory - The DrillPlanStatusHistory data
	 * @returns Promise<DrillPlanStatusHistory>
	 */
	async drillPlanStatusHistoryControllerRemove(drillPlanStatusHistoryId: string, drillPlanStatusHistory: DrillPlanStatusHistory): Promise<DrillPlanStatusHistory> {
		if (getMode() === WorkMode.OFFLINE) {
			// In offline mode, soft delete by updating ActiveInd
			const numAffected = await db.Planning_DrillPlanStatusHistory.update(drillPlanStatusHistoryId, { ...drillPlanStatusHistory, ActiveInd: false });
			let result;
			if (numAffected > 0) {
				result = await db.Planning_DrillPlanStatusHistory.get(drillPlanStatusHistoryId);
			}
			if (!result) {
				throw new Error(`DrillPlanStatusHistory not found: ${drillPlanStatusHistoryId}`);
			}
			return result;
		}
		// In online mode, call the API's Remove endpoint
		return (await apiClient.drillPlanStatusHistoryControllerUpdate(drillPlanStatusHistoryId, { ...drillPlanStatusHistory, ActiveInd: false })).data;
	},

	/**
	 * Find a single DrillProgram by ID
	 * @param drillProgramId - The DrillProgramId to find
	 * @returns Promise<DrillProgram>
	 */
	async drillProgramControllerFindOne(drillProgramId: string): Promise<DrillProgram> {
		if (getMode() === WorkMode.OFFLINE) {
			const result = await db.Planning_DrillProgram.get(drillProgramId);
			if (!result) {
				throw new Error(`DrillProgram not found: ${drillProgramId}`);
			}
			return result;
		}
		return (await apiClient.drillProgramControllerFindOne(drillProgramId)).data;
	},

	/**
	 * Find all DrillProgram records with optional filtering
	 * @param query - Optional query parameters for filtering, pagination, etc.
	 * @returns Promise<DrillProgram[]>
	 */
	async drillProgramControllerFindAll(query?: {
		page?: number;
		take?: number;
		order?: "ASC" | "DESC";
		search?: string;
		filters?: string | FilterInput;
		sorts?: string;
	}): Promise<DrillProgram[]> {
		if (getMode() === WorkMode.OFFLINE) {
			let collection = db.Planning_DrillProgram.toCollection();

			// Get results as array
			let results = await collection.toArray();

			// Apply ALL filters on array
			if (query?.filters) {
				const filters = parseFiltersForDexie(query.filters);
				if (filters.length > 0) {
					for (const filter of filters) {
						const { field, op, value } = filter;
						switch (op) {
							case 'eq':
								results = results.filter((item: any) => item[field] === value);
								break;
							case 'neq':
								results = results.filter((item: any) => item[field] !== value);
								break;
							case 'gt':
								results = results.filter((item: any) => item[field] > value);
								break;
							case 'gte':
								results = results.filter((item: any) => item[field] >= value);
								break;
							case 'lt':
								results = results.filter((item: any) => item[field] < value);
								break;
							case 'lte':
								results = results.filter((item: any) => item[field] <= value);
								break;
							case 'contains':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().includes(String(value).toLowerCase())
								);
								break;
							case 'startsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().startsWith(String(value).toLowerCase())
								);
								break;
							case 'endsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().endsWith(String(value).toLowerCase())
								);
								break;
							case 'in':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => value.includes(item[field]));
								}
								break;
							case 'notIn':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => !value.includes(item[field]));
								}
								break;
						}
					}
				}
			}

			// Apply search (on array)
			if (query?.search) {
				const searchLower = query.search.toLowerCase();
				results = results.filter((item: any) =>
					Object.values(item).some(val =>
						typeof val === 'string' && val.toLowerCase().includes(searchLower)
					)
				);
			}

			// Apply sorting
			if (query?.sorts) {
				try {
					const sortFields = JSON.parse(query.sorts);
					if (Array.isArray(sortFields) && sortFields.length > 0) {
						results.sort((a: any, b: any) => {
							for (const sort of sortFields) {
								const { field, dir } = sort;
								const aVal = a[field];
								const bVal = b[field];
								if (aVal === bVal) continue;
								const comparison = aVal < bVal ? -1 : 1;
								return dir === 'desc' ? -comparison : comparison;
							}
							return 0;
						}
						);
					}
				} catch {
					// Invalid sorts format, skip
				}
			}

			// Apply pagination
			if (query?.page && query?.take) {
				const skip = (query.page - 1) * query.take;
				results = results.slice(skip, skip + query.take);
			} else if (query?.take) {
				results = results.slice(0, query.take);
			}

			return results as DrillProgram[];
		}
		const response = await apiClient.drillProgramControllerFindAll(query);
		return (response.data as any) || [];
	},

	/**
	 * Create a new DrillProgram
	 * @param drillProgram - The DrillProgram data to create
	 * @returns Promise<DrillProgram>
	 */
	async drillProgramControllerCreate(drillProgram: DrillProgram): Promise<DrillProgram> {
		if (getMode() === WorkMode.OFFLINE) {
			await db.Planning_DrillProgram.add(drillProgram);
			const result = await db.Planning_DrillProgram.get(drillProgram.DrillProgramId);
			if (!result) {
				throw new Error(`Failed to create DrillProgram: ${drillProgram.DrillProgramId}`);
			}
			return result;
		}
		return (await apiClient.drillProgramControllerCreate(drillProgram)).data;
	},

	/**
	 * Update a DrillProgram
	 * @param drillProgramId - The DrillProgramId to update
	 * @param drillProgram - The updated DrillProgram data
	 * @returns Promise<DrillProgram>
	 */
	async drillProgramControllerUpdate(drillProgramId: string, drillProgram: DrillProgram): Promise<DrillProgram> {
		if (getMode() === WorkMode.OFFLINE) {
			const numAffected = await db.Planning_DrillProgram.update(drillProgramId, drillProgram as any);
			let result;
			if (numAffected > 0) {
				result = await db.Planning_DrillProgram.get(drillProgramId);
			}
			if (!result) {
				throw new Error(`DrillProgram not found: ${drillProgramId}`);
			}
			return result;
		}
		return (await apiClient.drillProgramControllerUpdate(drillProgramId, drillProgram)).data;
	},

	/**
	 * Remove (soft delete) a DrillProgram
	 * Calls the API Remove endpoint which sets ActiveInd to false
	 * @param drillProgramId - The DrillProgramId to remove
	 * @param drillProgram - The DrillProgram data
	 * @returns Promise<DrillProgram>
	 */
	async drillProgramControllerRemove(drillProgramId: string, drillProgram: DrillProgram): Promise<DrillProgram> {
		if (getMode() === WorkMode.OFFLINE) {
			// In offline mode, soft delete by updating ActiveInd
			const numAffected = await db.Planning_DrillProgram.update(drillProgramId, { ...drillProgram, ActiveInd: false });
			let result;
			if (numAffected > 0) {
				result = await db.Planning_DrillProgram.get(drillProgramId);
			}
			if (!result) {
				throw new Error(`DrillProgram not found: ${drillProgramId}`);
			}
			return result;
		}
		// In online mode, call the API's Remove endpoint
		return (await apiClient.drillProgramControllerUpdate(drillProgramId, { ...drillProgram, ActiveInd: false })).data;
	},

	/**
	 * Find a single AssayBatch by ID
	 * @param assayBatchId - The AssayBatchId to find
	 * @returns Promise<AssayBatch>
	 */
	async assayBatchControllerFindOne(assayBatchId: string): Promise<AssayBatch> {
		if (getMode() === WorkMode.OFFLINE) {
			const result = await db.Processing_AssayBatch.get(assayBatchId);
			if (!result) {
				throw new Error(`AssayBatch not found: ${assayBatchId}`);
			}
			return result;
		}
		return (await apiClient.assayBatchControllerFindOne(assayBatchId)).data;
	},

	/**
	 * Find all AssayBatch records with optional filtering
	 * @param query - Optional query parameters for filtering, pagination, etc.
	 * @returns Promise<AssayBatch[]>
	 */
	async assayBatchControllerFindAll(query?: {
		page?: number;
		take?: number;
		order?: "ASC" | "DESC";
		search?: string;
		filters?: string | FilterInput;
		sorts?: string;
	}): Promise<AssayBatch[]> {
		if (getMode() === WorkMode.OFFLINE) {
			let collection = db.Processing_AssayBatch.toCollection();

			// Get results as array
			let results = await collection.toArray();

			// Apply ALL filters on array
			if (query?.filters) {
				const filters = parseFiltersForDexie(query.filters);
				if (filters.length > 0) {
					for (const filter of filters) {
						const { field, op, value } = filter;
						switch (op) {
							case 'eq':
								results = results.filter((item: any) => item[field] === value);
								break;
							case 'neq':
								results = results.filter((item: any) => item[field] !== value);
								break;
							case 'gt':
								results = results.filter((item: any) => item[field] > value);
								break;
							case 'gte':
								results = results.filter((item: any) => item[field] >= value);
								break;
							case 'lt':
								results = results.filter((item: any) => item[field] < value);
								break;
							case 'lte':
								results = results.filter((item: any) => item[field] <= value);
								break;
							case 'contains':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().includes(String(value).toLowerCase())
								);
								break;
							case 'startsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().startsWith(String(value).toLowerCase())
								);
								break;
							case 'endsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().endsWith(String(value).toLowerCase())
								);
								break;
							case 'in':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => value.includes(item[field]));
								}
								break;
							case 'notIn':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => !value.includes(item[field]));
								}
								break;
						}
					}
				}
			}

			// Apply search (on array)
			if (query?.search) {
				const searchLower = query.search.toLowerCase();
				results = results.filter((item: any) =>
					Object.values(item).some(val =>
						typeof val === 'string' && val.toLowerCase().includes(searchLower)
					)
				);
			}

			// Apply sorting
			if (query?.sorts) {
				try {
					const sortFields = JSON.parse(query.sorts);
					if (Array.isArray(sortFields) && sortFields.length > 0) {
						results.sort((a: any, b: any) => {
							for (const sort of sortFields) {
								const { field, dir } = sort;
								const aVal = a[field];
								const bVal = b[field];
								if (aVal === bVal) continue;
								const comparison = aVal < bVal ? -1 : 1;
								return dir === 'desc' ? -comparison : comparison;
							}
							return 0;
						}
						);
					}
				} catch {
					// Invalid sorts format, skip
				}
			}

			// Apply pagination
			if (query?.page && query?.take) {
				const skip = (query.page - 1) * query.take;
				results = results.slice(skip, skip + query.take);
			} else if (query?.take) {
				results = results.slice(0, query.take);
			}

			return results as AssayBatch[];
		}
		const response = await apiClient.assayBatchControllerFindAll(query);
		return (response.data as any) || [];
	},

	/**
	 * Create a new AssayBatch
	 * @param assayBatch - The AssayBatch data to create
	 * @returns Promise<AssayBatch>
	 */
	async assayBatchControllerCreate(assayBatch: AssayBatch): Promise<AssayBatch> {
		if (getMode() === WorkMode.OFFLINE) {
			await db.Processing_AssayBatch.add(assayBatch);
			const result = await db.Processing_AssayBatch.get(assayBatch.AssayBatchId);
			if (!result) {
				throw new Error(`Failed to create AssayBatch: ${assayBatch.AssayBatchId}`);
			}
			return result;
		}
		return (await apiClient.assayBatchControllerCreate(assayBatch)).data;
	},

	/**
	 * Update a AssayBatch
	 * @param assayBatchId - The AssayBatchId to update
	 * @param assayBatch - The updated AssayBatch data
	 * @returns Promise<AssayBatch>
	 */
	async assayBatchControllerUpdate(assayBatchId: string, assayBatch: AssayBatch): Promise<AssayBatch> {
		if (getMode() === WorkMode.OFFLINE) {
			const numAffected = await db.Processing_AssayBatch.update(assayBatchId, assayBatch as any);
			let result;
			if (numAffected > 0) {
				result = await db.Processing_AssayBatch.get(assayBatchId);
			}
			if (!result) {
				throw new Error(`AssayBatch not found: ${assayBatchId}`);
			}
			return result;
		}
		return (await apiClient.assayBatchControllerUpdate(assayBatchId, assayBatch)).data;
	},

	/**
	 * Remove (soft delete) a AssayBatch
	 * Calls the API Remove endpoint which sets ActiveInd to false
	 * @param assayBatchId - The AssayBatchId to remove
	 * @param assayBatch - The AssayBatch data
	 * @returns Promise<AssayBatch>
	 */
	async assayBatchControllerRemove(assayBatchId: string, assayBatch: AssayBatch): Promise<AssayBatch> {
		if (getMode() === WorkMode.OFFLINE) {
			// In offline mode, soft delete by updating ActiveInd
			const numAffected = await db.Processing_AssayBatch.update(assayBatchId, { ...assayBatch, ActiveInd: false });
			let result;
			if (numAffected > 0) {
				result = await db.Processing_AssayBatch.get(assayBatchId);
			}
			if (!result) {
				throw new Error(`AssayBatch not found: ${assayBatchId}`);
			}
			return result;
		}
		// In online mode, call the API's Remove endpoint
		return (await apiClient.assayBatchControllerUpdate(assayBatchId, { ...assayBatch, ActiveInd: false })).data;
	},

	/**
	 * Find a single AssayBatchDetail by ID
	 * @param assayBatchDetailId - The AssayBatchDetailId to find
	 * @returns Promise<AssayBatchDetail>
	 */
	async assayBatchDetailControllerFindOne(assayBatchDetailId: string): Promise<AssayBatchDetail> {
		if (getMode() === WorkMode.OFFLINE) {
			const result = await db.Processing_AssayBatchDetail.get(assayBatchDetailId);
			if (!result) {
				throw new Error(`AssayBatchDetail not found: ${assayBatchDetailId}`);
			}
			return result;
		}
		return (await apiClient.assayBatchDetailControllerFindOne(assayBatchDetailId)).data;
	},

	/**
	 * Find all AssayBatchDetail records with optional filtering
	 * @param query - Optional query parameters for filtering, pagination, etc.
	 * @returns Promise<AssayBatchDetail[]>
	 */
	async assayBatchDetailControllerFindAll(query?: {
		page?: number;
		take?: number;
		order?: "ASC" | "DESC";
		search?: string;
		filters?: string | FilterInput;
		sorts?: string;
	}): Promise<AssayBatchDetail[]> {
		if (getMode() === WorkMode.OFFLINE) {
			let collection = db.Processing_AssayBatchDetail.toCollection();

			// Get results as array
			let results = await collection.toArray();

			// Apply ALL filters on array
			if (query?.filters) {
				const filters = parseFiltersForDexie(query.filters);
				if (filters.length > 0) {
					for (const filter of filters) {
						const { field, op, value } = filter;
						switch (op) {
							case 'eq':
								results = results.filter((item: any) => item[field] === value);
								break;
							case 'neq':
								results = results.filter((item: any) => item[field] !== value);
								break;
							case 'gt':
								results = results.filter((item: any) => item[field] > value);
								break;
							case 'gte':
								results = results.filter((item: any) => item[field] >= value);
								break;
							case 'lt':
								results = results.filter((item: any) => item[field] < value);
								break;
							case 'lte':
								results = results.filter((item: any) => item[field] <= value);
								break;
							case 'contains':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().includes(String(value).toLowerCase())
								);
								break;
							case 'startsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().startsWith(String(value).toLowerCase())
								);
								break;
							case 'endsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().endsWith(String(value).toLowerCase())
								);
								break;
							case 'in':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => value.includes(item[field]));
								}
								break;
							case 'notIn':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => !value.includes(item[field]));
								}
								break;
						}
					}
				}
			}

			// Apply search (on array)
			if (query?.search) {
				const searchLower = query.search.toLowerCase();
				results = results.filter((item: any) =>
					Object.values(item).some(val =>
						typeof val === 'string' && val.toLowerCase().includes(searchLower)
					)
				);
			}

			// Apply sorting
			if (query?.sorts) {
				try {
					const sortFields = JSON.parse(query.sorts);
					if (Array.isArray(sortFields) && sortFields.length > 0) {
						results.sort((a: any, b: any) => {
							for (const sort of sortFields) {
								const { field, dir } = sort;
								const aVal = a[field];
								const bVal = b[field];
								if (aVal === bVal) continue;
								const comparison = aVal < bVal ? -1 : 1;
								return dir === 'desc' ? -comparison : comparison;
							}
							return 0;
						}
						);
					}
				} catch {
					// Invalid sorts format, skip
				}
			}

			// Apply pagination
			if (query?.page && query?.take) {
				const skip = (query.page - 1) * query.take;
				results = results.slice(skip, skip + query.take);
			} else if (query?.take) {
				results = results.slice(0, query.take);
			}

			return results as AssayBatchDetail[];
		}
		const response = await apiClient.assayBatchDetailControllerFindAll(query);
		return (response.data as any) || [];
	},

	/**
	 * Create a new AssayBatchDetail
	 * @param assayBatchDetail - The AssayBatchDetail data to create
	 * @returns Promise<AssayBatchDetail>
	 */
	async assayBatchDetailControllerCreate(assayBatchDetail: AssayBatchDetail): Promise<AssayBatchDetail> {
		if (getMode() === WorkMode.OFFLINE) {
			await db.Processing_AssayBatchDetail.add(assayBatchDetail);
			const result = await db.Processing_AssayBatchDetail.get(assayBatchDetail.AssayBatchDetailId);
			if (!result) {
				throw new Error(`Failed to create AssayBatchDetail: ${assayBatchDetail.AssayBatchDetailId}`);
			}
			return result;
		}
		return (await apiClient.assayBatchDetailControllerCreate(assayBatchDetail)).data;
	},

	/**
	 * Update a AssayBatchDetail
	 * @param assayBatchDetailId - The AssayBatchDetailId to update
	 * @param assayBatchDetail - The updated AssayBatchDetail data
	 * @returns Promise<AssayBatchDetail>
	 */
	async assayBatchDetailControllerUpdate(assayBatchDetailId: string, assayBatchDetail: AssayBatchDetail): Promise<AssayBatchDetail> {
		if (getMode() === WorkMode.OFFLINE) {
			const numAffected = await db.Processing_AssayBatchDetail.update(assayBatchDetailId, assayBatchDetail as any);
			let result;
			if (numAffected > 0) {
				result = await db.Processing_AssayBatchDetail.get(assayBatchDetailId);
			}
			if (!result) {
				throw new Error(`AssayBatchDetail not found: ${assayBatchDetailId}`);
			}
			return result;
		}
		return (await apiClient.assayBatchDetailControllerUpdate(assayBatchDetailId, assayBatchDetail)).data;
	},

	/**
	 * Remove (soft delete) a AssayBatchDetail
	 * Calls the API Remove endpoint which sets ActiveInd to false
	 * @param assayBatchDetailId - The AssayBatchDetailId to remove
	 * @param assayBatchDetail - The AssayBatchDetail data
	 * @returns Promise<AssayBatchDetail>
	 */
	async assayBatchDetailControllerRemove(assayBatchDetailId: string, assayBatchDetail: AssayBatchDetail): Promise<AssayBatchDetail> {
		if (getMode() === WorkMode.OFFLINE) {
			// In offline mode, soft delete by updating ActiveInd
			const numAffected = await db.Processing_AssayBatchDetail.update(assayBatchDetailId, { ...assayBatchDetail, ActiveInd: false });
			let result;
			if (numAffected > 0) {
				result = await db.Processing_AssayBatchDetail.get(assayBatchDetailId);
			}
			if (!result) {
				throw new Error(`AssayBatchDetail not found: ${assayBatchDetailId}`);
			}
			return result;
		}
		// In online mode, call the API's Remove endpoint
		return (await apiClient.assayBatchDetailControllerUpdate(assayBatchDetailId, { ...assayBatchDetail, ActiveInd: false })).data;
	},

	/**
	 * Find a single AssayBatchStatus by ID
	 * @param assayBatchStatusId - The AssayBatchStatusId to find
	 * @returns Promise<AssayBatchStatus>
	 */
	async assayBatchStatusControllerFindOne(assayBatchStatusId: string): Promise<AssayBatchStatus> {
		if (getMode() === WorkMode.OFFLINE) {
			const result = await db.Processing_AssayBatchStatus.get(assayBatchStatusId);
			if (!result) {
				throw new Error(`AssayBatchStatus not found: ${assayBatchStatusId}`);
			}
			return result;
		}
		return (await apiClient.assayBatchStatusControllerFindOne(assayBatchStatusId)).data;
	},

	/**
	 * Find all AssayBatchStatus records with optional filtering
	 * @param query - Optional query parameters for filtering, pagination, etc.
	 * @returns Promise<AssayBatchStatus[]>
	 */
	async assayBatchStatusControllerFindAll(query?: {
		page?: number;
		take?: number;
		order?: "ASC" | "DESC";
		search?: string;
		filters?: string | FilterInput;
		sorts?: string;
	}): Promise<AssayBatchStatus[]> {
		if (getMode() === WorkMode.OFFLINE) {
			let collection = db.Processing_AssayBatchStatus.toCollection();

			// Get results as array
			let results = await collection.toArray();

			// Apply ALL filters on array
			if (query?.filters) {
				const filters = parseFiltersForDexie(query.filters);
				if (filters.length > 0) {
					for (const filter of filters) {
						const { field, op, value } = filter;
						switch (op) {
							case 'eq':
								results = results.filter((item: any) => item[field] === value);
								break;
							case 'neq':
								results = results.filter((item: any) => item[field] !== value);
								break;
							case 'gt':
								results = results.filter((item: any) => item[field] > value);
								break;
							case 'gte':
								results = results.filter((item: any) => item[field] >= value);
								break;
							case 'lt':
								results = results.filter((item: any) => item[field] < value);
								break;
							case 'lte':
								results = results.filter((item: any) => item[field] <= value);
								break;
							case 'contains':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().includes(String(value).toLowerCase())
								);
								break;
							case 'startsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().startsWith(String(value).toLowerCase())
								);
								break;
							case 'endsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().endsWith(String(value).toLowerCase())
								);
								break;
							case 'in':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => value.includes(item[field]));
								}
								break;
							case 'notIn':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => !value.includes(item[field]));
								}
								break;
						}
					}
				}
			}

			// Apply search (on array)
			if (query?.search) {
				const searchLower = query.search.toLowerCase();
				results = results.filter((item: any) =>
					Object.values(item).some(val =>
						typeof val === 'string' && val.toLowerCase().includes(searchLower)
					)
				);
			}

			// Apply sorting
			if (query?.sorts) {
				try {
					const sortFields = JSON.parse(query.sorts);
					if (Array.isArray(sortFields) && sortFields.length > 0) {
						results.sort((a: any, b: any) => {
							for (const sort of sortFields) {
								const { field, dir } = sort;
								const aVal = a[field];
								const bVal = b[field];
								if (aVal === bVal) continue;
								const comparison = aVal < bVal ? -1 : 1;
								return dir === 'desc' ? -comparison : comparison;
							}
							return 0;
						}
						);
					}
				} catch {
					// Invalid sorts format, skip
				}
			}

			// Apply pagination
			if (query?.page && query?.take) {
				const skip = (query.page - 1) * query.take;
				results = results.slice(skip, skip + query.take);
			} else if (query?.take) {
				results = results.slice(0, query.take);
			}

			return results as AssayBatchStatus[];
		}
		const response = await apiClient.assayBatchStatusControllerFindAll(query);
		return (response.data as any) || [];
	},

	/**
	 * Create a new AssayBatchStatus
	 * @param assayBatchStatus - The AssayBatchStatus data to create
	 * @returns Promise<AssayBatchStatus>
	 */
	async assayBatchStatusControllerCreate(assayBatchStatus: AssayBatchStatus): Promise<AssayBatchStatus> {
		if (getMode() === WorkMode.OFFLINE) {
			await db.Processing_AssayBatchStatus.add(assayBatchStatus);
			const result = await db.Processing_AssayBatchStatus.get(assayBatchStatus.AssayBatchStatusId);
			if (!result) {
				throw new Error(`Failed to create AssayBatchStatus: ${assayBatchStatus.AssayBatchStatusId}`);
			}
			return result;
		}
		return (await apiClient.assayBatchStatusControllerCreate(assayBatchStatus)).data;
	},

	/**
	 * Update a AssayBatchStatus
	 * @param assayBatchStatusId - The AssayBatchStatusId to update
	 * @param assayBatchStatus - The updated AssayBatchStatus data
	 * @returns Promise<AssayBatchStatus>
	 */
	async assayBatchStatusControllerUpdate(assayBatchStatusId: string, assayBatchStatus: AssayBatchStatus): Promise<AssayBatchStatus> {
		if (getMode() === WorkMode.OFFLINE) {
			const numAffected = await db.Processing_AssayBatchStatus.update(assayBatchStatusId, assayBatchStatus as any);
			let result;
			if (numAffected > 0) {
				result = await db.Processing_AssayBatchStatus.get(assayBatchStatusId);
			}
			if (!result) {
				throw new Error(`AssayBatchStatus not found: ${assayBatchStatusId}`);
			}
			return result;
		}
		return (await apiClient.assayBatchStatusControllerUpdate(assayBatchStatusId, assayBatchStatus)).data;
	},

	/**
	 * Remove (soft delete) a AssayBatchStatus
	 * Calls the API Remove endpoint which sets ActiveInd to false
	 * @param assayBatchStatusId - The AssayBatchStatusId to remove
	 * @param assayBatchStatus - The AssayBatchStatus data
	 * @returns Promise<AssayBatchStatus>
	 */
	async assayBatchStatusControllerRemove(assayBatchStatusId: string, assayBatchStatus: AssayBatchStatus): Promise<AssayBatchStatus> {
		if (getMode() === WorkMode.OFFLINE) {
			// In offline mode, soft delete by updating ActiveInd
			const numAffected = await db.Processing_AssayBatchStatus.update(assayBatchStatusId, { ...assayBatchStatus, ActiveInd: false });
			let result;
			if (numAffected > 0) {
				result = await db.Processing_AssayBatchStatus.get(assayBatchStatusId);
			}
			if (!result) {
				throw new Error(`AssayBatchStatus not found: ${assayBatchStatusId}`);
			}
			return result;
		}
		// In online mode, call the API's Remove endpoint
		return (await apiClient.assayBatchStatusControllerUpdate(assayBatchStatusId, { ...assayBatchStatus, ActiveInd: false })).data;
	},

	/**
	 * Find a single AssayBatchStatusLog by ID
	 * @param assayBatchStatusLogId - The AssayBatchStatusLogId to find
	 * @returns Promise<AssayBatchStatusLog>
	 */
	async assayBatchStatusLogControllerFindOne(assayBatchStatusLogId: string): Promise<AssayBatchStatusLog> {
		if (getMode() === WorkMode.OFFLINE) {
			const result = await db.Processing_AssayBatchStatusLog.get(assayBatchStatusLogId);
			if (!result) {
				throw new Error(`AssayBatchStatusLog not found: ${assayBatchStatusLogId}`);
			}
			return result;
		}
		return (await apiClient.assayBatchStatusLogControllerFindOne(assayBatchStatusLogId)).data;
	},

	/**
	 * Find all AssayBatchStatusLog records with optional filtering
	 * @param query - Optional query parameters for filtering, pagination, etc.
	 * @returns Promise<AssayBatchStatusLog[]>
	 */
	async assayBatchStatusLogControllerFindAll(query?: {
		page?: number;
		take?: number;
		order?: "ASC" | "DESC";
		search?: string;
		filters?: string | FilterInput;
		sorts?: string;
	}): Promise<AssayBatchStatusLog[]> {
		if (getMode() === WorkMode.OFFLINE) {
			let collection = db.Processing_AssayBatchStatusLog.toCollection();

			// Get results as array
			let results = await collection.toArray();

			// Apply ALL filters on array
			if (query?.filters) {
				const filters = parseFiltersForDexie(query.filters);
				if (filters.length > 0) {
					for (const filter of filters) {
						const { field, op, value } = filter;
						switch (op) {
							case 'eq':
								results = results.filter((item: any) => item[field] === value);
								break;
							case 'neq':
								results = results.filter((item: any) => item[field] !== value);
								break;
							case 'gt':
								results = results.filter((item: any) => item[field] > value);
								break;
							case 'gte':
								results = results.filter((item: any) => item[field] >= value);
								break;
							case 'lt':
								results = results.filter((item: any) => item[field] < value);
								break;
							case 'lte':
								results = results.filter((item: any) => item[field] <= value);
								break;
							case 'contains':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().includes(String(value).toLowerCase())
								);
								break;
							case 'startsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().startsWith(String(value).toLowerCase())
								);
								break;
							case 'endsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().endsWith(String(value).toLowerCase())
								);
								break;
							case 'in':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => value.includes(item[field]));
								}
								break;
							case 'notIn':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => !value.includes(item[field]));
								}
								break;
						}
					}
				}
			}

			// Apply search (on array)
			if (query?.search) {
				const searchLower = query.search.toLowerCase();
				results = results.filter((item: any) =>
					Object.values(item).some(val =>
						typeof val === 'string' && val.toLowerCase().includes(searchLower)
					)
				);
			}

			// Apply sorting
			if (query?.sorts) {
				try {
					const sortFields = JSON.parse(query.sorts);
					if (Array.isArray(sortFields) && sortFields.length > 0) {
						results.sort((a: any, b: any) => {
							for (const sort of sortFields) {
								const { field, dir } = sort;
								const aVal = a[field];
								const bVal = b[field];
								if (aVal === bVal) continue;
								const comparison = aVal < bVal ? -1 : 1;
								return dir === 'desc' ? -comparison : comparison;
							}
							return 0;
						}
						);
					}
				} catch {
					// Invalid sorts format, skip
				}
			}

			// Apply pagination
			if (query?.page && query?.take) {
				const skip = (query.page - 1) * query.take;
				results = results.slice(skip, skip + query.take);
			} else if (query?.take) {
				results = results.slice(0, query.take);
			}

			return results as AssayBatchStatusLog[];
		}
		const response = await apiClient.assayBatchStatusLogControllerFindAll(query);
		return (response.data as any) || [];
	},

	/**
	 * Create a new AssayBatchStatusLog
	 * @param assayBatchStatusLog - The AssayBatchStatusLog data to create
	 * @returns Promise<AssayBatchStatusLog>
	 */
	async assayBatchStatusLogControllerCreate(assayBatchStatusLog: AssayBatchStatusLog): Promise<AssayBatchStatusLog> {
		if (getMode() === WorkMode.OFFLINE) {
			await db.Processing_AssayBatchStatusLog.add(assayBatchStatusLog);
			const result = await db.Processing_AssayBatchStatusLog.get(assayBatchStatusLog.AssayBatchStatusLogId);
			if (!result) {
				throw new Error(`Failed to create AssayBatchStatusLog: ${assayBatchStatusLog.AssayBatchStatusLogId}`);
			}
			return result;
		}
		return (await apiClient.assayBatchStatusLogControllerCreate(assayBatchStatusLog)).data;
	},

	/**
	 * Update a AssayBatchStatusLog
	 * @param assayBatchStatusLogId - The AssayBatchStatusLogId to update
	 * @param assayBatchStatusLog - The updated AssayBatchStatusLog data
	 * @returns Promise<AssayBatchStatusLog>
	 */
	async assayBatchStatusLogControllerUpdate(assayBatchStatusLogId: string, assayBatchStatusLog: AssayBatchStatusLog): Promise<AssayBatchStatusLog> {
		if (getMode() === WorkMode.OFFLINE) {
			const numAffected = await db.Processing_AssayBatchStatusLog.update(assayBatchStatusLogId, assayBatchStatusLog as any);
			let result;
			if (numAffected > 0) {
				result = await db.Processing_AssayBatchStatusLog.get(assayBatchStatusLogId);
			}
			if (!result) {
				throw new Error(`AssayBatchStatusLog not found: ${assayBatchStatusLogId}`);
			}
			return result;
		}
		return (await apiClient.assayBatchStatusLogControllerUpdate(assayBatchStatusLogId, assayBatchStatusLog)).data;
	},

	/**
	 * Remove (soft delete) a AssayBatchStatusLog
	 * Calls the API Remove endpoint which sets ActiveInd to false
	 * @param assayBatchStatusLogId - The AssayBatchStatusLogId to remove
	 * @param assayBatchStatusLog - The AssayBatchStatusLog data
	 * @returns Promise<AssayBatchStatusLog>
	 */
	async assayBatchStatusLogControllerRemove(assayBatchStatusLogId: string, assayBatchStatusLog: AssayBatchStatusLog): Promise<AssayBatchStatusLog> {
		if (getMode() === WorkMode.OFFLINE) {
			// In offline mode, soft delete by updating ActiveInd
			const numAffected = await db.Processing_AssayBatchStatusLog.update(assayBatchStatusLogId, { ...assayBatchStatusLog, ActiveInd: false });
			let result;
			if (numAffected > 0) {
				result = await db.Processing_AssayBatchStatusLog.get(assayBatchStatusLogId);
			}
			if (!result) {
				throw new Error(`AssayBatchStatusLog not found: ${assayBatchStatusLogId}`);
			}
			return result;
		}
		// In online mode, call the API's Remove endpoint
		return (await apiClient.assayBatchStatusLogControllerUpdate(assayBatchStatusLogId, { ...assayBatchStatusLog, ActiveInd: false })).data;
	},

	/**
	 * Find a single AssayElement by ID
	 * @param assayElementId - The AssayElementId to find
	 * @returns Promise<AssayElement>
	 */
	async assayElementControllerFindOne(assayElementId: string): Promise<AssayElement> {
		if (getMode() === WorkMode.OFFLINE) {
			const result = await db.Processing_AssayElement.get(assayElementId);
			if (!result) {
				throw new Error(`AssayElement not found: ${assayElementId}`);
			}
			return result;
		}
		return (await apiClient.assayElementControllerFindOne(assayElementId)).data;
	},

	/**
	 * Find all AssayElement records with optional filtering
	 * @param query - Optional query parameters for filtering, pagination, etc.
	 * @returns Promise<AssayElement[]>
	 */
	async assayElementControllerFindAll(query?: {
		page?: number;
		take?: number;
		order?: "ASC" | "DESC";
		search?: string;
		filters?: string | FilterInput;
		sorts?: string;
	}): Promise<AssayElement[]> {
		if (getMode() === WorkMode.OFFLINE) {
			let collection = db.Processing_AssayElement.toCollection();

			// Get results as array
			let results = await collection.toArray();

			// Apply ALL filters on array
			if (query?.filters) {
				const filters = parseFiltersForDexie(query.filters);
				if (filters.length > 0) {
					for (const filter of filters) {
						const { field, op, value } = filter;
						switch (op) {
							case 'eq':
								results = results.filter((item: any) => item[field] === value);
								break;
							case 'neq':
								results = results.filter((item: any) => item[field] !== value);
								break;
							case 'gt':
								results = results.filter((item: any) => item[field] > value);
								break;
							case 'gte':
								results = results.filter((item: any) => item[field] >= value);
								break;
							case 'lt':
								results = results.filter((item: any) => item[field] < value);
								break;
							case 'lte':
								results = results.filter((item: any) => item[field] <= value);
								break;
							case 'contains':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().includes(String(value).toLowerCase())
								);
								break;
							case 'startsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().startsWith(String(value).toLowerCase())
								);
								break;
							case 'endsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().endsWith(String(value).toLowerCase())
								);
								break;
							case 'in':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => value.includes(item[field]));
								}
								break;
							case 'notIn':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => !value.includes(item[field]));
								}
								break;
						}
					}
				}
			}

			// Apply search (on array)
			if (query?.search) {
				const searchLower = query.search.toLowerCase();
				results = results.filter((item: any) =>
					Object.values(item).some(val =>
						typeof val === 'string' && val.toLowerCase().includes(searchLower)
					)
				);
			}

			// Apply sorting
			if (query?.sorts) {
				try {
					const sortFields = JSON.parse(query.sorts);
					if (Array.isArray(sortFields) && sortFields.length > 0) {
						results.sort((a: any, b: any) => {
							for (const sort of sortFields) {
								const { field, dir } = sort;
								const aVal = a[field];
								const bVal = b[field];
								if (aVal === bVal) continue;
								const comparison = aVal < bVal ? -1 : 1;
								return dir === 'desc' ? -comparison : comparison;
							}
							return 0;
						}
						);
					}
				} catch {
					// Invalid sorts format, skip
				}
			}

			// Apply pagination
			if (query?.page && query?.take) {
				const skip = (query.page - 1) * query.take;
				results = results.slice(skip, skip + query.take);
			} else if (query?.take) {
				results = results.slice(0, query.take);
			}

			return results as AssayElement[];
		}
		const response = await apiClient.assayElementControllerFindAll(query);
		return (response.data as any) || [];
	},

	/**
	 * Create a new AssayElement
	 * @param assayElement - The AssayElement data to create
	 * @returns Promise<AssayElement>
	 */
	async assayElementControllerCreate(assayElement: AssayElement): Promise<AssayElement> {
		if (getMode() === WorkMode.OFFLINE) {
			await db.Processing_AssayElement.add(assayElement);
			const result = await db.Processing_AssayElement.get(assayElement.AssayElementId);
			if (!result) {
				throw new Error(`Failed to create AssayElement: ${assayElement.AssayElementId}`);
			}
			return result;
		}
		return (await apiClient.assayElementControllerCreate(assayElement)).data;
	},

	/**
	 * Update a AssayElement
	 * @param assayElementId - The AssayElementId to update
	 * @param assayElement - The updated AssayElement data
	 * @returns Promise<AssayElement>
	 */
	async assayElementControllerUpdate(assayElementId: string, assayElement: AssayElement): Promise<AssayElement> {
		if (getMode() === WorkMode.OFFLINE) {
			const numAffected = await db.Processing_AssayElement.update(assayElementId, assayElement as any);
			let result;
			if (numAffected > 0) {
				result = await db.Processing_AssayElement.get(assayElementId);
			}
			if (!result) {
				throw new Error(`AssayElement not found: ${assayElementId}`);
			}
			return result;
		}
		return (await apiClient.assayElementControllerUpdate(assayElementId, assayElement)).data;
	},

	/**
	 * Remove (soft delete) a AssayElement
	 * Calls the API Remove endpoint which sets ActiveInd to false
	 * @param assayElementId - The AssayElementId to remove
	 * @param assayElement - The AssayElement data
	 * @returns Promise<AssayElement>
	 */
	async assayElementControllerRemove(assayElementId: string, assayElement: AssayElement): Promise<AssayElement> {
		if (getMode() === WorkMode.OFFLINE) {
			// In offline mode, soft delete by updating ActiveInd
			const numAffected = await db.Processing_AssayElement.update(assayElementId, { ...assayElement, ActiveInd: false });
			let result;
			if (numAffected > 0) {
				result = await db.Processing_AssayElement.get(assayElementId);
			}
			if (!result) {
				throw new Error(`AssayElement not found: ${assayElementId}`);
			}
			return result;
		}
		// In online mode, call the API's Remove endpoint
		return (await apiClient.assayElementControllerUpdate(assayElementId, { ...assayElement, ActiveInd: false })).data;
	},

	/**
	 * Find a single AssayElementGroup by ID
	 * @param assayElementGroupId - The AssayElementGroupId to find
	 * @returns Promise<AssayElementGroup>
	 */
	async assayElementGroupControllerFindOne(assayElementGroupId: string): Promise<AssayElementGroup> {
		if (getMode() === WorkMode.OFFLINE) {
			const result = await db.Processing_AssayElementGroup.get(assayElementGroupId);
			if (!result) {
				throw new Error(`AssayElementGroup not found: ${assayElementGroupId}`);
			}
			return result;
		}
		return (await apiClient.assayElementGroupControllerFindOne(assayElementGroupId)).data;
	},

	/**
	 * Find all AssayElementGroup records with optional filtering
	 * @param query - Optional query parameters for filtering, pagination, etc.
	 * @returns Promise<AssayElementGroup[]>
	 */
	async assayElementGroupControllerFindAll(query?: {
		page?: number;
		take?: number;
		order?: "ASC" | "DESC";
		search?: string;
		filters?: string | FilterInput;
		sorts?: string;
	}): Promise<AssayElementGroup[]> {
		if (getMode() === WorkMode.OFFLINE) {
			let collection = db.Processing_AssayElementGroup.toCollection();

			// Get results as array
			let results = await collection.toArray();

			// Apply ALL filters on array
			if (query?.filters) {
				const filters = parseFiltersForDexie(query.filters);
				if (filters.length > 0) {
					for (const filter of filters) {
						const { field, op, value } = filter;
						switch (op) {
							case 'eq':
								results = results.filter((item: any) => item[field] === value);
								break;
							case 'neq':
								results = results.filter((item: any) => item[field] !== value);
								break;
							case 'gt':
								results = results.filter((item: any) => item[field] > value);
								break;
							case 'gte':
								results = results.filter((item: any) => item[field] >= value);
								break;
							case 'lt':
								results = results.filter((item: any) => item[field] < value);
								break;
							case 'lte':
								results = results.filter((item: any) => item[field] <= value);
								break;
							case 'contains':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().includes(String(value).toLowerCase())
								);
								break;
							case 'startsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().startsWith(String(value).toLowerCase())
								);
								break;
							case 'endsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().endsWith(String(value).toLowerCase())
								);
								break;
							case 'in':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => value.includes(item[field]));
								}
								break;
							case 'notIn':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => !value.includes(item[field]));
								}
								break;
						}
					}
				}
			}

			// Apply search (on array)
			if (query?.search) {
				const searchLower = query.search.toLowerCase();
				results = results.filter((item: any) =>
					Object.values(item).some(val =>
						typeof val === 'string' && val.toLowerCase().includes(searchLower)
					)
				);
			}

			// Apply sorting
			if (query?.sorts) {
				try {
					const sortFields = JSON.parse(query.sorts);
					if (Array.isArray(sortFields) && sortFields.length > 0) {
						results.sort((a: any, b: any) => {
							for (const sort of sortFields) {
								const { field, dir } = sort;
								const aVal = a[field];
								const bVal = b[field];
								if (aVal === bVal) continue;
								const comparison = aVal < bVal ? -1 : 1;
								return dir === 'desc' ? -comparison : comparison;
							}
							return 0;
						}
						);
					}
				} catch {
					// Invalid sorts format, skip
				}
			}

			// Apply pagination
			if (query?.page && query?.take) {
				const skip = (query.page - 1) * query.take;
				results = results.slice(skip, skip + query.take);
			} else if (query?.take) {
				results = results.slice(0, query.take);
			}

			return results as AssayElementGroup[];
		}
		const response = await apiClient.assayElementGroupControllerFindAll(query);
		return (response.data as any) || [];
	},

	/**
	 * Create a new AssayElementGroup
	 * @param assayElementGroup - The AssayElementGroup data to create
	 * @returns Promise<AssayElementGroup>
	 */
	async assayElementGroupControllerCreate(assayElementGroup: AssayElementGroup): Promise<AssayElementGroup> {
		if (getMode() === WorkMode.OFFLINE) {
			await db.Processing_AssayElementGroup.add(assayElementGroup);
			const result = await db.Processing_AssayElementGroup.get(assayElementGroup.AssayElementGroupId);
			if (!result) {
				throw new Error(`Failed to create AssayElementGroup: ${assayElementGroup.AssayElementGroupId}`);
			}
			return result;
		}
		return (await apiClient.assayElementGroupControllerCreate(assayElementGroup)).data;
	},

	/**
	 * Update a AssayElementGroup
	 * @param assayElementGroupId - The AssayElementGroupId to update
	 * @param assayElementGroup - The updated AssayElementGroup data
	 * @returns Promise<AssayElementGroup>
	 */
	async assayElementGroupControllerUpdate(assayElementGroupId: string, assayElementGroup: AssayElementGroup): Promise<AssayElementGroup> {
		if (getMode() === WorkMode.OFFLINE) {
			const numAffected = await db.Processing_AssayElementGroup.update(assayElementGroupId, assayElementGroup as any);
			let result;
			if (numAffected > 0) {
				result = await db.Processing_AssayElementGroup.get(assayElementGroupId);
			}
			if (!result) {
				throw new Error(`AssayElementGroup not found: ${assayElementGroupId}`);
			}
			return result;
		}
		return (await apiClient.assayElementGroupControllerUpdate(assayElementGroupId, assayElementGroup)).data;
	},

	/**
	 * Remove (soft delete) a AssayElementGroup
	 * Calls the API Remove endpoint which sets ActiveInd to false
	 * @param assayElementGroupId - The AssayElementGroupId to remove
	 * @param assayElementGroup - The AssayElementGroup data
	 * @returns Promise<AssayElementGroup>
	 */
	async assayElementGroupControllerRemove(assayElementGroupId: string, assayElementGroup: AssayElementGroup): Promise<AssayElementGroup> {
		if (getMode() === WorkMode.OFFLINE) {
			// In offline mode, soft delete by updating ActiveInd
			const numAffected = await db.Processing_AssayElementGroup.update(assayElementGroupId, { ...assayElementGroup, ActiveInd: false });
			let result;
			if (numAffected > 0) {
				result = await db.Processing_AssayElementGroup.get(assayElementGroupId);
			}
			if (!result) {
				throw new Error(`AssayElementGroup not found: ${assayElementGroupId}`);
			}
			return result;
		}
		// In online mode, call the API's Remove endpoint
		return (await apiClient.assayElementGroupControllerUpdate(assayElementGroupId, { ...assayElementGroup, ActiveInd: false })).data;
	},

	/**
	 * Find a single AssayLab by ID
	 * @param assayLabId - The AssayLabId to find
	 * @returns Promise<AssayLab>
	 */
	async assayLabControllerFindOne(assayLabId: string): Promise<AssayLab> {
		if (getMode() === WorkMode.OFFLINE) {
			const result = await db.Processing_AssayLab.get(assayLabId);
			if (!result) {
				throw new Error(`AssayLab not found: ${assayLabId}`);
			}
			return result;
		}
		return (await apiClient.assayLabControllerFindOne(assayLabId)).data;
	},

	/**
	 * Find all AssayLab records with optional filtering
	 * @param query - Optional query parameters for filtering, pagination, etc.
	 * @returns Promise<AssayLab[]>
	 */
	async assayLabControllerFindAll(query?: {
		page?: number;
		take?: number;
		order?: "ASC" | "DESC";
		search?: string;
		filters?: string | FilterInput;
		sorts?: string;
	}): Promise<AssayLab[]> {
		if (getMode() === WorkMode.OFFLINE) {
			let collection = db.Processing_AssayLab.toCollection();

			// Get results as array
			let results = await collection.toArray();

			// Apply ALL filters on array
			if (query?.filters) {
				const filters = parseFiltersForDexie(query.filters);
				if (filters.length > 0) {
					for (const filter of filters) {
						const { field, op, value } = filter;
						switch (op) {
							case 'eq':
								results = results.filter((item: any) => item[field] === value);
								break;
							case 'neq':
								results = results.filter((item: any) => item[field] !== value);
								break;
							case 'gt':
								results = results.filter((item: any) => item[field] > value);
								break;
							case 'gte':
								results = results.filter((item: any) => item[field] >= value);
								break;
							case 'lt':
								results = results.filter((item: any) => item[field] < value);
								break;
							case 'lte':
								results = results.filter((item: any) => item[field] <= value);
								break;
							case 'contains':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().includes(String(value).toLowerCase())
								);
								break;
							case 'startsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().startsWith(String(value).toLowerCase())
								);
								break;
							case 'endsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().endsWith(String(value).toLowerCase())
								);
								break;
							case 'in':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => value.includes(item[field]));
								}
								break;
							case 'notIn':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => !value.includes(item[field]));
								}
								break;
						}
					}
				}
			}

			// Apply search (on array)
			if (query?.search) {
				const searchLower = query.search.toLowerCase();
				results = results.filter((item: any) =>
					Object.values(item).some(val =>
						typeof val === 'string' && val.toLowerCase().includes(searchLower)
					)
				);
			}

			// Apply sorting
			if (query?.sorts) {
				try {
					const sortFields = JSON.parse(query.sorts);
					if (Array.isArray(sortFields) && sortFields.length > 0) {
						results.sort((a: any, b: any) => {
							for (const sort of sortFields) {
								const { field, dir } = sort;
								const aVal = a[field];
								const bVal = b[field];
								if (aVal === bVal) continue;
								const comparison = aVal < bVal ? -1 : 1;
								return dir === 'desc' ? -comparison : comparison;
							}
							return 0;
						}
						);
					}
				} catch {
					// Invalid sorts format, skip
				}
			}

			// Apply pagination
			if (query?.page && query?.take) {
				const skip = (query.page - 1) * query.take;
				results = results.slice(skip, skip + query.take);
			} else if (query?.take) {
				results = results.slice(0, query.take);
			}

			return results as AssayLab[];
		}
		const response = await apiClient.assayLabControllerFindAll(query);
		return (response.data as any) || [];
	},

	/**
	 * Create a new AssayLab
	 * @param assayLab - The AssayLab data to create
	 * @returns Promise<AssayLab>
	 */
	async assayLabControllerCreate(assayLab: AssayLab): Promise<AssayLab> {
		if (getMode() === WorkMode.OFFLINE) {
			await db.Processing_AssayLab.add(assayLab);
			const result = await db.Processing_AssayLab.get(assayLab.AssayLabId);
			if (!result) {
				throw new Error(`Failed to create AssayLab: ${assayLab.AssayLabId}`);
			}
			return result;
		}
		return (await apiClient.assayLabControllerCreate(assayLab)).data;
	},

	/**
	 * Update a AssayLab
	 * @param assayLabId - The AssayLabId to update
	 * @param assayLab - The updated AssayLab data
	 * @returns Promise<AssayLab>
	 */
	async assayLabControllerUpdate(assayLabId: string, assayLab: AssayLab): Promise<AssayLab> {
		if (getMode() === WorkMode.OFFLINE) {
			const numAffected = await db.Processing_AssayLab.update(assayLabId, assayLab as any);
			let result;
			if (numAffected > 0) {
				result = await db.Processing_AssayLab.get(assayLabId);
			}
			if (!result) {
				throw new Error(`AssayLab not found: ${assayLabId}`);
			}
			return result;
		}
		return (await apiClient.assayLabControllerUpdate(assayLabId, assayLab)).data;
	},

	/**
	 * Remove (soft delete) a AssayLab
	 * Calls the API Remove endpoint which sets ActiveInd to false
	 * @param assayLabId - The AssayLabId to remove
	 * @param assayLab - The AssayLab data
	 * @returns Promise<AssayLab>
	 */
	async assayLabControllerRemove(assayLabId: string, assayLab: AssayLab): Promise<AssayLab> {
		if (getMode() === WorkMode.OFFLINE) {
			// In offline mode, soft delete by updating ActiveInd
			const numAffected = await db.Processing_AssayLab.update(assayLabId, { ...assayLab, ActiveInd: false });
			let result;
			if (numAffected > 0) {
				result = await db.Processing_AssayLab.get(assayLabId);
			}
			if (!result) {
				throw new Error(`AssayLab not found: ${assayLabId}`);
			}
			return result;
		}
		// In online mode, call the API's Remove endpoint
		return (await apiClient.assayLabControllerUpdate(assayLabId, { ...assayLab, ActiveInd: false })).data;
	},

	/**
	 * Find a single AssayLabElementAlias by ID
	 * @param assayLabElementAliasId - The AssayLabElementAliasId to find
	 * @returns Promise<AssayLabElementAlias>
	 */
	async assayLabElementAliasControllerFindOne(assayLabElementAliasId: string): Promise<AssayLabElementAlias> {
		if (getMode() === WorkMode.OFFLINE) {
			const result = await db.Processing_AssayLabElementAlias.get(assayLabElementAliasId);
			if (!result) {
				throw new Error(`AssayLabElementAlias not found: ${assayLabElementAliasId}`);
			}
			return result;
		}
		return (await apiClient.assayLabElementAliasControllerFindOne(assayLabElementAliasId)).data;
	},

	/**
	 * Find all AssayLabElementAlias records with optional filtering
	 * @param query - Optional query parameters for filtering, pagination, etc.
	 * @returns Promise<AssayLabElementAlias[]>
	 */
	async assayLabElementAliasControllerFindAll(query?: {
		page?: number;
		take?: number;
		order?: "ASC" | "DESC";
		search?: string;
		filters?: string | FilterInput;
		sorts?: string;
	}): Promise<AssayLabElementAlias[]> {
		if (getMode() === WorkMode.OFFLINE) {
			let collection = db.Processing_AssayLabElementAlias.toCollection();

			// Get results as array
			let results = await collection.toArray();

			// Apply ALL filters on array
			if (query?.filters) {
				const filters = parseFiltersForDexie(query.filters);
				if (filters.length > 0) {
					for (const filter of filters) {
						const { field, op, value } = filter;
						switch (op) {
							case 'eq':
								results = results.filter((item: any) => item[field] === value);
								break;
							case 'neq':
								results = results.filter((item: any) => item[field] !== value);
								break;
							case 'gt':
								results = results.filter((item: any) => item[field] > value);
								break;
							case 'gte':
								results = results.filter((item: any) => item[field] >= value);
								break;
							case 'lt':
								results = results.filter((item: any) => item[field] < value);
								break;
							case 'lte':
								results = results.filter((item: any) => item[field] <= value);
								break;
							case 'contains':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().includes(String(value).toLowerCase())
								);
								break;
							case 'startsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().startsWith(String(value).toLowerCase())
								);
								break;
							case 'endsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().endsWith(String(value).toLowerCase())
								);
								break;
							case 'in':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => value.includes(item[field]));
								}
								break;
							case 'notIn':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => !value.includes(item[field]));
								}
								break;
						}
					}
				}
			}

			// Apply search (on array)
			if (query?.search) {
				const searchLower = query.search.toLowerCase();
				results = results.filter((item: any) =>
					Object.values(item).some(val =>
						typeof val === 'string' && val.toLowerCase().includes(searchLower)
					)
				);
			}

			// Apply sorting
			if (query?.sorts) {
				try {
					const sortFields = JSON.parse(query.sorts);
					if (Array.isArray(sortFields) && sortFields.length > 0) {
						results.sort((a: any, b: any) => {
							for (const sort of sortFields) {
								const { field, dir } = sort;
								const aVal = a[field];
								const bVal = b[field];
								if (aVal === bVal) continue;
								const comparison = aVal < bVal ? -1 : 1;
								return dir === 'desc' ? -comparison : comparison;
							}
							return 0;
						}
						);
					}
				} catch {
					// Invalid sorts format, skip
				}
			}

			// Apply pagination
			if (query?.page && query?.take) {
				const skip = (query.page - 1) * query.take;
				results = results.slice(skip, skip + query.take);
			} else if (query?.take) {
				results = results.slice(0, query.take);
			}

			return results as AssayLabElementAlias[];
		}
		const response = await apiClient.assayLabElementAliasControllerFindAll(query);
		return (response.data as any) || [];
	},

	/**
	 * Create a new AssayLabElementAlias
	 * @param assayLabElementAlias - The AssayLabElementAlias data to create
	 * @returns Promise<AssayLabElementAlias>
	 */
	async assayLabElementAliasControllerCreate(assayLabElementAlias: AssayLabElementAlias): Promise<AssayLabElementAlias> {
		if (getMode() === WorkMode.OFFLINE) {
			await db.Processing_AssayLabElementAlias.add(assayLabElementAlias);
			const result = await db.Processing_AssayLabElementAlias.get(assayLabElementAlias.AssayLabElementAliasId);
			if (!result) {
				throw new Error(`Failed to create AssayLabElementAlias: ${assayLabElementAlias.AssayLabElementAliasId}`);
			}
			return result;
		}
		return (await apiClient.assayLabElementAliasControllerCreate(assayLabElementAlias)).data;
	},

	/**
	 * Update a AssayLabElementAlias
	 * @param assayLabElementAliasId - The AssayLabElementAliasId to update
	 * @param assayLabElementAlias - The updated AssayLabElementAlias data
	 * @returns Promise<AssayLabElementAlias>
	 */
	async assayLabElementAliasControllerUpdate(assayLabElementAliasId: string, assayLabElementAlias: AssayLabElementAlias): Promise<AssayLabElementAlias> {
		if (getMode() === WorkMode.OFFLINE) {
			const numAffected = await db.Processing_AssayLabElementAlias.update(assayLabElementAliasId, assayLabElementAlias as any);
			let result;
			if (numAffected > 0) {
				result = await db.Processing_AssayLabElementAlias.get(assayLabElementAliasId);
			}
			if (!result) {
				throw new Error(`AssayLabElementAlias not found: ${assayLabElementAliasId}`);
			}
			return result;
		}
		return (await apiClient.assayLabElementAliasControllerUpdate(assayLabElementAliasId, assayLabElementAlias)).data;
	},

	/**
	 * Remove (soft delete) a AssayLabElementAlias
	 * Calls the API Remove endpoint which sets ActiveInd to false
	 * @param assayLabElementAliasId - The AssayLabElementAliasId to remove
	 * @param assayLabElementAlias - The AssayLabElementAlias data
	 * @returns Promise<AssayLabElementAlias>
	 */
	async assayLabElementAliasControllerRemove(assayLabElementAliasId: string, assayLabElementAlias: AssayLabElementAlias): Promise<AssayLabElementAlias> {
		if (getMode() === WorkMode.OFFLINE) {
			// In offline mode, soft delete by updating ActiveInd
			const numAffected = await db.Processing_AssayLabElementAlias.update(assayLabElementAliasId, { ...assayLabElementAlias, ActiveInd: false });
			let result;
			if (numAffected > 0) {
				result = await db.Processing_AssayLabElementAlias.get(assayLabElementAliasId);
			}
			if (!result) {
				throw new Error(`AssayLabElementAlias not found: ${assayLabElementAliasId}`);
			}
			return result;
		}
		// In online mode, call the API's Remove endpoint
		return (await apiClient.assayLabElementAliasControllerUpdate(assayLabElementAliasId, { ...assayLabElementAlias, ActiveInd: false })).data;
	},

	/**
	 * Find a single AssayLabMethod by ID
	 * @param assayLabMethodId - The AssayLabMethodId to find
	 * @returns Promise<AssayLabMethod>
	 */
	async assayLabMethodControllerFindOne(assayLabMethodId: string): Promise<AssayLabMethod> {
		if (getMode() === WorkMode.OFFLINE) {
			const result = await db.Processing_AssayLabMethod.get(assayLabMethodId);
			if (!result) {
				throw new Error(`AssayLabMethod not found: ${assayLabMethodId}`);
			}
			return result;
		}
		return (await apiClient.assayLabMethodControllerFindOne(assayLabMethodId)).data;
	},

	/**
	 * Find all AssayLabMethod records with optional filtering
	 * @param query - Optional query parameters for filtering, pagination, etc.
	 * @returns Promise<AssayLabMethod[]>
	 */
	async assayLabMethodControllerFindAll(query?: {
		page?: number;
		take?: number;
		order?: "ASC" | "DESC";
		search?: string;
		filters?: string | FilterInput;
		sorts?: string;
	}): Promise<AssayLabMethod[]> {
		if (getMode() === WorkMode.OFFLINE) {
			let collection = db.Processing_AssayLabMethod.toCollection();

			// Get results as array
			let results = await collection.toArray();

			// Apply ALL filters on array
			if (query?.filters) {
				const filters = parseFiltersForDexie(query.filters);
				if (filters.length > 0) {
					for (const filter of filters) {
						const { field, op, value } = filter;
						switch (op) {
							case 'eq':
								results = results.filter((item: any) => item[field] === value);
								break;
							case 'neq':
								results = results.filter((item: any) => item[field] !== value);
								break;
							case 'gt':
								results = results.filter((item: any) => item[field] > value);
								break;
							case 'gte':
								results = results.filter((item: any) => item[field] >= value);
								break;
							case 'lt':
								results = results.filter((item: any) => item[field] < value);
								break;
							case 'lte':
								results = results.filter((item: any) => item[field] <= value);
								break;
							case 'contains':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().includes(String(value).toLowerCase())
								);
								break;
							case 'startsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().startsWith(String(value).toLowerCase())
								);
								break;
							case 'endsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().endsWith(String(value).toLowerCase())
								);
								break;
							case 'in':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => value.includes(item[field]));
								}
								break;
							case 'notIn':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => !value.includes(item[field]));
								}
								break;
						}
					}
				}
			}

			// Apply search (on array)
			if (query?.search) {
				const searchLower = query.search.toLowerCase();
				results = results.filter((item: any) =>
					Object.values(item).some(val =>
						typeof val === 'string' && val.toLowerCase().includes(searchLower)
					)
				);
			}

			// Apply sorting
			if (query?.sorts) {
				try {
					const sortFields = JSON.parse(query.sorts);
					if (Array.isArray(sortFields) && sortFields.length > 0) {
						results.sort((a: any, b: any) => {
							for (const sort of sortFields) {
								const { field, dir } = sort;
								const aVal = a[field];
								const bVal = b[field];
								if (aVal === bVal) continue;
								const comparison = aVal < bVal ? -1 : 1;
								return dir === 'desc' ? -comparison : comparison;
							}
							return 0;
						}
						);
					}
				} catch {
					// Invalid sorts format, skip
				}
			}

			// Apply pagination
			if (query?.page && query?.take) {
				const skip = (query.page - 1) * query.take;
				results = results.slice(skip, skip + query.take);
			} else if (query?.take) {
				results = results.slice(0, query.take);
			}

			return results as AssayLabMethod[];
		}
		const response = await apiClient.assayLabMethodControllerFindAll(query);
		return (response.data as any) || [];
	},

	/**
	 * Create a new AssayLabMethod
	 * @param assayLabMethod - The AssayLabMethod data to create
	 * @returns Promise<AssayLabMethod>
	 */
	async assayLabMethodControllerCreate(assayLabMethod: AssayLabMethod): Promise<AssayLabMethod> {
		if (getMode() === WorkMode.OFFLINE) {
			await db.Processing_AssayLabMethod.add(assayLabMethod);
			const result = await db.Processing_AssayLabMethod.get(assayLabMethod.AssayLabMethodId);
			if (!result) {
				throw new Error(`Failed to create AssayLabMethod: ${assayLabMethod.AssayLabMethodId}`);
			}
			return result;
		}
		return (await apiClient.assayLabMethodControllerCreate(assayLabMethod)).data;
	},

	/**
	 * Update a AssayLabMethod
	 * @param assayLabMethodId - The AssayLabMethodId to update
	 * @param assayLabMethod - The updated AssayLabMethod data
	 * @returns Promise<AssayLabMethod>
	 */
	async assayLabMethodControllerUpdate(assayLabMethodId: string, assayLabMethod: AssayLabMethod): Promise<AssayLabMethod> {
		if (getMode() === WorkMode.OFFLINE) {
			const numAffected = await db.Processing_AssayLabMethod.update(assayLabMethodId, assayLabMethod as any);
			let result;
			if (numAffected > 0) {
				result = await db.Processing_AssayLabMethod.get(assayLabMethodId);
			}
			if (!result) {
				throw new Error(`AssayLabMethod not found: ${assayLabMethodId}`);
			}
			return result;
		}
		return (await apiClient.assayLabMethodControllerUpdate(assayLabMethodId, assayLabMethod)).data;
	},

	/**
	 * Remove (soft delete) a AssayLabMethod
	 * Calls the API Remove endpoint which sets ActiveInd to false
	 * @param assayLabMethodId - The AssayLabMethodId to remove
	 * @param assayLabMethod - The AssayLabMethod data
	 * @returns Promise<AssayLabMethod>
	 */
	async assayLabMethodControllerRemove(assayLabMethodId: string, assayLabMethod: AssayLabMethod): Promise<AssayLabMethod> {
		if (getMode() === WorkMode.OFFLINE) {
			// In offline mode, soft delete by updating ActiveInd
			const numAffected = await db.Processing_AssayLabMethod.update(assayLabMethodId, { ...assayLabMethod, ActiveInd: false });
			let result;
			if (numAffected > 0) {
				result = await db.Processing_AssayLabMethod.get(assayLabMethodId);
			}
			if (!result) {
				throw new Error(`AssayLabMethod not found: ${assayLabMethodId}`);
			}
			return result;
		}
		// In online mode, call the API's Remove endpoint
		return (await apiClient.assayLabMethodControllerUpdate(assayLabMethodId, { ...assayLabMethod, ActiveInd: false })).data;
	},

	/**
	 * Find a single AssayMethodGeneric by ID
	 * @param assayMethodGenericId - The AssayMethodGenericId to find
	 * @returns Promise<AssayMethodGeneric>
	 */
	async assayMethodGenericControllerFindOne(assayMethodGenericId: string): Promise<AssayMethodGeneric> {
		if (getMode() === WorkMode.OFFLINE) {
			const result = await db.Processing_AssayMethodGeneric.get(assayMethodGenericId);
			if (!result) {
				throw new Error(`AssayMethodGeneric not found: ${assayMethodGenericId}`);
			}
			return result;
		}
		return (await apiClient.assayMethodGenericControllerFindOne(assayMethodGenericId)).data;
	},

	/**
	 * Find all AssayMethodGeneric records with optional filtering
	 * @param query - Optional query parameters for filtering, pagination, etc.
	 * @returns Promise<AssayMethodGeneric[]>
	 */
	async assayMethodGenericControllerFindAll(query?: {
		page?: number;
		take?: number;
		order?: "ASC" | "DESC";
		search?: string;
		filters?: string | FilterInput;
		sorts?: string;
	}): Promise<AssayMethodGeneric[]> {
		if (getMode() === WorkMode.OFFLINE) {
			let collection = db.Processing_AssayMethodGeneric.toCollection();

			// Get results as array
			let results = await collection.toArray();

			// Apply ALL filters on array
			if (query?.filters) {
				const filters = parseFiltersForDexie(query.filters);
				if (filters.length > 0) {
					for (const filter of filters) {
						const { field, op, value } = filter;
						switch (op) {
							case 'eq':
								results = results.filter((item: any) => item[field] === value);
								break;
							case 'neq':
								results = results.filter((item: any) => item[field] !== value);
								break;
							case 'gt':
								results = results.filter((item: any) => item[field] > value);
								break;
							case 'gte':
								results = results.filter((item: any) => item[field] >= value);
								break;
							case 'lt':
								results = results.filter((item: any) => item[field] < value);
								break;
							case 'lte':
								results = results.filter((item: any) => item[field] <= value);
								break;
							case 'contains':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().includes(String(value).toLowerCase())
								);
								break;
							case 'startsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().startsWith(String(value).toLowerCase())
								);
								break;
							case 'endsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().endsWith(String(value).toLowerCase())
								);
								break;
							case 'in':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => value.includes(item[field]));
								}
								break;
							case 'notIn':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => !value.includes(item[field]));
								}
								break;
						}
					}
				}
			}

			// Apply search (on array)
			if (query?.search) {
				const searchLower = query.search.toLowerCase();
				results = results.filter((item: any) =>
					Object.values(item).some(val =>
						typeof val === 'string' && val.toLowerCase().includes(searchLower)
					)
				);
			}

			// Apply sorting
			if (query?.sorts) {
				try {
					const sortFields = JSON.parse(query.sorts);
					if (Array.isArray(sortFields) && sortFields.length > 0) {
						results.sort((a: any, b: any) => {
							for (const sort of sortFields) {
								const { field, dir } = sort;
								const aVal = a[field];
								const bVal = b[field];
								if (aVal === bVal) continue;
								const comparison = aVal < bVal ? -1 : 1;
								return dir === 'desc' ? -comparison : comparison;
							}
							return 0;
						}
						);
					}
				} catch {
					// Invalid sorts format, skip
				}
			}

			// Apply pagination
			if (query?.page && query?.take) {
				const skip = (query.page - 1) * query.take;
				results = results.slice(skip, skip + query.take);
			} else if (query?.take) {
				results = results.slice(0, query.take);
			}

			return results as AssayMethodGeneric[];
		}
		const response = await apiClient.assayMethodGenericControllerFindAll(query);
		return (response.data as any) || [];
	},

	/**
	 * Create a new AssayMethodGeneric
	 * @param assayMethodGeneric - The AssayMethodGeneric data to create
	 * @returns Promise<AssayMethodGeneric>
	 */
	async assayMethodGenericControllerCreate(assayMethodGeneric: AssayMethodGeneric): Promise<AssayMethodGeneric> {
		if (getMode() === WorkMode.OFFLINE) {
			await db.Processing_AssayMethodGeneric.add(assayMethodGeneric);
			const result = await db.Processing_AssayMethodGeneric.get(assayMethodGeneric.AssayMethodGenericId);
			if (!result) {
				throw new Error(`Failed to create AssayMethodGeneric: ${assayMethodGeneric.AssayMethodGenericId}`);
			}
			return result;
		}
		return (await apiClient.assayMethodGenericControllerCreate(assayMethodGeneric)).data;
	},

	/**
	 * Update a AssayMethodGeneric
	 * @param assayMethodGenericId - The AssayMethodGenericId to update
	 * @param assayMethodGeneric - The updated AssayMethodGeneric data
	 * @returns Promise<AssayMethodGeneric>
	 */
	async assayMethodGenericControllerUpdate(assayMethodGenericId: string, assayMethodGeneric: AssayMethodGeneric): Promise<AssayMethodGeneric> {
		if (getMode() === WorkMode.OFFLINE) {
			const numAffected = await db.Processing_AssayMethodGeneric.update(assayMethodGenericId, assayMethodGeneric as any);
			let result;
			if (numAffected > 0) {
				result = await db.Processing_AssayMethodGeneric.get(assayMethodGenericId);
			}
			if (!result) {
				throw new Error(`AssayMethodGeneric not found: ${assayMethodGenericId}`);
			}
			return result;
		}
		return (await apiClient.assayMethodGenericControllerUpdate(assayMethodGenericId, assayMethodGeneric)).data;
	},

	/**
	 * Remove (soft delete) a AssayMethodGeneric
	 * Calls the API Remove endpoint which sets ActiveInd to false
	 * @param assayMethodGenericId - The AssayMethodGenericId to remove
	 * @param assayMethodGeneric - The AssayMethodGeneric data
	 * @returns Promise<AssayMethodGeneric>
	 */
	async assayMethodGenericControllerRemove(assayMethodGenericId: string, assayMethodGeneric: AssayMethodGeneric): Promise<AssayMethodGeneric> {
		if (getMode() === WorkMode.OFFLINE) {
			// In offline mode, soft delete by updating ActiveInd
			const numAffected = await db.Processing_AssayMethodGeneric.update(assayMethodGenericId, { ...assayMethodGeneric, ActiveInd: false });
			let result;
			if (numAffected > 0) {
				result = await db.Processing_AssayMethodGeneric.get(assayMethodGenericId);
			}
			if (!result) {
				throw new Error(`AssayMethodGeneric not found: ${assayMethodGenericId}`);
			}
			return result;
		}
		// In online mode, call the API's Remove endpoint
		return (await apiClient.assayMethodGenericControllerUpdate(assayMethodGenericId, { ...assayMethodGeneric, ActiveInd: false })).data;
	},

	/**
	 * Find a single QcAnalysisType by ID
	 * @param qCAnalysisTypeId - The QCAnalysisTypeId to find
	 * @returns Promise<QcAnalysisType>
	 */
	async qcAnalysisTypeControllerFindOne(qCAnalysisTypeId: string): Promise<QcAnalysisType> {
		if (getMode() === WorkMode.OFFLINE) {
			const result = await db.QAQC_QCAnalysisType.get(qCAnalysisTypeId);
			if (!result) {
				throw new Error(`QcAnalysisType not found: ${qCAnalysisTypeId}`);
			}
			return result;
		}
		return (await apiClient.qcAnalysisTypeControllerFindOne(qCAnalysisTypeId)).data;
	},

	/**
	 * Find all QcAnalysisType records with optional filtering
	 * @param query - Optional query parameters for filtering, pagination, etc.
	 * @returns Promise<QcAnalysisType[]>
	 */
	async qcAnalysisTypeControllerFindAll(query?: {
		page?: number;
		take?: number;
		order?: "ASC" | "DESC";
		search?: string;
		filters?: string | FilterInput;
		sorts?: string;
	}): Promise<QcAnalysisType[]> {
		if (getMode() === WorkMode.OFFLINE) {
			let collection = db.QAQC_QCAnalysisType.toCollection();

			// Get results as array
			let results = await collection.toArray();

			// Apply ALL filters on array
			if (query?.filters) {
				const filters = parseFiltersForDexie(query.filters);
				if (filters.length > 0) {
					for (const filter of filters) {
						const { field, op, value } = filter;
						switch (op) {
							case 'eq':
								results = results.filter((item: any) => item[field] === value);
								break;
							case 'neq':
								results = results.filter((item: any) => item[field] !== value);
								break;
							case 'gt':
								results = results.filter((item: any) => item[field] > value);
								break;
							case 'gte':
								results = results.filter((item: any) => item[field] >= value);
								break;
							case 'lt':
								results = results.filter((item: any) => item[field] < value);
								break;
							case 'lte':
								results = results.filter((item: any) => item[field] <= value);
								break;
							case 'contains':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().includes(String(value).toLowerCase())
								);
								break;
							case 'startsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().startsWith(String(value).toLowerCase())
								);
								break;
							case 'endsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().endsWith(String(value).toLowerCase())
								);
								break;
							case 'in':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => value.includes(item[field]));
								}
								break;
							case 'notIn':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => !value.includes(item[field]));
								}
								break;
						}
					}
				}
			}

			// Apply search (on array)
			if (query?.search) {
				const searchLower = query.search.toLowerCase();
				results = results.filter((item: any) =>
					Object.values(item).some(val =>
						typeof val === 'string' && val.toLowerCase().includes(searchLower)
					)
				);
			}

			// Apply sorting
			if (query?.sorts) {
				try {
					const sortFields = JSON.parse(query.sorts);
					if (Array.isArray(sortFields) && sortFields.length > 0) {
						results.sort((a: any, b: any) => {
							for (const sort of sortFields) {
								const { field, dir } = sort;
								const aVal = a[field];
								const bVal = b[field];
								if (aVal === bVal) continue;
								const comparison = aVal < bVal ? -1 : 1;
								return dir === 'desc' ? -comparison : comparison;
							}
							return 0;
						}
						);
					}
				} catch {
					// Invalid sorts format, skip
				}
			}

			// Apply pagination
			if (query?.page && query?.take) {
				const skip = (query.page - 1) * query.take;
				results = results.slice(skip, skip + query.take);
			} else if (query?.take) {
				results = results.slice(0, query.take);
			}

			return results as QcAnalysisType[];
		}
		const response = await apiClient.qcAnalysisTypeControllerFindAll(query);
		return (response.data as any) || [];
	},

	/**
	 * Create a new QcAnalysisType
	 * @param qcAnalysisType - The QcAnalysisType data to create
	 * @returns Promise<QcAnalysisType>
	 */
	async qcAnalysisTypeControllerCreate(qcAnalysisType: QcAnalysisType): Promise<QcAnalysisType> {
		if (getMode() === WorkMode.OFFLINE) {
			await db.QAQC_QCAnalysisType.add(qcAnalysisType);
			const result = await db.QAQC_QCAnalysisType.get(qcAnalysisType.QCAnalysisTypeId);
			if (!result) {
				throw new Error(`Failed to create QcAnalysisType: ${qcAnalysisType.QCAnalysisTypeId}`);
			}
			return result;
		}
		return (await apiClient.qcAnalysisTypeControllerCreate(qcAnalysisType)).data;
	},

	/**
	 * Update a QcAnalysisType
	 * @param qCAnalysisTypeId - The QCAnalysisTypeId to update
	 * @param qcAnalysisType - The updated QcAnalysisType data
	 * @returns Promise<QcAnalysisType>
	 */
	async qcAnalysisTypeControllerUpdate(qCAnalysisTypeId: string, qcAnalysisType: QcAnalysisType): Promise<QcAnalysisType> {
		if (getMode() === WorkMode.OFFLINE) {
			const numAffected = await db.QAQC_QCAnalysisType.update(qCAnalysisTypeId, qcAnalysisType as any);
			let result;
			if (numAffected > 0) {
				result = await db.QAQC_QCAnalysisType.get(qCAnalysisTypeId);
			}
			if (!result) {
				throw new Error(`QcAnalysisType not found: ${qCAnalysisTypeId}`);
			}
			return result;
		}
		return (await apiClient.qcAnalysisTypeControllerUpdate(qCAnalysisTypeId, qcAnalysisType)).data;
	},

	/**
	 * Remove (soft delete) a QcAnalysisType
	 * Calls the API Remove endpoint which sets ActiveInd to false
	 * @param qCAnalysisTypeId - The QCAnalysisTypeId to remove
	 * @param qcAnalysisType - The QcAnalysisType data
	 * @returns Promise<QcAnalysisType>
	 */
	async qcAnalysisTypeControllerRemove(qCAnalysisTypeId: string, qcAnalysisType: QcAnalysisType): Promise<QcAnalysisType> {
		if (getMode() === WorkMode.OFFLINE) {
			// In offline mode, soft delete by updating ActiveInd
			const numAffected = await db.QAQC_QCAnalysisType.update(qCAnalysisTypeId, { ...qcAnalysisType, ActiveInd: false });
			let result;
			if (numAffected > 0) {
				result = await db.QAQC_QCAnalysisType.get(qCAnalysisTypeId);
			}
			if (!result) {
				throw new Error(`QcAnalysisType not found: ${qCAnalysisTypeId}`);
			}
			return result;
		}
		// In online mode, call the API's Remove endpoint
		return (await apiClient.qcAnalysisTypeControllerUpdate(qCAnalysisTypeId, { ...qcAnalysisType, ActiveInd: false })).data;
	},

	/**
	 * Find a single QcClassification by ID
	 * @param qCClassificationId - The QCClassificationId to find
	 * @returns Promise<QcClassification>
	 */
	async qcClassificationControllerFindOne(qCClassificationId: string): Promise<QcClassification> {
		if (getMode() === WorkMode.OFFLINE) {
			const result = await db.QAQC_QCClassification.get(qCClassificationId);
			if (!result) {
				throw new Error(`QcClassification not found: ${qCClassificationId}`);
			}
			return result;
		}
		return (await apiClient.qcClassificationControllerFindOne(qCClassificationId)).data;
	},

	/**
	 * Find all QcClassification records with optional filtering
	 * @param query - Optional query parameters for filtering, pagination, etc.
	 * @returns Promise<QcClassification[]>
	 */
	async qcClassificationControllerFindAll(query?: {
		page?: number;
		take?: number;
		order?: "ASC" | "DESC";
		search?: string;
		filters?: string | FilterInput;
		sorts?: string;
	}): Promise<QcClassification[]> {
		if (getMode() === WorkMode.OFFLINE) {
			let collection = db.QAQC_QCClassification.toCollection();

			// Get results as array
			let results = await collection.toArray();

			// Apply ALL filters on array
			if (query?.filters) {
				const filters = parseFiltersForDexie(query.filters);
				if (filters.length > 0) {
					for (const filter of filters) {
						const { field, op, value } = filter;
						switch (op) {
							case 'eq':
								results = results.filter((item: any) => item[field] === value);
								break;
							case 'neq':
								results = results.filter((item: any) => item[field] !== value);
								break;
							case 'gt':
								results = results.filter((item: any) => item[field] > value);
								break;
							case 'gte':
								results = results.filter((item: any) => item[field] >= value);
								break;
							case 'lt':
								results = results.filter((item: any) => item[field] < value);
								break;
							case 'lte':
								results = results.filter((item: any) => item[field] <= value);
								break;
							case 'contains':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().includes(String(value).toLowerCase())
								);
								break;
							case 'startsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().startsWith(String(value).toLowerCase())
								);
								break;
							case 'endsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().endsWith(String(value).toLowerCase())
								);
								break;
							case 'in':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => value.includes(item[field]));
								}
								break;
							case 'notIn':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => !value.includes(item[field]));
								}
								break;
						}
					}
				}
			}

			// Apply search (on array)
			if (query?.search) {
				const searchLower = query.search.toLowerCase();
				results = results.filter((item: any) =>
					Object.values(item).some(val =>
						typeof val === 'string' && val.toLowerCase().includes(searchLower)
					)
				);
			}

			// Apply sorting
			if (query?.sorts) {
				try {
					const sortFields = JSON.parse(query.sorts);
					if (Array.isArray(sortFields) && sortFields.length > 0) {
						results.sort((a: any, b: any) => {
							for (const sort of sortFields) {
								const { field, dir } = sort;
								const aVal = a[field];
								const bVal = b[field];
								if (aVal === bVal) continue;
								const comparison = aVal < bVal ? -1 : 1;
								return dir === 'desc' ? -comparison : comparison;
							}
							return 0;
						}
						);
					}
				} catch {
					// Invalid sorts format, skip
				}
			}

			// Apply pagination
			if (query?.page && query?.take) {
				const skip = (query.page - 1) * query.take;
				results = results.slice(skip, skip + query.take);
			} else if (query?.take) {
				results = results.slice(0, query.take);
			}

			return results as QcClassification[];
		}
		const response = await apiClient.qcClassificationControllerFindAll(query);
		return (response.data as any) || [];
	},

	/**
	 * Create a new QcClassification
	 * @param qcClassification - The QcClassification data to create
	 * @returns Promise<QcClassification>
	 */
	async qcClassificationControllerCreate(qcClassification: QcClassification): Promise<QcClassification> {
		if (getMode() === WorkMode.OFFLINE) {
			await db.QAQC_QCClassification.add(qcClassification);
			const result = await db.QAQC_QCClassification.get(qcClassification.QCClassificationId);
			if (!result) {
				throw new Error(`Failed to create QcClassification: ${qcClassification.QCClassificationId}`);
			}
			return result;
		}
		return (await apiClient.qcClassificationControllerCreate(qcClassification)).data;
	},

	/**
	 * Update a QcClassification
	 * @param qCClassificationId - The QCClassificationId to update
	 * @param qcClassification - The updated QcClassification data
	 * @returns Promise<QcClassification>
	 */
	async qcClassificationControllerUpdate(qCClassificationId: string, qcClassification: QcClassification): Promise<QcClassification> {
		if (getMode() === WorkMode.OFFLINE) {
			const numAffected = await db.QAQC_QCClassification.update(qCClassificationId, qcClassification as any);
			let result;
			if (numAffected > 0) {
				result = await db.QAQC_QCClassification.get(qCClassificationId);
			}
			if (!result) {
				throw new Error(`QcClassification not found: ${qCClassificationId}`);
			}
			return result;
		}
		return (await apiClient.qcClassificationControllerUpdate(qCClassificationId, qcClassification)).data;
	},

	/**
	 * Remove (soft delete) a QcClassification
	 * Calls the API Remove endpoint which sets ActiveInd to false
	 * @param qCClassificationId - The QCClassificationId to remove
	 * @param qcClassification - The QcClassification data
	 * @returns Promise<QcClassification>
	 */
	async qcClassificationControllerRemove(qCClassificationId: string, qcClassification: QcClassification): Promise<QcClassification> {
		if (getMode() === WorkMode.OFFLINE) {
			// In offline mode, soft delete by updating ActiveInd
			const numAffected = await db.QAQC_QCClassification.update(qCClassificationId, { ...qcClassification, ActiveInd: false });
			let result;
			if (numAffected > 0) {
				result = await db.QAQC_QCClassification.get(qCClassificationId);
			}
			if (!result) {
				throw new Error(`QcClassification not found: ${qCClassificationId}`);
			}
			return result;
		}
		// In online mode, call the API's Remove endpoint
		return (await apiClient.qcClassificationControllerUpdate(qCClassificationId, { ...qcClassification, ActiveInd: false })).data;
	},

	/**
	 * Find a single QcFilteredset by ID
	 * @param qCFilteredsetId - The QCFilteredsetId to find
	 * @returns Promise<QcFilteredset>
	 */
	async qcFilteredsetControllerFindOne(qCFilteredsetId: string): Promise<QcFilteredset> {
		if (getMode() === WorkMode.OFFLINE) {
			const result = await db.QAQC_QCFilteredset.get(qCFilteredsetId);
			if (!result) {
				throw new Error(`QcFilteredset not found: ${qCFilteredsetId}`);
			}
			return result;
		}
		return (await apiClient.qcFilteredsetControllerFindOne(qCFilteredsetId)).data;
	},

	/**
	 * Find all QcFilteredset records with optional filtering
	 * @param query - Optional query parameters for filtering, pagination, etc.
	 * @returns Promise<QcFilteredset[]>
	 */
	async qcFilteredsetControllerFindAll(query?: {
		page?: number;
		take?: number;
		order?: "ASC" | "DESC";
		search?: string;
		filters?: string | FilterInput;
		sorts?: string;
	}): Promise<QcFilteredset[]> {
		if (getMode() === WorkMode.OFFLINE) {
			let collection = db.QAQC_QCFilteredset.toCollection();

			// Get results as array
			let results = await collection.toArray();

			// Apply ALL filters on array
			if (query?.filters) {
				const filters = parseFiltersForDexie(query.filters);
				if (filters.length > 0) {
					for (const filter of filters) {
						const { field, op, value } = filter;
						switch (op) {
							case 'eq':
								results = results.filter((item: any) => item[field] === value);
								break;
							case 'neq':
								results = results.filter((item: any) => item[field] !== value);
								break;
							case 'gt':
								results = results.filter((item: any) => item[field] > value);
								break;
							case 'gte':
								results = results.filter((item: any) => item[field] >= value);
								break;
							case 'lt':
								results = results.filter((item: any) => item[field] < value);
								break;
							case 'lte':
								results = results.filter((item: any) => item[field] <= value);
								break;
							case 'contains':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().includes(String(value).toLowerCase())
								);
								break;
							case 'startsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().startsWith(String(value).toLowerCase())
								);
								break;
							case 'endsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().endsWith(String(value).toLowerCase())
								);
								break;
							case 'in':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => value.includes(item[field]));
								}
								break;
							case 'notIn':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => !value.includes(item[field]));
								}
								break;
						}
					}
				}
			}

			// Apply search (on array)
			if (query?.search) {
				const searchLower = query.search.toLowerCase();
				results = results.filter((item: any) =>
					Object.values(item).some(val =>
						typeof val === 'string' && val.toLowerCase().includes(searchLower)
					)
				);
			}

			// Apply sorting
			if (query?.sorts) {
				try {
					const sortFields = JSON.parse(query.sorts);
					if (Array.isArray(sortFields) && sortFields.length > 0) {
						results.sort((a: any, b: any) => {
							for (const sort of sortFields) {
								const { field, dir } = sort;
								const aVal = a[field];
								const bVal = b[field];
								if (aVal === bVal) continue;
								const comparison = aVal < bVal ? -1 : 1;
								return dir === 'desc' ? -comparison : comparison;
							}
							return 0;
						}
						);
					}
				} catch {
					// Invalid sorts format, skip
				}
			}

			// Apply pagination
			if (query?.page && query?.take) {
				const skip = (query.page - 1) * query.take;
				results = results.slice(skip, skip + query.take);
			} else if (query?.take) {
				results = results.slice(0, query.take);
			}

			return results as QcFilteredset[];
		}
		const response = await apiClient.qcFilteredsetControllerFindAll(query);
		return (response.data as any) || [];
	},

	/**
	 * Create a new QcFilteredset
	 * @param qcFilteredset - The QcFilteredset data to create
	 * @returns Promise<QcFilteredset>
	 */
	async qcFilteredsetControllerCreate(qcFilteredset: QcFilteredset): Promise<QcFilteredset> {
		if (getMode() === WorkMode.OFFLINE) {
			await db.QAQC_QCFilteredset.add(qcFilteredset);
			const result = await db.QAQC_QCFilteredset.get(qcFilteredset.QCFilteredsetId);
			if (!result) {
				throw new Error(`Failed to create QcFilteredset: ${qcFilteredset.QCFilteredsetId}`);
			}
			return result;
		}
		return (await apiClient.qcFilteredsetControllerCreate(qcFilteredset)).data;
	},

	/**
	 * Update a QcFilteredset
	 * @param qCFilteredsetId - The QCFilteredsetId to update
	 * @param qcFilteredset - The updated QcFilteredset data
	 * @returns Promise<QcFilteredset>
	 */
	async qcFilteredsetControllerUpdate(qCFilteredsetId: string, qcFilteredset: QcFilteredset): Promise<QcFilteredset> {
		if (getMode() === WorkMode.OFFLINE) {
			const numAffected = await db.QAQC_QCFilteredset.update(qCFilteredsetId, qcFilteredset as any);
			let result;
			if (numAffected > 0) {
				result = await db.QAQC_QCFilteredset.get(qCFilteredsetId);
			}
			if (!result) {
				throw new Error(`QcFilteredset not found: ${qCFilteredsetId}`);
			}
			return result;
		}
		return (await apiClient.qcFilteredsetControllerUpdate(qCFilteredsetId, qcFilteredset)).data;
	},

	/**
	 * Remove (soft delete) a QcFilteredset
	 * Calls the API Remove endpoint which sets ActiveInd to false
	 * @param qCFilteredsetId - The QCFilteredsetId to remove
	 * @param qcFilteredset - The QcFilteredset data
	 * @returns Promise<QcFilteredset>
	 */
	async qcFilteredsetControllerRemove(qCFilteredsetId: string, qcFilteredset: QcFilteredset): Promise<QcFilteredset> {
		if (getMode() === WorkMode.OFFLINE) {
			// In offline mode, soft delete by updating ActiveInd
			const numAffected = await db.QAQC_QCFilteredset.update(qCFilteredsetId, { ...qcFilteredset, ActiveInd: false });
			let result;
			if (numAffected > 0) {
				result = await db.QAQC_QCFilteredset.get(qCFilteredsetId);
			}
			if (!result) {
				throw new Error(`QcFilteredset not found: ${qCFilteredsetId}`);
			}
			return result;
		}
		// In online mode, call the API's Remove endpoint
		return (await apiClient.qcFilteredsetControllerUpdate(qCFilteredsetId, { ...qcFilteredset, ActiveInd: false })).data;
	},

	/**
	 * Find a single QcGroup by ID
	 * @param qCGroupId - The QCGroupId to find
	 * @returns Promise<QcGroup>
	 */
	async qcGroupControllerFindOne(qCGroupId: string): Promise<QcGroup> {
		if (getMode() === WorkMode.OFFLINE) {
			const result = await db.QAQC_QCGroup.get(qCGroupId);
			if (!result) {
				throw new Error(`QcGroup not found: ${qCGroupId}`);
			}
			return result;
		}
		return (await apiClient.qcGroupControllerFindOne(qCGroupId)).data;
	},

	/**
	 * Find all QcGroup records with optional filtering
	 * @param query - Optional query parameters for filtering, pagination, etc.
	 * @returns Promise<QcGroup[]>
	 */
	async qcGroupControllerFindAll(query?: {
		page?: number;
		take?: number;
		order?: "ASC" | "DESC";
		search?: string;
		filters?: string | FilterInput;
		sorts?: string;
	}): Promise<QcGroup[]> {
		if (getMode() === WorkMode.OFFLINE) {
			let collection = db.QAQC_QCGroup.toCollection();

			// Get results as array
			let results = await collection.toArray();

			// Apply ALL filters on array
			if (query?.filters) {
				const filters = parseFiltersForDexie(query.filters);
				if (filters.length > 0) {
					for (const filter of filters) {
						const { field, op, value } = filter;
						switch (op) {
							case 'eq':
								results = results.filter((item: any) => item[field] === value);
								break;
							case 'neq':
								results = results.filter((item: any) => item[field] !== value);
								break;
							case 'gt':
								results = results.filter((item: any) => item[field] > value);
								break;
							case 'gte':
								results = results.filter((item: any) => item[field] >= value);
								break;
							case 'lt':
								results = results.filter((item: any) => item[field] < value);
								break;
							case 'lte':
								results = results.filter((item: any) => item[field] <= value);
								break;
							case 'contains':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().includes(String(value).toLowerCase())
								);
								break;
							case 'startsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().startsWith(String(value).toLowerCase())
								);
								break;
							case 'endsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().endsWith(String(value).toLowerCase())
								);
								break;
							case 'in':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => value.includes(item[field]));
								}
								break;
							case 'notIn':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => !value.includes(item[field]));
								}
								break;
						}
					}
				}
			}

			// Apply search (on array)
			if (query?.search) {
				const searchLower = query.search.toLowerCase();
				results = results.filter((item: any) =>
					Object.values(item).some(val =>
						typeof val === 'string' && val.toLowerCase().includes(searchLower)
					)
				);
			}

			// Apply sorting
			if (query?.sorts) {
				try {
					const sortFields = JSON.parse(query.sorts);
					if (Array.isArray(sortFields) && sortFields.length > 0) {
						results.sort((a: any, b: any) => {
							for (const sort of sortFields) {
								const { field, dir } = sort;
								const aVal = a[field];
								const bVal = b[field];
								if (aVal === bVal) continue;
								const comparison = aVal < bVal ? -1 : 1;
								return dir === 'desc' ? -comparison : comparison;
							}
							return 0;
						}
						);
					}
				} catch {
					// Invalid sorts format, skip
				}
			}

			// Apply pagination
			if (query?.page && query?.take) {
				const skip = (query.page - 1) * query.take;
				results = results.slice(skip, skip + query.take);
			} else if (query?.take) {
				results = results.slice(0, query.take);
			}

			return results as QcGroup[];
		}
		const response = await apiClient.qcGroupControllerFindAll(query);
		return (response.data as any) || [];
	},

	/**
	 * Create a new QcGroup
	 * @param qcGroup - The QcGroup data to create
	 * @returns Promise<QcGroup>
	 */
	async qcGroupControllerCreate(qcGroup: QcGroup): Promise<QcGroup> {
		if (getMode() === WorkMode.OFFLINE) {
			await db.QAQC_QCGroup.add(qcGroup);
			const result = await db.QAQC_QCGroup.get(qcGroup.QCGroupId);
			if (!result) {
				throw new Error(`Failed to create QcGroup: ${qcGroup.QCGroupId}`);
			}
			return result;
		}
		return (await apiClient.qcGroupControllerCreate(qcGroup)).data;
	},

	/**
	 * Update a QcGroup
	 * @param qCGroupId - The QCGroupId to update
	 * @param qcGroup - The updated QcGroup data
	 * @returns Promise<QcGroup>
	 */
	async qcGroupControllerUpdate(qCGroupId: string, qcGroup: QcGroup): Promise<QcGroup> {
		if (getMode() === WorkMode.OFFLINE) {
			const numAffected = await db.QAQC_QCGroup.update(qCGroupId, qcGroup as any);
			let result;
			if (numAffected > 0) {
				result = await db.QAQC_QCGroup.get(qCGroupId);
			}
			if (!result) {
				throw new Error(`QcGroup not found: ${qCGroupId}`);
			}
			return result;
		}
		return (await apiClient.qcGroupControllerUpdate(qCGroupId, qcGroup)).data;
	},

	/**
	 * Remove (soft delete) a QcGroup
	 * Calls the API Remove endpoint which sets ActiveInd to false
	 * @param qCGroupId - The QCGroupId to remove
	 * @param qcGroup - The QcGroup data
	 * @returns Promise<QcGroup>
	 */
	async qcGroupControllerRemove(qCGroupId: string, qcGroup: QcGroup): Promise<QcGroup> {
		if (getMode() === WorkMode.OFFLINE) {
			// In offline mode, soft delete by updating ActiveInd
			const numAffected = await db.QAQC_QCGroup.update(qCGroupId, { ...qcGroup, ActiveInd: false });
			let result;
			if (numAffected > 0) {
				result = await db.QAQC_QCGroup.get(qCGroupId);
			}
			if (!result) {
				throw new Error(`QcGroup not found: ${qCGroupId}`);
			}
			return result;
		}
		// In online mode, call the API's Remove endpoint
		return (await apiClient.qcGroupControllerUpdate(qCGroupId, { ...qcGroup, ActiveInd: false })).data;
	},

	/**
	 * Find a single QcInsertionRule by ID
	 * @param qCInsertionRuleId - The QCInsertionRuleId to find
	 * @returns Promise<QcInsertionRule>
	 */
	async qcInsertionRuleControllerFindOne(qCInsertionRuleId: string): Promise<QcInsertionRule> {
		if (getMode() === WorkMode.OFFLINE) {
			const result = await db.QAQC_QCInsertionRule.get(qCInsertionRuleId);
			if (!result) {
				throw new Error(`QcInsertionRule not found: ${qCInsertionRuleId}`);
			}
			return result;
		}
		return (await apiClient.qcInsertionRuleControllerFindOne(qCInsertionRuleId)).data;
	},

	/**
	 * Find all QcInsertionRule records with optional filtering
	 * @param query - Optional query parameters for filtering, pagination, etc.
	 * @returns Promise<QcInsertionRule[]>
	 */
	async qcInsertionRuleControllerFindAll(query?: {
		page?: number;
		take?: number;
		order?: "ASC" | "DESC";
		search?: string;
		filters?: string | FilterInput;
		sorts?: string;
	}): Promise<QcInsertionRule[]> {
		if (getMode() === WorkMode.OFFLINE) {
			let collection = db.QAQC_QCInsertionRule.toCollection();

			// Get results as array
			let results = await collection.toArray();

			// Apply ALL filters on array
			if (query?.filters) {
				const filters = parseFiltersForDexie(query.filters);
				if (filters.length > 0) {
					for (const filter of filters) {
						const { field, op, value } = filter;
						switch (op) {
							case 'eq':
								results = results.filter((item: any) => item[field] === value);
								break;
							case 'neq':
								results = results.filter((item: any) => item[field] !== value);
								break;
							case 'gt':
								results = results.filter((item: any) => item[field] > value);
								break;
							case 'gte':
								results = results.filter((item: any) => item[field] >= value);
								break;
							case 'lt':
								results = results.filter((item: any) => item[field] < value);
								break;
							case 'lte':
								results = results.filter((item: any) => item[field] <= value);
								break;
							case 'contains':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().includes(String(value).toLowerCase())
								);
								break;
							case 'startsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().startsWith(String(value).toLowerCase())
								);
								break;
							case 'endsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().endsWith(String(value).toLowerCase())
								);
								break;
							case 'in':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => value.includes(item[field]));
								}
								break;
							case 'notIn':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => !value.includes(item[field]));
								}
								break;
						}
					}
				}
			}

			// Apply search (on array)
			if (query?.search) {
				const searchLower = query.search.toLowerCase();
				results = results.filter((item: any) =>
					Object.values(item).some(val =>
						typeof val === 'string' && val.toLowerCase().includes(searchLower)
					)
				);
			}

			// Apply sorting
			if (query?.sorts) {
				try {
					const sortFields = JSON.parse(query.sorts);
					if (Array.isArray(sortFields) && sortFields.length > 0) {
						results.sort((a: any, b: any) => {
							for (const sort of sortFields) {
								const { field, dir } = sort;
								const aVal = a[field];
								const bVal = b[field];
								if (aVal === bVal) continue;
								const comparison = aVal < bVal ? -1 : 1;
								return dir === 'desc' ? -comparison : comparison;
							}
							return 0;
						}
						);
					}
				} catch {
					// Invalid sorts format, skip
				}
			}

			// Apply pagination
			if (query?.page && query?.take) {
				const skip = (query.page - 1) * query.take;
				results = results.slice(skip, skip + query.take);
			} else if (query?.take) {
				results = results.slice(0, query.take);
			}

			return results as QcInsertionRule[];
		}
		const response = await apiClient.qcInsertionRuleControllerFindAll(query);
		return (response.data as any) || [];
	},

	/**
	 * Create a new QcInsertionRule
	 * @param qcInsertionRule - The QcInsertionRule data to create
	 * @returns Promise<QcInsertionRule>
	 */
	async qcInsertionRuleControllerCreate(qcInsertionRule: QcInsertionRule): Promise<QcInsertionRule> {
		if (getMode() === WorkMode.OFFLINE) {
			await db.QAQC_QCInsertionRule.add(qcInsertionRule);
			const result = await db.QAQC_QCInsertionRule.get(qcInsertionRule.QCInsertionRuleId);
			if (!result) {
				throw new Error(`Failed to create QcInsertionRule: ${qcInsertionRule.QCInsertionRuleId}`);
			}
			return result;
		}
		return (await apiClient.qcInsertionRuleControllerCreate(qcInsertionRule)).data;
	},

	/**
	 * Update a QcInsertionRule
	 * @param qCInsertionRuleId - The QCInsertionRuleId to update
	 * @param qcInsertionRule - The updated QcInsertionRule data
	 * @returns Promise<QcInsertionRule>
	 */
	async qcInsertionRuleControllerUpdate(qCInsertionRuleId: string, qcInsertionRule: QcInsertionRule): Promise<QcInsertionRule> {
		if (getMode() === WorkMode.OFFLINE) {
			const numAffected = await db.QAQC_QCInsertionRule.update(qCInsertionRuleId, qcInsertionRule as any);
			let result;
			if (numAffected > 0) {
				result = await db.QAQC_QCInsertionRule.get(qCInsertionRuleId);
			}
			if (!result) {
				throw new Error(`QcInsertionRule not found: ${qCInsertionRuleId}`);
			}
			return result;
		}
		return (await apiClient.qcInsertionRuleControllerUpdate(qCInsertionRuleId, qcInsertionRule)).data;
	},

	/**
	 * Remove (soft delete) a QcInsertionRule
	 * Calls the API Remove endpoint which sets ActiveInd to false
	 * @param qCInsertionRuleId - The QCInsertionRuleId to remove
	 * @param qcInsertionRule - The QcInsertionRule data
	 * @returns Promise<QcInsertionRule>
	 */
	async qcInsertionRuleControllerRemove(qCInsertionRuleId: string, qcInsertionRule: QcInsertionRule): Promise<QcInsertionRule> {
		if (getMode() === WorkMode.OFFLINE) {
			// In offline mode, soft delete by updating ActiveInd
			const numAffected = await db.QAQC_QCInsertionRule.update(qCInsertionRuleId, { ...qcInsertionRule, ActiveInd: false });
			let result;
			if (numAffected > 0) {
				result = await db.QAQC_QCInsertionRule.get(qCInsertionRuleId);
			}
			if (!result) {
				throw new Error(`QcInsertionRule not found: ${qCInsertionRuleId}`);
			}
			return result;
		}
		// In online mode, call the API's Remove endpoint
		return (await apiClient.qcInsertionRuleControllerUpdate(qCInsertionRuleId, { ...qcInsertionRule, ActiveInd: false })).data;
	},

	/**
	 * Find a single QcInsertionRuleStandardSequence by ID
	 * @param qCInsertionRuleStandardSequenceId - The QCInsertionRuleStandardSequenceId to find
	 * @returns Promise<QcInsertionRuleStandardSequence>
	 */
	async qcInsertionRuleStandardSequenceControllerFindOne(qCInsertionRuleStandardSequenceId: string): Promise<QcInsertionRuleStandardSequence> {
		if (getMode() === WorkMode.OFFLINE) {
			const result = await db.QAQC_QCInsertionRuleStandardSequence.get(qCInsertionRuleStandardSequenceId);
			if (!result) {
				throw new Error(`QcInsertionRuleStandardSequence not found: ${qCInsertionRuleStandardSequenceId}`);
			}
			return result;
		}
		return (await apiClient.qcInsertionRuleStandardSequenceControllerFindOne(qCInsertionRuleStandardSequenceId)).data;
	},

	/**
	 * Find all QcInsertionRuleStandardSequence records with optional filtering
	 * @param query - Optional query parameters for filtering, pagination, etc.
	 * @returns Promise<QcInsertionRuleStandardSequence[]>
	 */
	async qcInsertionRuleStandardSequenceControllerFindAll(query?: {
		page?: number;
		take?: number;
		order?: "ASC" | "DESC";
		search?: string;
		filters?: string | FilterInput;
		sorts?: string;
	}): Promise<QcInsertionRuleStandardSequence[]> {
		if (getMode() === WorkMode.OFFLINE) {
			let collection = db.QAQC_QCInsertionRuleStandardSequence.toCollection();

			// Get results as array
			let results = await collection.toArray();

			// Apply ALL filters on array
			if (query?.filters) {
				const filters = parseFiltersForDexie(query.filters);
				if (filters.length > 0) {
					for (const filter of filters) {
						const { field, op, value } = filter;
						switch (op) {
							case 'eq':
								results = results.filter((item: any) => item[field] === value);
								break;
							case 'neq':
								results = results.filter((item: any) => item[field] !== value);
								break;
							case 'gt':
								results = results.filter((item: any) => item[field] > value);
								break;
							case 'gte':
								results = results.filter((item: any) => item[field] >= value);
								break;
							case 'lt':
								results = results.filter((item: any) => item[field] < value);
								break;
							case 'lte':
								results = results.filter((item: any) => item[field] <= value);
								break;
							case 'contains':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().includes(String(value).toLowerCase())
								);
								break;
							case 'startsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().startsWith(String(value).toLowerCase())
								);
								break;
							case 'endsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().endsWith(String(value).toLowerCase())
								);
								break;
							case 'in':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => value.includes(item[field]));
								}
								break;
							case 'notIn':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => !value.includes(item[field]));
								}
								break;
						}
					}
				}
			}

			// Apply search (on array)
			if (query?.search) {
				const searchLower = query.search.toLowerCase();
				results = results.filter((item: any) =>
					Object.values(item).some(val =>
						typeof val === 'string' && val.toLowerCase().includes(searchLower)
					)
				);
			}

			// Apply sorting
			if (query?.sorts) {
				try {
					const sortFields = JSON.parse(query.sorts);
					if (Array.isArray(sortFields) && sortFields.length > 0) {
						results.sort((a: any, b: any) => {
							for (const sort of sortFields) {
								const { field, dir } = sort;
								const aVal = a[field];
								const bVal = b[field];
								if (aVal === bVal) continue;
								const comparison = aVal < bVal ? -1 : 1;
								return dir === 'desc' ? -comparison : comparison;
							}
							return 0;
						}
						);
					}
				} catch {
					// Invalid sorts format, skip
				}
			}

			// Apply pagination
			if (query?.page && query?.take) {
				const skip = (query.page - 1) * query.take;
				results = results.slice(skip, skip + query.take);
			} else if (query?.take) {
				results = results.slice(0, query.take);
			}

			return results as QcInsertionRuleStandardSequence[];
		}
		const response = await apiClient.qcInsertionRuleStandardSequenceControllerFindAll(query);
		return (response.data as any) || [];
	},

	/**
	 * Create a new QcInsertionRuleStandardSequence
	 * @param qcInsertionRuleStandardSequence - The QcInsertionRuleStandardSequence data to create
	 * @returns Promise<QcInsertionRuleStandardSequence>
	 */
	async qcInsertionRuleStandardSequenceControllerCreate(qcInsertionRuleStandardSequence: QcInsertionRuleStandardSequence): Promise<QcInsertionRuleStandardSequence> {
		if (getMode() === WorkMode.OFFLINE) {
			await db.QAQC_QCInsertionRuleStandardSequence.add(qcInsertionRuleStandardSequence);
			const result = await db.QAQC_QCInsertionRuleStandardSequence.get(qcInsertionRuleStandardSequence.QCInsertionRuleStandardSequenceId);
			if (!result) {
				throw new Error(`Failed to create QcInsertionRuleStandardSequence: ${qcInsertionRuleStandardSequence.QCInsertionRuleStandardSequenceId}`);
			}
			return result;
		}
		return (await apiClient.qcInsertionRuleStandardSequenceControllerCreate(qcInsertionRuleStandardSequence)).data;
	},

	/**
	 * Update a QcInsertionRuleStandardSequence
	 * @param qCInsertionRuleStandardSequenceId - The QCInsertionRuleStandardSequenceId to update
	 * @param qcInsertionRuleStandardSequence - The updated QcInsertionRuleStandardSequence data
	 * @returns Promise<QcInsertionRuleStandardSequence>
	 */
	async qcInsertionRuleStandardSequenceControllerUpdate(qCInsertionRuleStandardSequenceId: string, qcInsertionRuleStandardSequence: QcInsertionRuleStandardSequence): Promise<QcInsertionRuleStandardSequence> {
		if (getMode() === WorkMode.OFFLINE) {
			const numAffected = await db.QAQC_QCInsertionRuleStandardSequence.update(qCInsertionRuleStandardSequenceId, qcInsertionRuleStandardSequence as any);
			let result;
			if (numAffected > 0) {
				result = await db.QAQC_QCInsertionRuleStandardSequence.get(qCInsertionRuleStandardSequenceId);
			}
			if (!result) {
				throw new Error(`QcInsertionRuleStandardSequence not found: ${qCInsertionRuleStandardSequenceId}`);
			}
			return result;
		}
		return (await apiClient.qcInsertionRuleStandardSequenceControllerUpdate(qCInsertionRuleStandardSequenceId, qcInsertionRuleStandardSequence)).data;
	},

	/**
	 * Remove (soft delete) a QcInsertionRuleStandardSequence
	 * Calls the API Remove endpoint which sets ActiveInd to false
	 * @param qCInsertionRuleStandardSequenceId - The QCInsertionRuleStandardSequenceId to remove
	 * @param qcInsertionRuleStandardSequence - The QcInsertionRuleStandardSequence data
	 * @returns Promise<QcInsertionRuleStandardSequence>
	 */
	async qcInsertionRuleStandardSequenceControllerRemove(qCInsertionRuleStandardSequenceId: string, qcInsertionRuleStandardSequence: QcInsertionRuleStandardSequence): Promise<QcInsertionRuleStandardSequence> {
		if (getMode() === WorkMode.OFFLINE) {
			// In offline mode, soft delete by updating ActiveInd
			const numAffected = await db.QAQC_QCInsertionRuleStandardSequence.update(qCInsertionRuleStandardSequenceId, { ...qcInsertionRuleStandardSequence, ActiveInd: false });
			let result;
			if (numAffected > 0) {
				result = await db.QAQC_QCInsertionRuleStandardSequence.get(qCInsertionRuleStandardSequenceId);
			}
			if (!result) {
				throw new Error(`QcInsertionRuleStandardSequence not found: ${qCInsertionRuleStandardSequenceId}`);
			}
			return result;
		}
		// In online mode, call the API's Remove endpoint
		return (await apiClient.qcInsertionRuleStandardSequenceControllerUpdate(qCInsertionRuleStandardSequenceId, { ...qcInsertionRuleStandardSequence, ActiveInd: false })).data;
	},

	/**
	 * Find a single QcReference by ID
	 * @param qCReferenceId - The QCReferenceId to find
	 * @returns Promise<QcReference>
	 */
	async qcReferenceControllerFindOne(qCReferenceId: string): Promise<QcReference> {
		if (getMode() === WorkMode.OFFLINE) {
			const result = await db.QAQC_QCReference.get(qCReferenceId);
			if (!result) {
				throw new Error(`QcReference not found: ${qCReferenceId}`);
			}
			return result;
		}
		return (await apiClient.qcReferenceControllerFindOne(qCReferenceId)).data;
	},

	/**
	 * Find all QcReference records with optional filtering
	 * @param query - Optional query parameters for filtering, pagination, etc.
	 * @returns Promise<QcReference[]>
	 */
	async qcReferenceControllerFindAll(query?: {
		page?: number;
		take?: number;
		order?: "ASC" | "DESC";
		search?: string;
		filters?: string | FilterInput;
		sorts?: string;
	}): Promise<QcReference[]> {
		if (getMode() === WorkMode.OFFLINE) {
			let collection = db.QAQC_QCReference.toCollection();

			// Get results as array
			let results = await collection.toArray();

			// Apply ALL filters on array
			if (query?.filters) {
				const filters = parseFiltersForDexie(query.filters);
				if (filters.length > 0) {
					for (const filter of filters) {
						const { field, op, value } = filter;
						switch (op) {
							case 'eq':
								results = results.filter((item: any) => item[field] === value);
								break;
							case 'neq':
								results = results.filter((item: any) => item[field] !== value);
								break;
							case 'gt':
								results = results.filter((item: any) => item[field] > value);
								break;
							case 'gte':
								results = results.filter((item: any) => item[field] >= value);
								break;
							case 'lt':
								results = results.filter((item: any) => item[field] < value);
								break;
							case 'lte':
								results = results.filter((item: any) => item[field] <= value);
								break;
							case 'contains':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().includes(String(value).toLowerCase())
								);
								break;
							case 'startsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().startsWith(String(value).toLowerCase())
								);
								break;
							case 'endsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().endsWith(String(value).toLowerCase())
								);
								break;
							case 'in':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => value.includes(item[field]));
								}
								break;
							case 'notIn':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => !value.includes(item[field]));
								}
								break;
						}
					}
				}
			}

			// Apply search (on array)
			if (query?.search) {
				const searchLower = query.search.toLowerCase();
				results = results.filter((item: any) =>
					Object.values(item).some(val =>
						typeof val === 'string' && val.toLowerCase().includes(searchLower)
					)
				);
			}

			// Apply sorting
			if (query?.sorts) {
				try {
					const sortFields = JSON.parse(query.sorts);
					if (Array.isArray(sortFields) && sortFields.length > 0) {
						results.sort((a: any, b: any) => {
							for (const sort of sortFields) {
								const { field, dir } = sort;
								const aVal = a[field];
								const bVal = b[field];
								if (aVal === bVal) continue;
								const comparison = aVal < bVal ? -1 : 1;
								return dir === 'desc' ? -comparison : comparison;
							}
							return 0;
						}
						);
					}
				} catch {
					// Invalid sorts format, skip
				}
			}

			// Apply pagination
			if (query?.page && query?.take) {
				const skip = (query.page - 1) * query.take;
				results = results.slice(skip, skip + query.take);
			} else if (query?.take) {
				results = results.slice(0, query.take);
			}

			return results as QcReference[];
		}
		const response = await apiClient.qcReferenceControllerFindAll(query);
		return (response.data as any) || [];
	},

	/**
	 * Create a new QcReference
	 * @param qcReference - The QcReference data to create
	 * @returns Promise<QcReference>
	 */
	async qcReferenceControllerCreate(qcReference: QcReference): Promise<QcReference> {
		if (getMode() === WorkMode.OFFLINE) {
			await db.QAQC_QCReference.add(qcReference);
			const result = await db.QAQC_QCReference.get(qcReference.QCReferenceId);
			if (!result) {
				throw new Error(`Failed to create QcReference: ${qcReference.QCReferenceId}`);
			}
			return result;
		}
		return (await apiClient.qcReferenceControllerCreate(qcReference)).data;
	},

	/**
	 * Update a QcReference
	 * @param qCReferenceId - The QCReferenceId to update
	 * @param qcReference - The updated QcReference data
	 * @returns Promise<QcReference>
	 */
	async qcReferenceControllerUpdate(qCReferenceId: string, qcReference: QcReference): Promise<QcReference> {
		if (getMode() === WorkMode.OFFLINE) {
			const numAffected = await db.QAQC_QCReference.update(qCReferenceId, qcReference as any);
			let result;
			if (numAffected > 0) {
				result = await db.QAQC_QCReference.get(qCReferenceId);
			}
			if (!result) {
				throw new Error(`QcReference not found: ${qCReferenceId}`);
			}
			return result;
		}
		return (await apiClient.qcReferenceControllerUpdate(qCReferenceId, qcReference)).data;
	},

	/**
	 * Remove (soft delete) a QcReference
	 * Calls the API Remove endpoint which sets ActiveInd to false
	 * @param qCReferenceId - The QCReferenceId to remove
	 * @param qcReference - The QcReference data
	 * @returns Promise<QcReference>
	 */
	async qcReferenceControllerRemove(qCReferenceId: string, qcReference: QcReference): Promise<QcReference> {
		if (getMode() === WorkMode.OFFLINE) {
			// In offline mode, soft delete by updating ActiveInd
			const numAffected = await db.QAQC_QCReference.update(qCReferenceId, { ...qcReference, ActiveInd: false });
			let result;
			if (numAffected > 0) {
				result = await db.QAQC_QCReference.get(qCReferenceId);
			}
			if (!result) {
				throw new Error(`QcReference not found: ${qCReferenceId}`);
			}
			return result;
		}
		// In online mode, call the API's Remove endpoint
		return (await apiClient.qcReferenceControllerUpdate(qCReferenceId, { ...qcReference, ActiveInd: false })).data;
	},

	/**
	 * Find a single QcReferenceType by ID
	 * @param qCReferenceTypeId - The QCReferenceTypeId to find
	 * @returns Promise<QcReferenceType>
	 */
	async qcReferenceTypeControllerFindOne(qCReferenceTypeId: string): Promise<QcReferenceType> {
		if (getMode() === WorkMode.OFFLINE) {
			const result = await db.QAQC_QCReferenceType.get(qCReferenceTypeId);
			if (!result) {
				throw new Error(`QcReferenceType not found: ${qCReferenceTypeId}`);
			}
			return result;
		}
		return (await apiClient.qcReferenceTypeControllerFindOne(qCReferenceTypeId)).data;
	},

	/**
	 * Find all QcReferenceType records with optional filtering
	 * @param query - Optional query parameters for filtering, pagination, etc.
	 * @returns Promise<QcReferenceType[]>
	 */
	async qcReferenceTypeControllerFindAll(query?: {
		page?: number;
		take?: number;
		order?: "ASC" | "DESC";
		search?: string;
		filters?: string | FilterInput;
		sorts?: string;
	}): Promise<QcReferenceType[]> {
		if (getMode() === WorkMode.OFFLINE) {
			let collection = db.QAQC_QCReferenceType.toCollection();

			// Get results as array
			let results = await collection.toArray();

			// Apply ALL filters on array
			if (query?.filters) {
				const filters = parseFiltersForDexie(query.filters);
				if (filters.length > 0) {
					for (const filter of filters) {
						const { field, op, value } = filter;
						switch (op) {
							case 'eq':
								results = results.filter((item: any) => item[field] === value);
								break;
							case 'neq':
								results = results.filter((item: any) => item[field] !== value);
								break;
							case 'gt':
								results = results.filter((item: any) => item[field] > value);
								break;
							case 'gte':
								results = results.filter((item: any) => item[field] >= value);
								break;
							case 'lt':
								results = results.filter((item: any) => item[field] < value);
								break;
							case 'lte':
								results = results.filter((item: any) => item[field] <= value);
								break;
							case 'contains':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().includes(String(value).toLowerCase())
								);
								break;
							case 'startsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().startsWith(String(value).toLowerCase())
								);
								break;
							case 'endsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().endsWith(String(value).toLowerCase())
								);
								break;
							case 'in':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => value.includes(item[field]));
								}
								break;
							case 'notIn':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => !value.includes(item[field]));
								}
								break;
						}
					}
				}
			}

			// Apply search (on array)
			if (query?.search) {
				const searchLower = query.search.toLowerCase();
				results = results.filter((item: any) =>
					Object.values(item).some(val =>
						typeof val === 'string' && val.toLowerCase().includes(searchLower)
					)
				);
			}

			// Apply sorting
			if (query?.sorts) {
				try {
					const sortFields = JSON.parse(query.sorts);
					if (Array.isArray(sortFields) && sortFields.length > 0) {
						results.sort((a: any, b: any) => {
							for (const sort of sortFields) {
								const { field, dir } = sort;
								const aVal = a[field];
								const bVal = b[field];
								if (aVal === bVal) continue;
								const comparison = aVal < bVal ? -1 : 1;
								return dir === 'desc' ? -comparison : comparison;
							}
							return 0;
						}
						);
					}
				} catch {
					// Invalid sorts format, skip
				}
			}

			// Apply pagination
			if (query?.page && query?.take) {
				const skip = (query.page - 1) * query.take;
				results = results.slice(skip, skip + query.take);
			} else if (query?.take) {
				results = results.slice(0, query.take);
			}

			return results as QcReferenceType[];
		}
		const response = await apiClient.qcReferenceTypeControllerFindAll(query);
		return (response.data as any) || [];
	},

	/**
	 * Create a new QcReferenceType
	 * @param qcReferenceType - The QcReferenceType data to create
	 * @returns Promise<QcReferenceType>
	 */
	async qcReferenceTypeControllerCreate(qcReferenceType: QcReferenceType): Promise<QcReferenceType> {
		if (getMode() === WorkMode.OFFLINE) {
			await db.QAQC_QCReferenceType.add(qcReferenceType);
			const result = await db.QAQC_QCReferenceType.get(qcReferenceType.QCReferenceTypeId);
			if (!result) {
				throw new Error(`Failed to create QcReferenceType: ${qcReferenceType.QCReferenceTypeId}`);
			}
			return result;
		}
		return (await apiClient.qcReferenceTypeControllerCreate(qcReferenceType)).data;
	},

	/**
	 * Update a QcReferenceType
	 * @param qCReferenceTypeId - The QCReferenceTypeId to update
	 * @param qcReferenceType - The updated QcReferenceType data
	 * @returns Promise<QcReferenceType>
	 */
	async qcReferenceTypeControllerUpdate(qCReferenceTypeId: string, qcReferenceType: QcReferenceType): Promise<QcReferenceType> {
		if (getMode() === WorkMode.OFFLINE) {
			const numAffected = await db.QAQC_QCReferenceType.update(qCReferenceTypeId, qcReferenceType as any);
			let result;
			if (numAffected > 0) {
				result = await db.QAQC_QCReferenceType.get(qCReferenceTypeId);
			}
			if (!result) {
				throw new Error(`QcReferenceType not found: ${qCReferenceTypeId}`);
			}
			return result;
		}
		return (await apiClient.qcReferenceTypeControllerUpdate(qCReferenceTypeId, qcReferenceType)).data;
	},

	/**
	 * Remove (soft delete) a QcReferenceType
	 * Calls the API Remove endpoint which sets ActiveInd to false
	 * @param qCReferenceTypeId - The QCReferenceTypeId to remove
	 * @param qcReferenceType - The QcReferenceType data
	 * @returns Promise<QcReferenceType>
	 */
	async qcReferenceTypeControllerRemove(qCReferenceTypeId: string, qcReferenceType: QcReferenceType): Promise<QcReferenceType> {
		if (getMode() === WorkMode.OFFLINE) {
			// In offline mode, soft delete by updating ActiveInd
			const numAffected = await db.QAQC_QCReferenceType.update(qCReferenceTypeId, { ...qcReferenceType, ActiveInd: false });
			let result;
			if (numAffected > 0) {
				result = await db.QAQC_QCReferenceType.get(qCReferenceTypeId);
			}
			if (!result) {
				throw new Error(`QcReferenceType not found: ${qCReferenceTypeId}`);
			}
			return result;
		}
		// In online mode, call the API's Remove endpoint
		return (await apiClient.qcReferenceTypeControllerUpdate(qCReferenceTypeId, { ...qcReferenceType, ActiveInd: false })).data;
	},

	/**
	 * Find a single QcReferenceValue by ID
	 * @param qCReferenceValueId - The QCReferenceValueId to find
	 * @returns Promise<QcReferenceValue>
	 */
	async qcReferenceValueControllerFindOne(qCReferenceValueId: string): Promise<QcReferenceValue> {
		if (getMode() === WorkMode.OFFLINE) {
			const result = await db.QAQC_QCReferenceValue.get(qCReferenceValueId);
			if (!result) {
				throw new Error(`QcReferenceValue not found: ${qCReferenceValueId}`);
			}
			return result;
		}
		return (await apiClient.qcReferenceValueControllerFindOne(qCReferenceValueId)).data;
	},

	/**
	 * Find all QcReferenceValue records with optional filtering
	 * @param query - Optional query parameters for filtering, pagination, etc.
	 * @returns Promise<QcReferenceValue[]>
	 */
	async qcReferenceValueControllerFindAll(query?: {
		page?: number;
		take?: number;
		order?: "ASC" | "DESC";
		search?: string;
		filters?: string | FilterInput;
		sorts?: string;
	}): Promise<QcReferenceValue[]> {
		if (getMode() === WorkMode.OFFLINE) {
			let collection = db.QAQC_QCReferenceValue.toCollection();

			// Get results as array
			let results = await collection.toArray();

			// Apply ALL filters on array
			if (query?.filters) {
				const filters = parseFiltersForDexie(query.filters);
				if (filters.length > 0) {
					for (const filter of filters) {
						const { field, op, value } = filter;
						switch (op) {
							case 'eq':
								results = results.filter((item: any) => item[field] === value);
								break;
							case 'neq':
								results = results.filter((item: any) => item[field] !== value);
								break;
							case 'gt':
								results = results.filter((item: any) => item[field] > value);
								break;
							case 'gte':
								results = results.filter((item: any) => item[field] >= value);
								break;
							case 'lt':
								results = results.filter((item: any) => item[field] < value);
								break;
							case 'lte':
								results = results.filter((item: any) => item[field] <= value);
								break;
							case 'contains':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().includes(String(value).toLowerCase())
								);
								break;
							case 'startsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().startsWith(String(value).toLowerCase())
								);
								break;
							case 'endsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().endsWith(String(value).toLowerCase())
								);
								break;
							case 'in':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => value.includes(item[field]));
								}
								break;
							case 'notIn':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => !value.includes(item[field]));
								}
								break;
						}
					}
				}
			}

			// Apply search (on array)
			if (query?.search) {
				const searchLower = query.search.toLowerCase();
				results = results.filter((item: any) =>
					Object.values(item).some(val =>
						typeof val === 'string' && val.toLowerCase().includes(searchLower)
					)
				);
			}

			// Apply sorting
			if (query?.sorts) {
				try {
					const sortFields = JSON.parse(query.sorts);
					if (Array.isArray(sortFields) && sortFields.length > 0) {
						results.sort((a: any, b: any) => {
							for (const sort of sortFields) {
								const { field, dir } = sort;
								const aVal = a[field];
								const bVal = b[field];
								if (aVal === bVal) continue;
								const comparison = aVal < bVal ? -1 : 1;
								return dir === 'desc' ? -comparison : comparison;
							}
							return 0;
						}
						);
					}
				} catch {
					// Invalid sorts format, skip
				}
			}

			// Apply pagination
			if (query?.page && query?.take) {
				const skip = (query.page - 1) * query.take;
				results = results.slice(skip, skip + query.take);
			} else if (query?.take) {
				results = results.slice(0, query.take);
			}

			return results as QcReferenceValue[];
		}
		const response = await apiClient.qcReferenceValueControllerFindAll(query);
		return (response.data as any) || [];
	},

	/**
	 * Create a new QcReferenceValue
	 * @param qcReferenceValue - The QcReferenceValue data to create
	 * @returns Promise<QcReferenceValue>
	 */
	async qcReferenceValueControllerCreate(qcReferenceValue: QcReferenceValue): Promise<QcReferenceValue> {
		if (getMode() === WorkMode.OFFLINE) {
			await db.QAQC_QCReferenceValue.add(qcReferenceValue);
			const result = await db.QAQC_QCReferenceValue.get(qcReferenceValue.QCReferenceValueId);
			if (!result) {
				throw new Error(`Failed to create QcReferenceValue: ${qcReferenceValue.QCReferenceValueId}`);
			}
			return result;
		}
		return (await apiClient.qcReferenceValueControllerCreate(qcReferenceValue)).data;
	},

	/**
	 * Update a QcReferenceValue
	 * @param qCReferenceValueId - The QCReferenceValueId to update
	 * @param qcReferenceValue - The updated QcReferenceValue data
	 * @returns Promise<QcReferenceValue>
	 */
	async qcReferenceValueControllerUpdate(qCReferenceValueId: string, qcReferenceValue: QcReferenceValue): Promise<QcReferenceValue> {
		if (getMode() === WorkMode.OFFLINE) {
			const numAffected = await db.QAQC_QCReferenceValue.update(qCReferenceValueId, qcReferenceValue as any);
			let result;
			if (numAffected > 0) {
				result = await db.QAQC_QCReferenceValue.get(qCReferenceValueId);
			}
			if (!result) {
				throw new Error(`QcReferenceValue not found: ${qCReferenceValueId}`);
			}
			return result;
		}
		return (await apiClient.qcReferenceValueControllerUpdate(qCReferenceValueId, qcReferenceValue)).data;
	},

	/**
	 * Remove (soft delete) a QcReferenceValue
	 * Calls the API Remove endpoint which sets ActiveInd to false
	 * @param qCReferenceValueId - The QCReferenceValueId to remove
	 * @param qcReferenceValue - The QcReferenceValue data
	 * @returns Promise<QcReferenceValue>
	 */
	async qcReferenceValueControllerRemove(qCReferenceValueId: string, qcReferenceValue: QcReferenceValue): Promise<QcReferenceValue> {
		if (getMode() === WorkMode.OFFLINE) {
			// In offline mode, soft delete by updating ActiveInd
			const numAffected = await db.QAQC_QCReferenceValue.update(qCReferenceValueId, { ...qcReferenceValue, ActiveInd: false });
			let result;
			if (numAffected > 0) {
				result = await db.QAQC_QCReferenceValue.get(qCReferenceValueId);
			}
			if (!result) {
				throw new Error(`QcReferenceValue not found: ${qCReferenceValueId}`);
			}
			return result;
		}
		// In online mode, call the API's Remove endpoint
		return (await apiClient.qcReferenceValueControllerUpdate(qCReferenceValueId, { ...qcReferenceValue, ActiveInd: false })).data;
	},

	/**
	 * Find a single QcReferenceValueType by ID
	 * @param qCReferenceValueTypeId - The QCReferenceValueTypeId to find
	 * @returns Promise<QcReferenceValueType>
	 */
	async qcReferenceValueTypeControllerFindOne(qCReferenceValueTypeId: string): Promise<QcReferenceValueType> {
		if (getMode() === WorkMode.OFFLINE) {
			const result = await db.QAQC_QCReferenceValueType.get(qCReferenceValueTypeId);
			if (!result) {
				throw new Error(`QcReferenceValueType not found: ${qCReferenceValueTypeId}`);
			}
			return result;
		}
		return (await apiClient.qcReferenceValueTypeControllerFindOne(qCReferenceValueTypeId)).data;
	},

	/**
	 * Find all QcReferenceValueType records with optional filtering
	 * @param query - Optional query parameters for filtering, pagination, etc.
	 * @returns Promise<QcReferenceValueType[]>
	 */
	async qcReferenceValueTypeControllerFindAll(query?: {
		page?: number;
		take?: number;
		order?: "ASC" | "DESC";
		search?: string;
		filters?: string | FilterInput;
		sorts?: string;
	}): Promise<QcReferenceValueType[]> {
		if (getMode() === WorkMode.OFFLINE) {
			let collection = db.QAQC_QCReferenceValueType.toCollection();

			// Get results as array
			let results = await collection.toArray();

			// Apply ALL filters on array
			if (query?.filters) {
				const filters = parseFiltersForDexie(query.filters);
				if (filters.length > 0) {
					for (const filter of filters) {
						const { field, op, value } = filter;
						switch (op) {
							case 'eq':
								results = results.filter((item: any) => item[field] === value);
								break;
							case 'neq':
								results = results.filter((item: any) => item[field] !== value);
								break;
							case 'gt':
								results = results.filter((item: any) => item[field] > value);
								break;
							case 'gte':
								results = results.filter((item: any) => item[field] >= value);
								break;
							case 'lt':
								results = results.filter((item: any) => item[field] < value);
								break;
							case 'lte':
								results = results.filter((item: any) => item[field] <= value);
								break;
							case 'contains':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().includes(String(value).toLowerCase())
								);
								break;
							case 'startsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().startsWith(String(value).toLowerCase())
								);
								break;
							case 'endsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().endsWith(String(value).toLowerCase())
								);
								break;
							case 'in':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => value.includes(item[field]));
								}
								break;
							case 'notIn':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => !value.includes(item[field]));
								}
								break;
						}
					}
				}
			}

			// Apply search (on array)
			if (query?.search) {
				const searchLower = query.search.toLowerCase();
				results = results.filter((item: any) =>
					Object.values(item).some(val =>
						typeof val === 'string' && val.toLowerCase().includes(searchLower)
					)
				);
			}

			// Apply sorting
			if (query?.sorts) {
				try {
					const sortFields = JSON.parse(query.sorts);
					if (Array.isArray(sortFields) && sortFields.length > 0) {
						results.sort((a: any, b: any) => {
							for (const sort of sortFields) {
								const { field, dir } = sort;
								const aVal = a[field];
								const bVal = b[field];
								if (aVal === bVal) continue;
								const comparison = aVal < bVal ? -1 : 1;
								return dir === 'desc' ? -comparison : comparison;
							}
							return 0;
						}
						);
					}
				} catch {
					// Invalid sorts format, skip
				}
			}

			// Apply pagination
			if (query?.page && query?.take) {
				const skip = (query.page - 1) * query.take;
				results = results.slice(skip, skip + query.take);
			} else if (query?.take) {
				results = results.slice(0, query.take);
			}

			return results as QcReferenceValueType[];
		}
		const response = await apiClient.qcReferenceValueTypeControllerFindAll(query);
		return (response.data as any) || [];
	},

	/**
	 * Create a new QcReferenceValueType
	 * @param qcReferenceValueType - The QcReferenceValueType data to create
	 * @returns Promise<QcReferenceValueType>
	 */
	async qcReferenceValueTypeControllerCreate(qcReferenceValueType: QcReferenceValueType): Promise<QcReferenceValueType> {
		if (getMode() === WorkMode.OFFLINE) {
			await db.QAQC_QCReferenceValueType.add(qcReferenceValueType);
			const result = await db.QAQC_QCReferenceValueType.get(qcReferenceValueType.QCReferenceValueTypeId);
			if (!result) {
				throw new Error(`Failed to create QcReferenceValueType: ${qcReferenceValueType.QCReferenceValueTypeId}`);
			}
			return result;
		}
		return (await apiClient.qcReferenceValueTypeControllerCreate(qcReferenceValueType)).data;
	},

	/**
	 * Update a QcReferenceValueType
	 * @param qCReferenceValueTypeId - The QCReferenceValueTypeId to update
	 * @param qcReferenceValueType - The updated QcReferenceValueType data
	 * @returns Promise<QcReferenceValueType>
	 */
	async qcReferenceValueTypeControllerUpdate(qCReferenceValueTypeId: string, qcReferenceValueType: QcReferenceValueType): Promise<QcReferenceValueType> {
		if (getMode() === WorkMode.OFFLINE) {
			const numAffected = await db.QAQC_QCReferenceValueType.update(qCReferenceValueTypeId, qcReferenceValueType as any);
			let result;
			if (numAffected > 0) {
				result = await db.QAQC_QCReferenceValueType.get(qCReferenceValueTypeId);
			}
			if (!result) {
				throw new Error(`QcReferenceValueType not found: ${qCReferenceValueTypeId}`);
			}
			return result;
		}
		return (await apiClient.qcReferenceValueTypeControllerUpdate(qCReferenceValueTypeId, qcReferenceValueType)).data;
	},

	/**
	 * Remove (soft delete) a QcReferenceValueType
	 * Calls the API Remove endpoint which sets ActiveInd to false
	 * @param qCReferenceValueTypeId - The QCReferenceValueTypeId to remove
	 * @param qcReferenceValueType - The QcReferenceValueType data
	 * @returns Promise<QcReferenceValueType>
	 */
	async qcReferenceValueTypeControllerRemove(qCReferenceValueTypeId: string, qcReferenceValueType: QcReferenceValueType): Promise<QcReferenceValueType> {
		if (getMode() === WorkMode.OFFLINE) {
			// In offline mode, soft delete by updating ActiveInd
			const numAffected = await db.QAQC_QCReferenceValueType.update(qCReferenceValueTypeId, { ...qcReferenceValueType, ActiveInd: false });
			let result;
			if (numAffected > 0) {
				result = await db.QAQC_QCReferenceValueType.get(qCReferenceValueTypeId);
			}
			if (!result) {
				throw new Error(`QcReferenceValueType not found: ${qCReferenceValueTypeId}`);
			}
			return result;
		}
		// In online mode, call the API's Remove endpoint
		return (await apiClient.qcReferenceValueTypeControllerUpdate(qCReferenceValueTypeId, { ...qcReferenceValueType, ActiveInd: false })).data;
	},

	/**
	 * Find a single QcRule by ID
	 * @param qCRuleId - The QCRuleId to find
	 * @returns Promise<QcRule>
	 */
	async qcRuleControllerFindOne(qCRuleId: string): Promise<QcRule> {
		if (getMode() === WorkMode.OFFLINE) {
			const result = await db.QAQC_QCRule.get(qCRuleId);
			if (!result) {
				throw new Error(`QcRule not found: ${qCRuleId}`);
			}
			return result;
		}
		return (await apiClient.qcRuleControllerFindOne(qCRuleId)).data;
	},

	/**
	 * Find all QcRule records with optional filtering
	 * @param query - Optional query parameters for filtering, pagination, etc.
	 * @returns Promise<QcRule[]>
	 */
	async qcRuleControllerFindAll(query?: {
		page?: number;
		take?: number;
		order?: "ASC" | "DESC";
		search?: string;
		filters?: string | FilterInput;
		sorts?: string;
	}): Promise<QcRule[]> {
		if (getMode() === WorkMode.OFFLINE) {
			let collection = db.QAQC_QCRule.toCollection();

			// Get results as array
			let results = await collection.toArray();

			// Apply ALL filters on array
			if (query?.filters) {
				const filters = parseFiltersForDexie(query.filters);
				if (filters.length > 0) {
					for (const filter of filters) {
						const { field, op, value } = filter;
						switch (op) {
							case 'eq':
								results = results.filter((item: any) => item[field] === value);
								break;
							case 'neq':
								results = results.filter((item: any) => item[field] !== value);
								break;
							case 'gt':
								results = results.filter((item: any) => item[field] > value);
								break;
							case 'gte':
								results = results.filter((item: any) => item[field] >= value);
								break;
							case 'lt':
								results = results.filter((item: any) => item[field] < value);
								break;
							case 'lte':
								results = results.filter((item: any) => item[field] <= value);
								break;
							case 'contains':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().includes(String(value).toLowerCase())
								);
								break;
							case 'startsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().startsWith(String(value).toLowerCase())
								);
								break;
							case 'endsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().endsWith(String(value).toLowerCase())
								);
								break;
							case 'in':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => value.includes(item[field]));
								}
								break;
							case 'notIn':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => !value.includes(item[field]));
								}
								break;
						}
					}
				}
			}

			// Apply search (on array)
			if (query?.search) {
				const searchLower = query.search.toLowerCase();
				results = results.filter((item: any) =>
					Object.values(item).some(val =>
						typeof val === 'string' && val.toLowerCase().includes(searchLower)
					)
				);
			}

			// Apply sorting
			if (query?.sorts) {
				try {
					const sortFields = JSON.parse(query.sorts);
					if (Array.isArray(sortFields) && sortFields.length > 0) {
						results.sort((a: any, b: any) => {
							for (const sort of sortFields) {
								const { field, dir } = sort;
								const aVal = a[field];
								const bVal = b[field];
								if (aVal === bVal) continue;
								const comparison = aVal < bVal ? -1 : 1;
								return dir === 'desc' ? -comparison : comparison;
							}
							return 0;
						}
						);
					}
				} catch {
					// Invalid sorts format, skip
				}
			}

			// Apply pagination
			if (query?.page && query?.take) {
				const skip = (query.page - 1) * query.take;
				results = results.slice(skip, skip + query.take);
			} else if (query?.take) {
				results = results.slice(0, query.take);
			}

			return results as QcRule[];
		}
		const response = await apiClient.qcRuleControllerFindAll(query);
		return (response.data as any) || [];
	},

	/**
	 * Create a new QcRule
	 * @param qcRule - The QcRule data to create
	 * @returns Promise<QcRule>
	 */
	async qcRuleControllerCreate(qcRule: QcRule): Promise<QcRule> {
		if (getMode() === WorkMode.OFFLINE) {
			await db.QAQC_QCRule.add(qcRule);
			const result = await db.QAQC_QCRule.get(qcRule.QCRuleId);
			if (!result) {
				throw new Error(`Failed to create QcRule: ${qcRule.QCRuleId}`);
			}
			return result;
		}
		return (await apiClient.qcRuleControllerCreate(qcRule)).data;
	},

	/**
	 * Update a QcRule
	 * @param qCRuleId - The QCRuleId to update
	 * @param qcRule - The updated QcRule data
	 * @returns Promise<QcRule>
	 */
	async qcRuleControllerUpdate(qCRuleId: string, qcRule: QcRule): Promise<QcRule> {
		if (getMode() === WorkMode.OFFLINE) {
			const numAffected = await db.QAQC_QCRule.update(qCRuleId, qcRule as any);
			let result;
			if (numAffected > 0) {
				result = await db.QAQC_QCRule.get(qCRuleId);
			}
			if (!result) {
				throw new Error(`QcRule not found: ${qCRuleId}`);
			}
			return result;
		}
		return (await apiClient.qcRuleControllerUpdate(qCRuleId, qcRule)).data;
	},

	/**
	 * Remove (soft delete) a QcRule
	 * Calls the API Remove endpoint which sets ActiveInd to false
	 * @param qCRuleId - The QCRuleId to remove
	 * @param qcRule - The QcRule data
	 * @returns Promise<QcRule>
	 */
	async qcRuleControllerRemove(qCRuleId: string, qcRule: QcRule): Promise<QcRule> {
		if (getMode() === WorkMode.OFFLINE) {
			// In offline mode, soft delete by updating ActiveInd
			const numAffected = await db.QAQC_QCRule.update(qCRuleId, { ...qcRule, ActiveInd: false });
			let result;
			if (numAffected > 0) {
				result = await db.QAQC_QCRule.get(qCRuleId);
			}
			if (!result) {
				throw new Error(`QcRule not found: ${qCRuleId}`);
			}
			return result;
		}
		// In online mode, call the API's Remove endpoint
		return (await apiClient.qcRuleControllerUpdate(qCRuleId, { ...qcRule, ActiveInd: false })).data;
	},

	/**
	 * Find a single QcStatisticalLimits by ID
	 * @param qCStatisticalLimitsId - The QCStatisticalLimitsId to find
	 * @returns Promise<QcStatisticalLimits>
	 */
	async qcStatisticalLimitsControllerFindOne(qCStatisticalLimitsId: string): Promise<QcStatisticalLimits> {
		if (getMode() === WorkMode.OFFLINE) {
			const result = await db.QAQC_QCStatisticalLimits.get(qCStatisticalLimitsId);
			if (!result) {
				throw new Error(`QcStatisticalLimits not found: ${qCStatisticalLimitsId}`);
			}
			return result;
		}
		return (await apiClient.qcStatisticalLimitsControllerFindOne(qCStatisticalLimitsId)).data;
	},

	/**
	 * Find all QcStatisticalLimits records with optional filtering
	 * @param query - Optional query parameters for filtering, pagination, etc.
	 * @returns Promise<QcStatisticalLimits[]>
	 */
	async qcStatisticalLimitsControllerFindAll(query?: {
		page?: number;
		take?: number;
		order?: "ASC" | "DESC";
		search?: string;
		filters?: string | FilterInput;
		sorts?: string;
	}): Promise<QcStatisticalLimits[]> {
		if (getMode() === WorkMode.OFFLINE) {
			let collection = db.QAQC_QCStatisticalLimits.toCollection();

			// Get results as array
			let results = await collection.toArray();

			// Apply ALL filters on array
			if (query?.filters) {
				const filters = parseFiltersForDexie(query.filters);
				if (filters.length > 0) {
					for (const filter of filters) {
						const { field, op, value } = filter;
						switch (op) {
							case 'eq':
								results = results.filter((item: any) => item[field] === value);
								break;
							case 'neq':
								results = results.filter((item: any) => item[field] !== value);
								break;
							case 'gt':
								results = results.filter((item: any) => item[field] > value);
								break;
							case 'gte':
								results = results.filter((item: any) => item[field] >= value);
								break;
							case 'lt':
								results = results.filter((item: any) => item[field] < value);
								break;
							case 'lte':
								results = results.filter((item: any) => item[field] <= value);
								break;
							case 'contains':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().includes(String(value).toLowerCase())
								);
								break;
							case 'startsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().startsWith(String(value).toLowerCase())
								);
								break;
							case 'endsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().endsWith(String(value).toLowerCase())
								);
								break;
							case 'in':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => value.includes(item[field]));
								}
								break;
							case 'notIn':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => !value.includes(item[field]));
								}
								break;
						}
					}
				}
			}

			// Apply search (on array)
			if (query?.search) {
				const searchLower = query.search.toLowerCase();
				results = results.filter((item: any) =>
					Object.values(item).some(val =>
						typeof val === 'string' && val.toLowerCase().includes(searchLower)
					)
				);
			}

			// Apply sorting
			if (query?.sorts) {
				try {
					const sortFields = JSON.parse(query.sorts);
					if (Array.isArray(sortFields) && sortFields.length > 0) {
						results.sort((a: any, b: any) => {
							for (const sort of sortFields) {
								const { field, dir } = sort;
								const aVal = a[field];
								const bVal = b[field];
								if (aVal === bVal) continue;
								const comparison = aVal < bVal ? -1 : 1;
								return dir === 'desc' ? -comparison : comparison;
							}
							return 0;
						}
						);
					}
				} catch {
					// Invalid sorts format, skip
				}
			}

			// Apply pagination
			if (query?.page && query?.take) {
				const skip = (query.page - 1) * query.take;
				results = results.slice(skip, skip + query.take);
			} else if (query?.take) {
				results = results.slice(0, query.take);
			}

			return results as QcStatisticalLimits[];
		}
		const response = await apiClient.qcStatisticalLimitsControllerFindAll(query);
		return (response.data as any) || [];
	},

	/**
	 * Create a new QcStatisticalLimits
	 * @param qcStatisticalLimits - The QcStatisticalLimits data to create
	 * @returns Promise<QcStatisticalLimits>
	 */
	async qcStatisticalLimitsControllerCreate(qcStatisticalLimits: QcStatisticalLimits): Promise<QcStatisticalLimits> {
		if (getMode() === WorkMode.OFFLINE) {
			await db.QAQC_QCStatisticalLimits.add(qcStatisticalLimits);
			const result = await db.QAQC_QCStatisticalLimits.get(qcStatisticalLimits.QCStatisticalLimitsId);
			if (!result) {
				throw new Error(`Failed to create QcStatisticalLimits: ${qcStatisticalLimits.QCStatisticalLimitsId}`);
			}
			return result;
		}
		return (await apiClient.qcStatisticalLimitsControllerCreate(qcStatisticalLimits)).data;
	},

	/**
	 * Update a QcStatisticalLimits
	 * @param qCStatisticalLimitsId - The QCStatisticalLimitsId to update
	 * @param qcStatisticalLimits - The updated QcStatisticalLimits data
	 * @returns Promise<QcStatisticalLimits>
	 */
	async qcStatisticalLimitsControllerUpdate(qCStatisticalLimitsId: string, qcStatisticalLimits: QcStatisticalLimits): Promise<QcStatisticalLimits> {
		if (getMode() === WorkMode.OFFLINE) {
			const numAffected = await db.QAQC_QCStatisticalLimits.update(qCStatisticalLimitsId, qcStatisticalLimits as any);
			let result;
			if (numAffected > 0) {
				result = await db.QAQC_QCStatisticalLimits.get(qCStatisticalLimitsId);
			}
			if (!result) {
				throw new Error(`QcStatisticalLimits not found: ${qCStatisticalLimitsId}`);
			}
			return result;
		}
		return (await apiClient.qcStatisticalLimitsControllerUpdate(qCStatisticalLimitsId, qcStatisticalLimits)).data;
	},

	/**
	 * Remove (soft delete) a QcStatisticalLimits
	 * Calls the API Remove endpoint which sets ActiveInd to false
	 * @param qCStatisticalLimitsId - The QCStatisticalLimitsId to remove
	 * @param qcStatisticalLimits - The QcStatisticalLimits data
	 * @returns Promise<QcStatisticalLimits>
	 */
	async qcStatisticalLimitsControllerRemove(qCStatisticalLimitsId: string, qcStatisticalLimits: QcStatisticalLimits): Promise<QcStatisticalLimits> {
		if (getMode() === WorkMode.OFFLINE) {
			// In offline mode, soft delete by updating ActiveInd
			const numAffected = await db.QAQC_QCStatisticalLimits.update(qCStatisticalLimitsId, { ...qcStatisticalLimits, ActiveInd: false });
			let result;
			if (numAffected > 0) {
				result = await db.QAQC_QCStatisticalLimits.get(qCStatisticalLimitsId);
			}
			if (!result) {
				throw new Error(`QcStatisticalLimits not found: ${qCStatisticalLimitsId}`);
			}
			return result;
		}
		// In online mode, call the API's Remove endpoint
		return (await apiClient.qcStatisticalLimitsControllerUpdate(qCStatisticalLimitsId, { ...qcStatisticalLimits, ActiveInd: false })).data;
	},

	/**
	 * Find a single QcType by ID
	 * @param qCTypeId - The QCTypeId to find
	 * @returns Promise<QcType>
	 */
	async qcTypeControllerFindOne(qCTypeId: string): Promise<QcType> {
		if (getMode() === WorkMode.OFFLINE) {
			const result = await db.QAQC_QCType.get(qCTypeId);
			if (!result) {
				throw new Error(`QcType not found: ${qCTypeId}`);
			}
			return result;
		}
		return (await apiClient.qcTypeControllerFindOne(qCTypeId)).data;
	},

	/**
	 * Find all QcType records with optional filtering
	 * @param query - Optional query parameters for filtering, pagination, etc.
	 * @returns Promise<QcType[]>
	 */
	async qcTypeControllerFindAll(query?: {
		page?: number;
		take?: number;
		order?: "ASC" | "DESC";
		search?: string;
		filters?: string | FilterInput;
		sorts?: string;
	}): Promise<QcType[]> {
		if (getMode() === WorkMode.OFFLINE) {
			let collection = db.QAQC_QCType.toCollection();

			// Get results as array
			let results = await collection.toArray();

			// Apply ALL filters on array
			if (query?.filters) {
				const filters = parseFiltersForDexie(query.filters);
				if (filters.length > 0) {
					for (const filter of filters) {
						const { field, op, value } = filter;
						switch (op) {
							case 'eq':
								results = results.filter((item: any) => item[field] === value);
								break;
							case 'neq':
								results = results.filter((item: any) => item[field] !== value);
								break;
							case 'gt':
								results = results.filter((item: any) => item[field] > value);
								break;
							case 'gte':
								results = results.filter((item: any) => item[field] >= value);
								break;
							case 'lt':
								results = results.filter((item: any) => item[field] < value);
								break;
							case 'lte':
								results = results.filter((item: any) => item[field] <= value);
								break;
							case 'contains':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().includes(String(value).toLowerCase())
								);
								break;
							case 'startsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().startsWith(String(value).toLowerCase())
								);
								break;
							case 'endsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().endsWith(String(value).toLowerCase())
								);
								break;
							case 'in':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => value.includes(item[field]));
								}
								break;
							case 'notIn':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => !value.includes(item[field]));
								}
								break;
						}
					}
				}
			}

			// Apply search (on array)
			if (query?.search) {
				const searchLower = query.search.toLowerCase();
				results = results.filter((item: any) =>
					Object.values(item).some(val =>
						typeof val === 'string' && val.toLowerCase().includes(searchLower)
					)
				);
			}

			// Apply sorting
			if (query?.sorts) {
				try {
					const sortFields = JSON.parse(query.sorts);
					if (Array.isArray(sortFields) && sortFields.length > 0) {
						results.sort((a: any, b: any) => {
							for (const sort of sortFields) {
								const { field, dir } = sort;
								const aVal = a[field];
								const bVal = b[field];
								if (aVal === bVal) continue;
								const comparison = aVal < bVal ? -1 : 1;
								return dir === 'desc' ? -comparison : comparison;
							}
							return 0;
						}
						);
					}
				} catch {
					// Invalid sorts format, skip
				}
			}

			// Apply pagination
			if (query?.page && query?.take) {
				const skip = (query.page - 1) * query.take;
				results = results.slice(skip, skip + query.take);
			} else if (query?.take) {
				results = results.slice(0, query.take);
			}

			return results as QcType[];
		}
		const response = await apiClient.qcTypeControllerFindAll(query);
		return (response.data as any) || [];
	},

	/**
	 * Create a new QcType
	 * @param qcType - The QcType data to create
	 * @returns Promise<QcType>
	 */
	async qcTypeControllerCreate(qcType: QcType): Promise<QcType> {
		if (getMode() === WorkMode.OFFLINE) {
			await db.QAQC_QCType.add(qcType);
			const result = await db.QAQC_QCType.get(qcType.QCTypeId);
			if (!result) {
				throw new Error(`Failed to create QcType: ${qcType.QCTypeId}`);
			}
			return result;
		}
		return (await apiClient.qcTypeControllerCreate(qcType)).data;
	},

	/**
	 * Update a QcType
	 * @param qCTypeId - The QCTypeId to update
	 * @param qcType - The updated QcType data
	 * @returns Promise<QcType>
	 */
	async qcTypeControllerUpdate(qCTypeId: string, qcType: QcType): Promise<QcType> {
		if (getMode() === WorkMode.OFFLINE) {
			const numAffected = await db.QAQC_QCType.update(qCTypeId, qcType as any);
			let result;
			if (numAffected > 0) {
				result = await db.QAQC_QCType.get(qCTypeId);
			}
			if (!result) {
				throw new Error(`QcType not found: ${qCTypeId}`);
			}
			return result;
		}
		return (await apiClient.qcTypeControllerUpdate(qCTypeId, qcType)).data;
	},

	/**
	 * Remove (soft delete) a QcType
	 * Calls the API Remove endpoint which sets ActiveInd to false
	 * @param qCTypeId - The QCTypeId to remove
	 * @param qcType - The QcType data
	 * @returns Promise<QcType>
	 */
	async qcTypeControllerRemove(qCTypeId: string, qcType: QcType): Promise<QcType> {
		if (getMode() === WorkMode.OFFLINE) {
			// In offline mode, soft delete by updating ActiveInd
			const numAffected = await db.QAQC_QCType.update(qCTypeId, { ...qcType, ActiveInd: false });
			let result;
			if (numAffected > 0) {
				result = await db.QAQC_QCType.get(qCTypeId);
			}
			if (!result) {
				throw new Error(`QcType not found: ${qCTypeId}`);
			}
			return result;
		}
		// In online mode, call the API's Remove endpoint
		return (await apiClient.qcTypeControllerUpdate(qCTypeId, { ...qcType, ActiveInd: false })).data;
	},

	/**
	 * Find a single LabDispatch by ID
	 * @param labDispatchId - The LabDispatchId to find
	 * @returns Promise<LabDispatch>
	 */
	async labDispatchControllerFindOne(labDispatchId: string): Promise<LabDispatch> {
		if (getMode() === WorkMode.OFFLINE) {
			const result = await db.Sample_LabDispatch.get(labDispatchId);
			if (!result) {
				throw new Error(`LabDispatch not found: ${labDispatchId}`);
			}
			return result;
		}
		return (await apiClient.labDispatchControllerFindOne(labDispatchId)).data;
	},

	/**
	 * Find all LabDispatch records with optional filtering
	 * @param query - Optional query parameters for filtering, pagination, etc.
	 * @returns Promise<LabDispatch[]>
	 */
	async labDispatchControllerFindAll(query?: {
		page?: number;
		take?: number;
		order?: "ASC" | "DESC";
		search?: string;
		filters?: string | FilterInput;
		sorts?: string;
	}): Promise<LabDispatch[]> {
		if (getMode() === WorkMode.OFFLINE) {
			let collection = db.Sample_LabDispatch.toCollection();

			// Get results as array
			let results = await collection.toArray();

			// Apply ALL filters on array
			if (query?.filters) {
				const filters = parseFiltersForDexie(query.filters);
				if (filters.length > 0) {
					for (const filter of filters) {
						const { field, op, value } = filter;
						switch (op) {
							case 'eq':
								results = results.filter((item: any) => item[field] === value);
								break;
							case 'neq':
								results = results.filter((item: any) => item[field] !== value);
								break;
							case 'gt':
								results = results.filter((item: any) => item[field] > value);
								break;
							case 'gte':
								results = results.filter((item: any) => item[field] >= value);
								break;
							case 'lt':
								results = results.filter((item: any) => item[field] < value);
								break;
							case 'lte':
								results = results.filter((item: any) => item[field] <= value);
								break;
							case 'contains':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().includes(String(value).toLowerCase())
								);
								break;
							case 'startsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().startsWith(String(value).toLowerCase())
								);
								break;
							case 'endsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().endsWith(String(value).toLowerCase())
								);
								break;
							case 'in':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => value.includes(item[field]));
								}
								break;
							case 'notIn':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => !value.includes(item[field]));
								}
								break;
						}
					}
				}
			}

			// Apply search (on array)
			if (query?.search) {
				const searchLower = query.search.toLowerCase();
				results = results.filter((item: any) =>
					Object.values(item).some(val =>
						typeof val === 'string' && val.toLowerCase().includes(searchLower)
					)
				);
			}

			// Apply sorting
			if (query?.sorts) {
				try {
					const sortFields = JSON.parse(query.sorts);
					if (Array.isArray(sortFields) && sortFields.length > 0) {
						results.sort((a: any, b: any) => {
							for (const sort of sortFields) {
								const { field, dir } = sort;
								const aVal = a[field];
								const bVal = b[field];
								if (aVal === bVal) continue;
								const comparison = aVal < bVal ? -1 : 1;
								return dir === 'desc' ? -comparison : comparison;
							}
							return 0;
						}
						);
					}
				} catch {
					// Invalid sorts format, skip
				}
			}

			// Apply pagination
			if (query?.page && query?.take) {
				const skip = (query.page - 1) * query.take;
				results = results.slice(skip, skip + query.take);
			} else if (query?.take) {
				results = results.slice(0, query.take);
			}

			return results as LabDispatch[];
		}
		const response = await apiClient.labDispatchControllerFindAll(query);
		return (response.data as any) || [];
	},

	/**
	 * Create a new LabDispatch
	 * @param labDispatch - The LabDispatch data to create
	 * @returns Promise<LabDispatch>
	 */
	async labDispatchControllerCreate(labDispatch: LabDispatch): Promise<LabDispatch> {
		if (getMode() === WorkMode.OFFLINE) {
			await db.Sample_LabDispatch.add(labDispatch);
			const result = await db.Sample_LabDispatch.get(labDispatch.LabDispatchId);
			if (!result) {
				throw new Error(`Failed to create LabDispatch: ${labDispatch.LabDispatchId}`);
			}
			return result;
		}
		return (await apiClient.labDispatchControllerCreate(labDispatch)).data;
	},

	/**
	 * Update a LabDispatch
	 * @param labDispatchId - The LabDispatchId to update
	 * @param labDispatch - The updated LabDispatch data
	 * @returns Promise<LabDispatch>
	 */
	async labDispatchControllerUpdate(labDispatchId: string, labDispatch: LabDispatch): Promise<LabDispatch> {
		if (getMode() === WorkMode.OFFLINE) {
			const numAffected = await db.Sample_LabDispatch.update(labDispatchId, labDispatch as any);
			let result;
			if (numAffected > 0) {
				result = await db.Sample_LabDispatch.get(labDispatchId);
			}
			if (!result) {
				throw new Error(`LabDispatch not found: ${labDispatchId}`);
			}
			return result;
		}
		return (await apiClient.labDispatchControllerUpdate(labDispatchId, labDispatch)).data;
	},

	/**
	 * Remove (soft delete) a LabDispatch
	 * Calls the API Remove endpoint which sets ActiveInd to false
	 * @param labDispatchId - The LabDispatchId to remove
	 * @param labDispatch - The LabDispatch data
	 * @returns Promise<LabDispatch>
	 */
	async labDispatchControllerRemove(labDispatchId: string, labDispatch: LabDispatch): Promise<LabDispatch> {
		if (getMode() === WorkMode.OFFLINE) {
			// In offline mode, soft delete by updating ActiveInd
			const numAffected = await db.Sample_LabDispatch.update(labDispatchId, { ...labDispatch, ActiveInd: false });
			let result;
			if (numAffected > 0) {
				result = await db.Sample_LabDispatch.get(labDispatchId);
			}
			if (!result) {
				throw new Error(`LabDispatch not found: ${labDispatchId}`);
			}
			return result;
		}
		// In online mode, call the API's Remove endpoint
		return (await apiClient.labDispatchControllerUpdate(labDispatchId, { ...labDispatch, ActiveInd: false })).data;
	},

	/**
	 * Find a single Config by ID
	 * @param configId - The ConfigId to find
	 * @returns Promise<Config>
	 */
	async configControllerFindOne(configId: string): Promise<Config> {
		if (getMode() === WorkMode.OFFLINE) {
			const result = await db.System_Config.get(configId);
			if (!result) {
				throw new Error(`Config not found: ${configId}`);
			}
			return result;
		}
		return (await apiClient.configControllerFindOne(configId)).data;
	},

	/**
	 * Find all Config records with optional filtering
	 * @param query - Optional query parameters for filtering, pagination, etc.
	 * @returns Promise<Config[]>
	 */
	async configControllerFindAll(query?: {
		page?: number;
		take?: number;
		order?: "ASC" | "DESC";
		search?: string;
		filters?: string | FilterInput;
		sorts?: string;
	}): Promise<Config[]> {
		if (getMode() === WorkMode.OFFLINE) {
			let collection = db.System_Config.toCollection();

			// Get results as array
			let results = await collection.toArray();

			// Apply ALL filters on array
			if (query?.filters) {
				const filters = parseFiltersForDexie(query.filters);
				if (filters.length > 0) {
					for (const filter of filters) {
						const { field, op, value } = filter;
						switch (op) {
							case 'eq':
								results = results.filter((item: any) => item[field] === value);
								break;
							case 'neq':
								results = results.filter((item: any) => item[field] !== value);
								break;
							case 'gt':
								results = results.filter((item: any) => item[field] > value);
								break;
							case 'gte':
								results = results.filter((item: any) => item[field] >= value);
								break;
							case 'lt':
								results = results.filter((item: any) => item[field] < value);
								break;
							case 'lte':
								results = results.filter((item: any) => item[field] <= value);
								break;
							case 'contains':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().includes(String(value).toLowerCase())
								);
								break;
							case 'startsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().startsWith(String(value).toLowerCase())
								);
								break;
							case 'endsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().endsWith(String(value).toLowerCase())
								);
								break;
							case 'in':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => value.includes(item[field]));
								}
								break;
							case 'notIn':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => !value.includes(item[field]));
								}
								break;
						}
					}
				}
			}

			// Apply search (on array)
			if (query?.search) {
				const searchLower = query.search.toLowerCase();
				results = results.filter((item: any) =>
					Object.values(item).some(val =>
						typeof val === 'string' && val.toLowerCase().includes(searchLower)
					)
				);
			}

			// Apply sorting
			if (query?.sorts) {
				try {
					const sortFields = JSON.parse(query.sorts);
					if (Array.isArray(sortFields) && sortFields.length > 0) {
						results.sort((a: any, b: any) => {
							for (const sort of sortFields) {
								const { field, dir } = sort;
								const aVal = a[field];
								const bVal = b[field];
								if (aVal === bVal) continue;
								const comparison = aVal < bVal ? -1 : 1;
								return dir === 'desc' ? -comparison : comparison;
							}
							return 0;
						}
						);
					}
				} catch {
					// Invalid sorts format, skip
				}
			}

			// Apply pagination
			if (query?.page && query?.take) {
				const skip = (query.page - 1) * query.take;
				results = results.slice(skip, skip + query.take);
			} else if (query?.take) {
				results = results.slice(0, query.take);
			}

			return results as Config[];
		}
		const response = await apiClient.configControllerFindAll(query);
		return (response.data as any) || [];
	},

	/**
	 * Create a new Config
	 * @param config - The Config data to create
	 * @returns Promise<Config>
	 */
	async configControllerCreate(config: Config): Promise<Config> {
		if (getMode() === WorkMode.OFFLINE) {
			await db.System_Config.add(config);
			const result = await db.System_Config.get(config.ConfigId);
			if (!result) {
				throw new Error(`Failed to create Config: ${config.ConfigId}`);
			}
			return result;
		}
		return (await apiClient.configControllerCreate(config)).data;
	},

	/**
	 * Update a Config
	 * @param configId - The ConfigId to update
	 * @param config - The updated Config data
	 * @returns Promise<Config>
	 */
	async configControllerUpdate(configId: string, config: Config): Promise<Config> {
		if (getMode() === WorkMode.OFFLINE) {
			const numAffected = await db.System_Config.update(configId, config as any);
			let result;
			if (numAffected > 0) {
				result = await db.System_Config.get(configId);
			}
			if (!result) {
				throw new Error(`Config not found: ${configId}`);
			}
			return result;
		}
		return (await apiClient.configControllerUpdate(configId, config)).data;
	},

	/**
	 * Remove (soft delete) a Config
	 * Calls the API Remove endpoint which sets ActiveInd to false
	 * @param configId - The ConfigId to remove
	 * @param config - The Config data
	 * @returns Promise<Config>
	 */
	async configControllerRemove(configId: string, config: Config): Promise<Config> {
		if (getMode() === WorkMode.OFFLINE) {
			// In offline mode, soft delete by updating ActiveInd
			const numAffected = await db.System_Config.update(configId, { ...config, ActiveInd: false });
			let result;
			if (numAffected > 0) {
				result = await db.System_Config.get(configId);
			}
			if (!result) {
				throw new Error(`Config not found: ${configId}`);
			}
			return result;
		}
		// In online mode, call the API's Remove endpoint
		return (await apiClient.configControllerUpdate(configId, { ...config, ActiveInd: false })).data;
	},

	/**
	 * Find a single LookUpNormalization by ID
	 * @param lookUpNormalizationId - The LookUpNormalizationId to find
	 * @returns Promise<LookUpNormalization>
	 */
	async lookUpNormalizationControllerFindOne(lookUpNormalizationId: string): Promise<LookUpNormalization> {
		if (getMode() === WorkMode.OFFLINE) {
			const result = await db.System_LookUpNormalization.get(lookUpNormalizationId);
			if (!result) {
				throw new Error(`LookUpNormalization not found: ${lookUpNormalizationId}`);
			}
			return result;
		}
		return (await apiClient.lookUpNormalizationControllerFindOne(lookUpNormalizationId)).data;
	},

	/**
	 * Find all LookUpNormalization records with optional filtering
	 * @param query - Optional query parameters for filtering, pagination, etc.
	 * @returns Promise<LookUpNormalization[]>
	 */
	async lookUpNormalizationControllerFindAll(query?: {
		page?: number;
		take?: number;
		order?: "ASC" | "DESC";
		search?: string;
		filters?: string | FilterInput;
		sorts?: string;
	}): Promise<LookUpNormalization[]> {
		if (getMode() === WorkMode.OFFLINE) {
			let collection = db.System_LookUpNormalization.toCollection();

			// Get results as array
			let results = await collection.toArray();

			// Apply ALL filters on array
			if (query?.filters) {
				const filters = parseFiltersForDexie(query.filters);
				if (filters.length > 0) {
					for (const filter of filters) {
						const { field, op, value } = filter;
						switch (op) {
							case 'eq':
								results = results.filter((item: any) => item[field] === value);
								break;
							case 'neq':
								results = results.filter((item: any) => item[field] !== value);
								break;
							case 'gt':
								results = results.filter((item: any) => item[field] > value);
								break;
							case 'gte':
								results = results.filter((item: any) => item[field] >= value);
								break;
							case 'lt':
								results = results.filter((item: any) => item[field] < value);
								break;
							case 'lte':
								results = results.filter((item: any) => item[field] <= value);
								break;
							case 'contains':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().includes(String(value).toLowerCase())
								);
								break;
							case 'startsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().startsWith(String(value).toLowerCase())
								);
								break;
							case 'endsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().endsWith(String(value).toLowerCase())
								);
								break;
							case 'in':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => value.includes(item[field]));
								}
								break;
							case 'notIn':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => !value.includes(item[field]));
								}
								break;
						}
					}
				}
			}

			// Apply search (on array)
			if (query?.search) {
				const searchLower = query.search.toLowerCase();
				results = results.filter((item: any) =>
					Object.values(item).some(val =>
						typeof val === 'string' && val.toLowerCase().includes(searchLower)
					)
				);
			}

			// Apply sorting
			if (query?.sorts) {
				try {
					const sortFields = JSON.parse(query.sorts);
					if (Array.isArray(sortFields) && sortFields.length > 0) {
						results.sort((a: any, b: any) => {
							for (const sort of sortFields) {
								const { field, dir } = sort;
								const aVal = a[field];
								const bVal = b[field];
								if (aVal === bVal) continue;
								const comparison = aVal < bVal ? -1 : 1;
								return dir === 'desc' ? -comparison : comparison;
							}
							return 0;
						}
						);
					}
				} catch {
					// Invalid sorts format, skip
				}
			}

			// Apply pagination
			if (query?.page && query?.take) {
				const skip = (query.page - 1) * query.take;
				results = results.slice(skip, skip + query.take);
			} else if (query?.take) {
				results = results.slice(0, query.take);
			}

			return results as LookUpNormalization[];
		}
		const response = await apiClient.lookUpNormalizationControllerFindAll(query);
		return (response.data as any) || [];
	},

	/**
	 * Create a new LookUpNormalization
	 * @param lookUpNormalization - The LookUpNormalization data to create
	 * @returns Promise<LookUpNormalization>
	 */
	async lookUpNormalizationControllerCreate(lookUpNormalization: LookUpNormalization): Promise<LookUpNormalization> {
		if (getMode() === WorkMode.OFFLINE) {
			await db.System_LookUpNormalization.add(lookUpNormalization);
			const result = await db.System_LookUpNormalization.get(lookUpNormalization.LookUpNormalizationId);
			if (!result) {
				throw new Error(`Failed to create LookUpNormalization: ${lookUpNormalization.LookUpNormalizationId}`);
			}
			return result;
		}
		return (await apiClient.lookUpNormalizationControllerCreate(lookUpNormalization)).data;
	},

	/**
	 * Update a LookUpNormalization
	 * @param lookUpNormalizationId - The LookUpNormalizationId to update
	 * @param lookUpNormalization - The updated LookUpNormalization data
	 * @returns Promise<LookUpNormalization>
	 */
	async lookUpNormalizationControllerUpdate(lookUpNormalizationId: string, lookUpNormalization: LookUpNormalization): Promise<LookUpNormalization> {
		if (getMode() === WorkMode.OFFLINE) {
			const numAffected = await db.System_LookUpNormalization.update(lookUpNormalizationId, lookUpNormalization as any);
			let result;
			if (numAffected > 0) {
				result = await db.System_LookUpNormalization.get(lookUpNormalizationId);
			}
			if (!result) {
				throw new Error(`LookUpNormalization not found: ${lookUpNormalizationId}`);
			}
			return result;
		}
		return (await apiClient.lookUpNormalizationControllerUpdate(lookUpNormalizationId, lookUpNormalization)).data;
	},

	/**
	 * Remove (soft delete) a LookUpNormalization
	 * Calls the API Remove endpoint which sets ActiveInd to false
	 * @param lookUpNormalizationId - The LookUpNormalizationId to remove
	 * @param lookUpNormalization - The LookUpNormalization data
	 * @returns Promise<LookUpNormalization>
	 */
	async lookUpNormalizationControllerRemove(lookUpNormalizationId: string, lookUpNormalization: LookUpNormalization): Promise<LookUpNormalization> {
		if (getMode() === WorkMode.OFFLINE) {
			// In offline mode, soft delete by updating ActiveInd
			const numAffected = await db.System_LookUpNormalization.update(lookUpNormalizationId, { ...lookUpNormalization, ActiveInd: false });
			let result;
			if (numAffected > 0) {
				result = await db.System_LookUpNormalization.get(lookUpNormalizationId);
			}
			if (!result) {
				throw new Error(`LookUpNormalization not found: ${lookUpNormalizationId}`);
			}
			return result;
		}
		// In online mode, call the API's Remove endpoint
		return (await apiClient.lookUpNormalizationControllerUpdate(lookUpNormalizationId, { ...lookUpNormalization, ActiveInd: false })).data;
	},

	/**
	 * Find a single PickList by ID
	 * @param pickListId - The PickListId to find
	 * @returns Promise<PickList>
	 */
	async pickListControllerFindOne(pickListId: string): Promise<PickList> {
		if (getMode() === WorkMode.OFFLINE) {
			const result = await db.System_PickList.get(pickListId);
			if (!result) {
				throw new Error(`PickList not found: ${pickListId}`);
			}
			return result;
		}
		return (await apiClient.pickListControllerFindOne(pickListId)).data;
	},

	/**
	 * Find all PickList records with optional filtering
	 * @param query - Optional query parameters for filtering, pagination, etc.
	 * @returns Promise<PickList[]>
	 */
	async pickListControllerFindAll(query?: {
		page?: number;
		take?: number;
		order?: "ASC" | "DESC";
		search?: string;
		filters?: string | FilterInput;
		sorts?: string;
	}): Promise<PickList[]> {
		if (getMode() === WorkMode.OFFLINE) {
			let collection = db.System_PickList.toCollection();

			// Get results as array
			let results = await collection.toArray();

			// Apply ALL filters on array
			if (query?.filters) {
				const filters = parseFiltersForDexie(query.filters);
				if (filters.length > 0) {
					for (const filter of filters) {
						const { field, op, value } = filter;
						switch (op) {
							case 'eq':
								results = results.filter((item: any) => item[field] === value);
								break;
							case 'neq':
								results = results.filter((item: any) => item[field] !== value);
								break;
							case 'gt':
								results = results.filter((item: any) => item[field] > value);
								break;
							case 'gte':
								results = results.filter((item: any) => item[field] >= value);
								break;
							case 'lt':
								results = results.filter((item: any) => item[field] < value);
								break;
							case 'lte':
								results = results.filter((item: any) => item[field] <= value);
								break;
							case 'contains':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().includes(String(value).toLowerCase())
								);
								break;
							case 'startsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().startsWith(String(value).toLowerCase())
								);
								break;
							case 'endsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().endsWith(String(value).toLowerCase())
								);
								break;
							case 'in':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => value.includes(item[field]));
								}
								break;
							case 'notIn':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => !value.includes(item[field]));
								}
								break;
						}
					}
				}
			}

			// Apply search (on array)
			if (query?.search) {
				const searchLower = query.search.toLowerCase();
				results = results.filter((item: any) =>
					Object.values(item).some(val =>
						typeof val === 'string' && val.toLowerCase().includes(searchLower)
					)
				);
			}

			// Apply sorting
			if (query?.sorts) {
				try {
					const sortFields = JSON.parse(query.sorts);
					if (Array.isArray(sortFields) && sortFields.length > 0) {
						results.sort((a: any, b: any) => {
							for (const sort of sortFields) {
								const { field, dir } = sort;
								const aVal = a[field];
								const bVal = b[field];
								if (aVal === bVal) continue;
								const comparison = aVal < bVal ? -1 : 1;
								return dir === 'desc' ? -comparison : comparison;
							}
							return 0;
						}
						);
					}
				} catch {
					// Invalid sorts format, skip
				}
			}

			// Apply pagination
			if (query?.page && query?.take) {
				const skip = (query.page - 1) * query.take;
				results = results.slice(skip, skip + query.take);
			} else if (query?.take) {
				results = results.slice(0, query.take);
			}

			return results as PickList[];
		}
		const response = await apiClient.pickListControllerFindAll(query);
		return (response.data as any) || [];
	},

	/**
	 * Create a new PickList
	 * @param pickList - The PickList data to create
	 * @returns Promise<PickList>
	 */
	async pickListControllerCreate(pickList: PickList): Promise<PickList> {
		if (getMode() === WorkMode.OFFLINE) {
			await db.System_PickList.add(pickList);
			const result = await db.System_PickList.get(pickList.PickListId);
			if (!result) {
				throw new Error(`Failed to create PickList: ${pickList.PickListId}`);
			}
			return result;
		}
		return (await apiClient.pickListControllerCreate(pickList)).data;
	},

	/**
	 * Update a PickList
	 * @param pickListId - The PickListId to update
	 * @param pickList - The updated PickList data
	 * @returns Promise<PickList>
	 */
	async pickListControllerUpdate(pickListId: string, pickList: PickList): Promise<PickList> {
		if (getMode() === WorkMode.OFFLINE) {
			const numAffected = await db.System_PickList.update(pickListId, pickList as any);
			let result;
			if (numAffected > 0) {
				result = await db.System_PickList.get(pickListId);
			}
			if (!result) {
				throw new Error(`PickList not found: ${pickListId}`);
			}
			return result;
		}
		return (await apiClient.pickListControllerUpdate(pickListId, pickList)).data;
	},

	/**
	 * Remove (soft delete) a PickList
	 * Calls the API Remove endpoint which sets ActiveInd to false
	 * @param pickListId - The PickListId to remove
	 * @param pickList - The PickList data
	 * @returns Promise<PickList>
	 */
	async pickListControllerRemove(pickListId: string, pickList: PickList): Promise<PickList> {
		if (getMode() === WorkMode.OFFLINE) {
			// In offline mode, soft delete by updating ActiveInd
			const numAffected = await db.System_PickList.update(pickListId, { ...pickList, ActiveInd: false });
			let result;
			if (numAffected > 0) {
				result = await db.System_PickList.get(pickListId);
			}
			if (!result) {
				throw new Error(`PickList not found: ${pickListId}`);
			}
			return result;
		}
		// In online mode, call the API's Remove endpoint
		return (await apiClient.pickListControllerUpdate(pickListId, { ...pickList, ActiveInd: false })).data;
	},

	/**
	 * Find a single PickListUser by ID
	 * @param pickListUserId - The PickListUserId to find
	 * @returns Promise<PickListUser>
	 */
	async pickListUserControllerFindOne(pickListUserId: string): Promise<PickListUser> {
		if (getMode() === WorkMode.OFFLINE) {
			const result = await db.System_PickListUser.get(pickListUserId);
			if (!result) {
				throw new Error(`PickListUser not found: ${pickListUserId}`);
			}
			return result;
		}
		return (await apiClient.pickListUserControllerFindOne(pickListUserId)).data;
	},

	/**
	 * Find all PickListUser records with optional filtering
	 * @param query - Optional query parameters for filtering, pagination, etc.
	 * @returns Promise<PickListUser[]>
	 */
	async pickListUserControllerFindAll(query?: {
		page?: number;
		take?: number;
		order?: "ASC" | "DESC";
		search?: string;
		filters?: string | FilterInput;
		sorts?: string;
	}): Promise<PickListUser[]> {
		if (getMode() === WorkMode.OFFLINE) {
			let collection = db.System_PickListUser.toCollection();

			// Get results as array
			let results = await collection.toArray();

			// Apply ALL filters on array
			if (query?.filters) {
				const filters = parseFiltersForDexie(query.filters);
				if (filters.length > 0) {
					for (const filter of filters) {
						const { field, op, value } = filter;
						switch (op) {
							case 'eq':
								results = results.filter((item: any) => item[field] === value);
								break;
							case 'neq':
								results = results.filter((item: any) => item[field] !== value);
								break;
							case 'gt':
								results = results.filter((item: any) => item[field] > value);
								break;
							case 'gte':
								results = results.filter((item: any) => item[field] >= value);
								break;
							case 'lt':
								results = results.filter((item: any) => item[field] < value);
								break;
							case 'lte':
								results = results.filter((item: any) => item[field] <= value);
								break;
							case 'contains':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().includes(String(value).toLowerCase())
								);
								break;
							case 'startsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().startsWith(String(value).toLowerCase())
								);
								break;
							case 'endsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().endsWith(String(value).toLowerCase())
								);
								break;
							case 'in':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => value.includes(item[field]));
								}
								break;
							case 'notIn':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => !value.includes(item[field]));
								}
								break;
						}
					}
				}
			}

			// Apply search (on array)
			if (query?.search) {
				const searchLower = query.search.toLowerCase();
				results = results.filter((item: any) =>
					Object.values(item).some(val =>
						typeof val === 'string' && val.toLowerCase().includes(searchLower)
					)
				);
			}

			// Apply sorting
			if (query?.sorts) {
				try {
					const sortFields = JSON.parse(query.sorts);
					if (Array.isArray(sortFields) && sortFields.length > 0) {
						results.sort((a: any, b: any) => {
							for (const sort of sortFields) {
								const { field, dir } = sort;
								const aVal = a[field];
								const bVal = b[field];
								if (aVal === bVal) continue;
								const comparison = aVal < bVal ? -1 : 1;
								return dir === 'desc' ? -comparison : comparison;
							}
							return 0;
						}
						);
					}
				} catch {
					// Invalid sorts format, skip
				}
			}

			// Apply pagination
			if (query?.page && query?.take) {
				const skip = (query.page - 1) * query.take;
				results = results.slice(skip, skip + query.take);
			} else if (query?.take) {
				results = results.slice(0, query.take);
			}

			return results as PickListUser[];
		}
		const response = await apiClient.pickListUserControllerFindAll(query);
		return (response.data as any) || [];
	},

	/**
	 * Create a new PickListUser
	 * @param pickListUser - The PickListUser data to create
	 * @returns Promise<PickListUser>
	 */
	async pickListUserControllerCreate(pickListUser: PickListUser): Promise<PickListUser> {
		if (getMode() === WorkMode.OFFLINE) {
			await db.System_PickListUser.add(pickListUser);
			const result = await db.System_PickListUser.get(pickListUser.PickListUserId);
			if (!result) {
				throw new Error(`Failed to create PickListUser: ${pickListUser.PickListUserId}`);
			}
			return result;
		}
		return (await apiClient.pickListUserControllerCreate(pickListUser)).data;
	},

	/**
	 * Update a PickListUser
	 * @param pickListUserId - The PickListUserId to update
	 * @param pickListUser - The updated PickListUser data
	 * @returns Promise<PickListUser>
	 */
	async pickListUserControllerUpdate(pickListUserId: string, pickListUser: PickListUser): Promise<PickListUser> {
		if (getMode() === WorkMode.OFFLINE) {
			const numAffected = await db.System_PickListUser.update(pickListUserId, pickListUser as any);
			let result;
			if (numAffected > 0) {
				result = await db.System_PickListUser.get(pickListUserId);
			}
			if (!result) {
				throw new Error(`PickListUser not found: ${pickListUserId}`);
			}
			return result;
		}
		return (await apiClient.pickListUserControllerUpdate(pickListUserId, pickListUser)).data;
	},

	/**
	 * Remove (soft delete) a PickListUser
	 * Calls the API Remove endpoint which sets ActiveInd to false
	 * @param pickListUserId - The PickListUserId to remove
	 * @param pickListUser - The PickListUser data
	 * @returns Promise<PickListUser>
	 */
	async pickListUserControllerRemove(pickListUserId: string, pickListUser: PickListUser): Promise<PickListUser> {
		if (getMode() === WorkMode.OFFLINE) {
			// In offline mode, soft delete by updating ActiveInd
			const numAffected = await db.System_PickListUser.update(pickListUserId, { ...pickListUser, ActiveInd: false });
			let result;
			if (numAffected > 0) {
				result = await db.System_PickListUser.get(pickListUserId);
			}
			if (!result) {
				throw new Error(`PickListUser not found: ${pickListUserId}`);
			}
			return result;
		}
		// In online mode, call the API's Remove endpoint
		return (await apiClient.pickListUserControllerUpdate(pickListUserId, { ...pickListUser, ActiveInd: false })).data;
	},

	/**
	 * Find a single PickListValue by ID
	 * @param pickListValueId - The PickListValueId to find
	 * @returns Promise<PickListValue>
	 */
	async pickListValueControllerFindOne(pickListValueId: string): Promise<PickListValue> {
		if (getMode() === WorkMode.OFFLINE) {
			const result = await db.System_PickListValue.get(pickListValueId);
			if (!result) {
				throw new Error(`PickListValue not found: ${pickListValueId}`);
			}
			return result;
		}
		return (await apiClient.pickListValueControllerFindOne(pickListValueId)).data;
	},

	/**
	 * Find all PickListValue records with optional filtering
	 * @param query - Optional query parameters for filtering, pagination, etc.
	 * @returns Promise<PickListValue[]>
	 */
	async pickListValueControllerFindAll(query?: {
		page?: number;
		take?: number;
		order?: "ASC" | "DESC";
		search?: string;
		filters?: string | FilterInput;
		sorts?: string;
	}): Promise<PickListValue[]> {
		if (getMode() === WorkMode.OFFLINE) {
			let collection = db.System_PickListValue.toCollection();

			// Get results as array
			let results = await collection.toArray();

			// Apply ALL filters on array
			if (query?.filters) {
				const filters = parseFiltersForDexie(query.filters);
				if (filters.length > 0) {
					for (const filter of filters) {
						const { field, op, value } = filter;
						switch (op) {
							case 'eq':
								results = results.filter((item: any) => item[field] === value);
								break;
							case 'neq':
								results = results.filter((item: any) => item[field] !== value);
								break;
							case 'gt':
								results = results.filter((item: any) => item[field] > value);
								break;
							case 'gte':
								results = results.filter((item: any) => item[field] >= value);
								break;
							case 'lt':
								results = results.filter((item: any) => item[field] < value);
								break;
							case 'lte':
								results = results.filter((item: any) => item[field] <= value);
								break;
							case 'contains':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().includes(String(value).toLowerCase())
								);
								break;
							case 'startsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().startsWith(String(value).toLowerCase())
								);
								break;
							case 'endsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().endsWith(String(value).toLowerCase())
								);
								break;
							case 'in':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => value.includes(item[field]));
								}
								break;
							case 'notIn':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => !value.includes(item[field]));
								}
								break;
						}
					}
				}
			}

			// Apply search (on array)
			if (query?.search) {
				const searchLower = query.search.toLowerCase();
				results = results.filter((item: any) =>
					Object.values(item).some(val =>
						typeof val === 'string' && val.toLowerCase().includes(searchLower)
					)
				);
			}

			// Apply sorting
			if (query?.sorts) {
				try {
					const sortFields = JSON.parse(query.sorts);
					if (Array.isArray(sortFields) && sortFields.length > 0) {
						results.sort((a: any, b: any) => {
							for (const sort of sortFields) {
								const { field, dir } = sort;
								const aVal = a[field];
								const bVal = b[field];
								if (aVal === bVal) continue;
								const comparison = aVal < bVal ? -1 : 1;
								return dir === 'desc' ? -comparison : comparison;
							}
							return 0;
						}
						);
					}
				} catch {
					// Invalid sorts format, skip
				}
			}

			// Apply pagination
			if (query?.page && query?.take) {
				const skip = (query.page - 1) * query.take;
				results = results.slice(skip, skip + query.take);
			} else if (query?.take) {
				results = results.slice(0, query.take);
			}

			return results as PickListValue[];
		}
		const response = await apiClient.pickListValueControllerFindAll(query);
		return (response.data as any) || [];
	},

	/**
	 * Create a new PickListValue
	 * @param pickListValue - The PickListValue data to create
	 * @returns Promise<PickListValue>
	 */
	async pickListValueControllerCreate(pickListValue: PickListValue): Promise<PickListValue> {
		if (getMode() === WorkMode.OFFLINE) {
			await db.System_PickListValue.add(pickListValue);
			const result = await db.System_PickListValue.get(pickListValue.PickListValueId);
			if (!result) {
				throw new Error(`Failed to create PickListValue: ${pickListValue.PickListValueId}`);
			}
			return result;
		}
		return (await apiClient.pickListValueControllerCreate(pickListValue)).data;
	},

	/**
	 * Update a PickListValue
	 * @param pickListValueId - The PickListValueId to update
	 * @param pickListValue - The updated PickListValue data
	 * @returns Promise<PickListValue>
	 */
	async pickListValueControllerUpdate(pickListValueId: string, pickListValue: PickListValue): Promise<PickListValue> {
		if (getMode() === WorkMode.OFFLINE) {
			const numAffected = await db.System_PickListValue.update(pickListValueId, pickListValue as any);
			let result;
			if (numAffected > 0) {
				result = await db.System_PickListValue.get(pickListValueId);
			}
			if (!result) {
				throw new Error(`PickListValue not found: ${pickListValueId}`);
			}
			return result;
		}
		return (await apiClient.pickListValueControllerUpdate(pickListValueId, pickListValue)).data;
	},

	/**
	 * Remove (soft delete) a PickListValue
	 * Calls the API Remove endpoint which sets ActiveInd to false
	 * @param pickListValueId - The PickListValueId to remove
	 * @param pickListValue - The PickListValue data
	 * @returns Promise<PickListValue>
	 */
	async pickListValueControllerRemove(pickListValueId: string, pickListValue: PickListValue): Promise<PickListValue> {
		if (getMode() === WorkMode.OFFLINE) {
			// In offline mode, soft delete by updating ActiveInd
			const numAffected = await db.System_PickListValue.update(pickListValueId, { ...pickListValue, ActiveInd: false });
			let result;
			if (numAffected > 0) {
				result = await db.System_PickListValue.get(pickListValueId);
			}
			if (!result) {
				throw new Error(`PickListValue not found: ${pickListValueId}`);
			}
			return result;
		}
		// In online mode, call the API's Remove endpoint
		return (await apiClient.pickListValueControllerUpdate(pickListValueId, { ...pickListValue, ActiveInd: false })).data;
	},

	/**
	 * Find a single Template by ID
	 * @param templateId - The TemplateId to find
	 * @returns Promise<Template>
	 */
	async templateControllerFindOne(templateId: string): Promise<Template> {
		if (getMode() === WorkMode.OFFLINE) {
			const result = await db.System_Template.get(templateId);
			if (!result) {
				throw new Error(`Template not found: ${templateId}`);
			}
			return result;
		}
		return (await apiClient.templateControllerFindOne(templateId)).data;
	},

	/**
	 * Find all Template records with optional filtering
	 * @param query - Optional query parameters for filtering, pagination, etc.
	 * @returns Promise<Template[]>
	 */
	async templateControllerFindAll(query?: {
		page?: number;
		take?: number;
		order?: "ASC" | "DESC";
		search?: string;
		filters?: string | FilterInput;
		sorts?: string;
	}): Promise<Template[]> {
		if (getMode() === WorkMode.OFFLINE) {
			let collection = db.System_Template.toCollection();

			// Get results as array
			let results = await collection.toArray();

			// Apply ALL filters on array
			if (query?.filters) {
				const filters = parseFiltersForDexie(query.filters);
				if (filters.length > 0) {
					for (const filter of filters) {
						const { field, op, value } = filter;
						switch (op) {
							case 'eq':
								results = results.filter((item: any) => item[field] === value);
								break;
							case 'neq':
								results = results.filter((item: any) => item[field] !== value);
								break;
							case 'gt':
								results = results.filter((item: any) => item[field] > value);
								break;
							case 'gte':
								results = results.filter((item: any) => item[field] >= value);
								break;
							case 'lt':
								results = results.filter((item: any) => item[field] < value);
								break;
							case 'lte':
								results = results.filter((item: any) => item[field] <= value);
								break;
							case 'contains':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().includes(String(value).toLowerCase())
								);
								break;
							case 'startsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().startsWith(String(value).toLowerCase())
								);
								break;
							case 'endsWith':
								results = results.filter((item: any) =>
									String(item[field] ?? '').toLowerCase().endsWith(String(value).toLowerCase())
								);
								break;
							case 'in':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => value.includes(item[field]));
								}
								break;
							case 'notIn':
								if (Array.isArray(value)) {
									results = results.filter((item: any) => !value.includes(item[field]));
								}
								break;
						}
					}
				}
			}

			// Apply search (on array)
			if (query?.search) {
				const searchLower = query.search.toLowerCase();
				results = results.filter((item: any) =>
					Object.values(item).some(val =>
						typeof val === 'string' && val.toLowerCase().includes(searchLower)
					)
				);
			}

			// Apply sorting
			if (query?.sorts) {
				try {
					const sortFields = JSON.parse(query.sorts);
					if (Array.isArray(sortFields) && sortFields.length > 0) {
						results.sort((a: any, b: any) => {
							for (const sort of sortFields) {
								const { field, dir } = sort;
								const aVal = a[field];
								const bVal = b[field];
								if (aVal === bVal) continue;
								const comparison = aVal < bVal ? -1 : 1;
								return dir === 'desc' ? -comparison : comparison;
							}
							return 0;
						}
						);
					}
				} catch {
					// Invalid sorts format, skip
				}
			}

			// Apply pagination
			if (query?.page && query?.take) {
				const skip = (query.page - 1) * query.take;
				results = results.slice(skip, skip + query.take);
			} else if (query?.take) {
				results = results.slice(0, query.take);
			}

			return results as Template[];
		}
		const response = await apiClient.templateControllerFindAll(query);
		return (response.data as any) || [];
	},

	/**
	 * Create a new Template
	 * @param template - The Template data to create
	 * @returns Promise<Template>
	 */
	async templateControllerCreate(template: Template): Promise<Template> {
		if (getMode() === WorkMode.OFFLINE) {
			await db.System_Template.add(template);
			const result = await db.System_Template.get(template.TemplateId);
			if (!result) {
				throw new Error(`Failed to create Template: ${template.TemplateId}`);
			}
			return result;
		}
		return (await apiClient.templateControllerCreate(template)).data;
	},

	/**
	 * Update a Template
	 * @param templateId - The TemplateId to update
	 * @param template - The updated Template data
	 * @returns Promise<Template>
	 */
	async templateControllerUpdate(templateId: string, template: Template): Promise<Template> {
		if (getMode() === WorkMode.OFFLINE) {
			const numAffected = await db.System_Template.update(templateId, template as any);
			let result;
			if (numAffected > 0) {
				result = await db.System_Template.get(templateId);
			}
			if (!result) {
				throw new Error(`Template not found: ${templateId}`);
			}
			return result;
		}
		return (await apiClient.templateControllerUpdate(templateId, template)).data;
	},

	/**
	 * Remove (soft delete) a Template
	 * Calls the API Remove endpoint which sets ActiveInd to false
	 * @param templateId - The TemplateId to remove
	 * @param template - The Template data
	 * @returns Promise<Template>
	 */
	async templateControllerRemove(templateId: string, template: Template): Promise<Template> {
		if (getMode() === WorkMode.OFFLINE) {
			// In offline mode, soft delete by updating ActiveInd
			const numAffected = await db.System_Template.update(templateId, { ...template, ActiveInd: false });
			let result;
			if (numAffected > 0) {
				result = await db.System_Template.get(templateId);
			}
			if (!result) {
				throw new Error(`Template not found: ${templateId}`);
			}
			return result;
		}
		// In online mode, call the API's Remove endpoint
		return (await apiClient.templateControllerUpdate(templateId, { ...template, ActiveInd: false })).data;
	},
};

export default dataLayer;
